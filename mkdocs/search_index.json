{
    "docs": [
        {
            "location": "/", 
            "text": "sciebo@Learnweb\n\n\nDiese Website dokumentiert die Integration von \nsciebo\n in das \nLearnweb\n, die durch das Projektseminar \nsciebo@Learnweb\n im Wintersemester 2016/17 an der \nWestf\u00e4lischen Wilhelms-Universit\u00e4t M\u00fcnster\n realisiert wurde.\n\n\nSciebo ist ein Cloud-Dienst, der gemeinsam von 26 Hochschulen und Forschungseinrichtungen in NRW angeboten wird. Als Grundlage dient die Enterprise-Edition von \nownCloud\n. Das Learnweb ist ein auf der Open-Source-L\u00f6sung \nMoodle\n basierendes E-Learning System der Westf\u00e4lischen Wilhelms-Universit\u00e4t M\u00fcnster.\n\n\nStruktur der Dokumentation\n\n\nDie vorliegende Dokumentation ist in mehrere Teile gegliedert. Neben der Startseite (auf der Sie sich momentan befinden), gibt es die Abschnitte \nownCloud\n und \nMoodle\n.\n\n\nDie Startseite enth\u00e4lt grundlegende Informationen zum Projektseminar und verschafft einen \u00dcberblick \u00fcber die Dokumentation. Die Abschnitte \nownCloud\n und \nMoodle\n dokumentieren jeweils die \ntechnische Umsetzung\n und \nBenutzung\n der beiden Systeme. W\u00e4hrend die technische Umsetzung f\u00fcr Entwickler interessant ist, ist der Teil Benutzung als Bedienungsanleitung an die Nutzer gerichtet.\n\n\nDer Unterabschnitt \ntechnische Umsetzung\n im Abschnitt \nownCloud\n enth\u00e4lt die Themen \nOAuth 2.0\n, \nSoftwarearchitektur\n, \nOAuth 2.0 App\n und \nCore Anpassungen\n. Auf Seiten von \nMoodle\n werden die Themen \nSoftwarearchitektur\n, \nAdmin Tool\n, \nRepository\n und \nCollaborative Folders\n behandelt.\n\n\nMotivation\n\n\nDa im Learnweb sehr h\u00e4ufig mit Dateien umgegangen wird, lag es nahe, dem Nutzer nicht nur den Upload seiner lokalen Dateien anzubieten, sondern zus\u00e4tzlich seinen Cloudspeicher zu integrieren (ganz abgesehen von den anderen M\u00f6glichkeiten, die die Integration eines Cloudspeichers bietet). Zur Kommunikation zwischen den beiden Systemen musste bisher jedoch das Passwort des Nutzers in beiden Systemen gespeichert werden, was ein Sicherheitsrisiko darstellt. Daher mussten andere L\u00f6sungen gefunden werden.\n\n\nDas grundlegende Ziel bei allen umzusetzenden \nIntegrationsszenarien\n war daher, die beiden Systeme sciebo und Learnweb passwortlos miteinander kommunizieren zu lassen. Dies bedeutet, dass beispielsweise f\u00fcr einen Zugriff vom Learnweb auf sciebo das Passwort des Nutzers nicht im Learnweb vorliegt, sondern die Authentifizierung und Autorisierung auf anderem Wege stattfindet.\n\n\nDes Weiteren sollte die zu entwickelnde L\u00f6sung m\u00f6glichst allgemein einsetzbar sein, da die Kombination von Moodle und ownCloud an zahlreichen Universit\u00e4ten genutzt wird. Aus diesem Grunde wird nachfolgend nicht mehr von Learnweb und sciebo, sondern von Moodle und ownCloud gesprochen.\n\n\nAuthentifizierung und Autorisierung\n\n\nGrundlegend f\u00fcr die Integration beider Systeme ist die Authentifizierung und Autorisierung. Unter den Verfahren, die untersucht wurden, befinden sich:\n\n\n\n\nOAuth 2.0\n\n\nJSON Web Tokens\n\n\nMacaroons\n\n\nFederated Single Sign-on mit beispielsweise \nShibboleth\n\n\n\n\nF\u00fcr das Projekt wurde das OAuth 2.0 Verfahren ausgew\u00e4hlt, da mit ihm ein standardisiertes Verfahren zur tokenbasierten Authentifizierung und\nAutorisierung vorliegt, das sich gut in bestehende Applikationen auf Basis vieler verschiedener Programmiersprachen einf\u00fcgen l\u00e4sst und damit keine weiteren Anforderungen an die Infrastruktur stellt.\n\n\nIntegrationsszenarien\n\n\nZu Beginn wurden verschiedene Integrationsszenarien zwischen den beiden Systemen entwickelt. Diese haben wir nach Schwierigkeit, Interesse, Benutzbarkeit und Implementierungsaufwand priorisiert. Als Integrationsrichtung konzentrierte wir uns dabei auf die Richtung Learnweb \n sciebo.\n\n\nEs wurden folgende Integrationsszenarien realisiert.\n\n\n\n\n\n\nAls \nNutzer\n m\u00f6chte ich OAuth 2.0 benutzen k\u00f6nnen, um Moodle Zugriff auf ownCloud zu gew\u00e4hren. \n \nDieses Integrationsszenario behandelt die passwortlose Authentifizierung mit dem OAuth 2.0 Verfahren, was die Grundlage f\u00fcr alle weiteren Szenarien war. Auf Seiten von ownCloud wurde dazu eine \nApp\n entwickelt und \nAnpassungen am ownCloud Core\n durchgef\u00fchrt. Auf der anderen Seite ist in Moodle ein \nAdmin Tool\n implementiert worden, das s\u00e4mtliche Aufgaben zur Authentifizierung und Autorisierung mittels OAuth 2.0 \u00fcbernimmt. Alle anderen entwickelten Plugins nutzen dieses Tool.\n\n\n\n\n\n\nAls \nNutzer\n m\u00f6chte ich in der Dateiauswahl in Moodle eine Datei aus meiner ownCloud Instanz \nhochladen\n. \n\nF\u00fcr dieses Szenario wurde f\u00fcr Moodle ein \nRepository Plugin\n entwickelt, mithilfe dessen der Nutzer, nach Autorisierung von Moodle f\u00fcr den Zugriff auf ownCloud, Dateien aus ownCloud hochladen kann.\n\n\n\n\n\n\nAls \nNutzer\n m\u00f6chte ich in der Dateiauswahl in Moodle eine Datei aus meiner ownCloud Instanz \nverlinken\n. \n\nEine Erweiterung des vorherigen Szenarios ist die Verlinkung von Dateien. Hierzu wird zu einer Datei ein \u00f6ffentlicher Link erstellt. Dieser kann daraufhin von Nutzern angeklickt werden. Diese Funktionalit\u00e4t ist auch Teil des \nRepository Plugins\n. Das Verlinken ist\njedoch nur in der Moodle-Aktivit\u00e4t \u201eURL\u201c verf\u00fcgbar.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich Studierenden oder Gruppen von Studierenden Ordner f\u00fcr kollaboratives Arbeiten bereitstellen. \n\nNach diesem Integrationsszenario wurde vermehrt von Lehrenden der Universit\u00e4t M\u00fcnster gefragt. Ein Lehrender kann mithilfe eines \nActivity Plugins\n f\u00fcr Moodle in einem Kurs Ordner erstellen, auf den Studierende Zugriff haben und den sie zu ihrer ownCloud hinzuf\u00fcgen k\u00f6nnen.\n\n\n\n\n\n\nKomponenten\n\n\nAls \u00dcberblick werden nachfolgend die entwickelten Komponenten in den beiden Systemen dargestellt.\n\n\n\n\nownCloud\n\n\nApp \noauth2\n: Implementierung des OAuth 2.0 Protokolls.\n\n\nCore Anpassungen\n: Erm\u00f6glichen den Zugriff auf verschiedene Schnittstellen von ownCloud via OAuth 2.0.\n\n\n\n\n\n\nMoodle\n\n\nAdmin Tool \noauth2owncloud\n: Verwaltung der Authentifizierung und Autorisierung mit OAuth 2.0.\n\n\nRepository Plugin \nowncloud\n: Herunterladen und Verlinken von Dateien aus ownCloud.\n\n\nActivity Plugin \ncollaborativefolders\n: Erstellen von Ordnern in ownCloud f\u00fcr kollaboratives Arbeiten.\n\n\n\n\n\n\n\n\nWeitere Integrationsszenarien\n\n\nWegen zeitlicher Restriktionen konnten nicht alle Integrationsszenarien, \u00fcber deren Implementierung wir nachgedacht haben, realisiert werden. Zuk\u00fcnftige Arbeiten k\u00f6nnten sich jedoch mit folgenden Erweiterungen besch\u00e4ftigen.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich auf einen Button klicken, um hochgeladene Dateien zu aktualisieren.\n\n\n\n\n\n\nAls \nStudierender\n m\u00f6chte ich Dateien aus Moodle direkt in meiner ownCloud Instanz speichern k\u00f6nnen.\n\n\n\n\n\n\nAls \nStudierender\n m\u00f6chte ich anderen Studierenden Schreib- und Lese-Rechte geben um kollaborativ zu arbeiten.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich Nutzern auf Modul-Basis das Recht entziehen, eine Datei zu verlinken.\n\n\n\n\n\n\nAls \nNutzer\n m\u00f6chte ich in der Dateiauswahl in Moodle einen ganzen Ordner aus meiner ownCloud Instanz hochladen.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich in der Dateiauswahl in Moodle einen Ordner aus meiner ownCloud Instanz verlinken.\n\n\n\n\n\n\nAls \nStudierender\n m\u00f6chte ich Lehrenden Schreib- oder Lese-Rechte auf mein Dokument geben k\u00f6nnen, um Feedback zu erhalten.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich die M\u00f6glichkeit haben, einen Zielordner in ownCloud zur Speicherung auszuw\u00e4hlen, um Abgaben herunterzuladen.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich ownCloud als prim\u00e4ren Speicher f\u00fcr alle Dateien im Kurs verwenden k\u00f6nnen.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich in ownCloud die Teilen-Funktion nutzen, um Dateien oder Dokumente f\u00fcr Kursteilnehmer freigeben zu k\u00f6nnen.\n\n\n\n\n\n\nZusammenfassung\n\n\nIn diesem Projektseminar wurden die beiden Systeme ownCloud und Moodle integriert. Als Grundlage diente dabei das OAuth 2.0 Protokoll, um eine passwortlose Authentifizierung und Autorisierung zu erm\u00f6glichen. Es wurden verschiedene Integrationsszenarien betrachtet und vier von ihnen realisiert. Au\u00dferdem wurde die implementierte OAuth 2.0 ownCloud App in die offizielle \nownCloud GitHub Organisation\n \u00fcbernommen, sowie die Anpassungen am ownCloud Core akzeptiert. Das in K\u00fcrze erscheinende ownCloud 10.0 wird die \u00c4nderungen enthalten und vollst\u00e4ndig kompatibel mit der OAuth 2.0 App sein. Des Weiteren k\u00f6nnte in Zukunft auch ownCloud 9.1.5 kompatibel mit der App sein, falls der Backport akzeptiert wird.\n\n\nAm 15. M\u00e4rz 2017 wurde die Arbeit pr\u00e4sentiert. Nachfolgend finden Sie eine Aufzeichnung der Abschlusspr\u00e4sentation (wir entschuldigen uns f\u00fcr die Mikrofon-Probleme). Die Folien dazu k\u00f6nnen Sie sich \nhier\n ansehen.", 
            "title": "Home"
        }, 
        {
            "location": "/#sciebolearnweb", 
            "text": "Diese Website dokumentiert die Integration von  sciebo  in das  Learnweb , die durch das Projektseminar  sciebo@Learnweb  im Wintersemester 2016/17 an der  Westf\u00e4lischen Wilhelms-Universit\u00e4t M\u00fcnster  realisiert wurde.  Sciebo ist ein Cloud-Dienst, der gemeinsam von 26 Hochschulen und Forschungseinrichtungen in NRW angeboten wird. Als Grundlage dient die Enterprise-Edition von  ownCloud . Das Learnweb ist ein auf der Open-Source-L\u00f6sung  Moodle  basierendes E-Learning System der Westf\u00e4lischen Wilhelms-Universit\u00e4t M\u00fcnster.", 
            "title": "sciebo@Learnweb"
        }, 
        {
            "location": "/#struktur-der-dokumentation", 
            "text": "Die vorliegende Dokumentation ist in mehrere Teile gegliedert. Neben der Startseite (auf der Sie sich momentan befinden), gibt es die Abschnitte  ownCloud  und  Moodle .  Die Startseite enth\u00e4lt grundlegende Informationen zum Projektseminar und verschafft einen \u00dcberblick \u00fcber die Dokumentation. Die Abschnitte  ownCloud  und  Moodle  dokumentieren jeweils die  technische Umsetzung  und  Benutzung  der beiden Systeme. W\u00e4hrend die technische Umsetzung f\u00fcr Entwickler interessant ist, ist der Teil Benutzung als Bedienungsanleitung an die Nutzer gerichtet.  Der Unterabschnitt  technische Umsetzung  im Abschnitt  ownCloud  enth\u00e4lt die Themen  OAuth 2.0 ,  Softwarearchitektur ,  OAuth 2.0 App  und  Core Anpassungen . Auf Seiten von  Moodle  werden die Themen  Softwarearchitektur ,  Admin Tool ,  Repository  und  Collaborative Folders  behandelt.", 
            "title": "Struktur der Dokumentation"
        }, 
        {
            "location": "/#motivation", 
            "text": "Da im Learnweb sehr h\u00e4ufig mit Dateien umgegangen wird, lag es nahe, dem Nutzer nicht nur den Upload seiner lokalen Dateien anzubieten, sondern zus\u00e4tzlich seinen Cloudspeicher zu integrieren (ganz abgesehen von den anderen M\u00f6glichkeiten, die die Integration eines Cloudspeichers bietet). Zur Kommunikation zwischen den beiden Systemen musste bisher jedoch das Passwort des Nutzers in beiden Systemen gespeichert werden, was ein Sicherheitsrisiko darstellt. Daher mussten andere L\u00f6sungen gefunden werden.  Das grundlegende Ziel bei allen umzusetzenden  Integrationsszenarien  war daher, die beiden Systeme sciebo und Learnweb passwortlos miteinander kommunizieren zu lassen. Dies bedeutet, dass beispielsweise f\u00fcr einen Zugriff vom Learnweb auf sciebo das Passwort des Nutzers nicht im Learnweb vorliegt, sondern die Authentifizierung und Autorisierung auf anderem Wege stattfindet.  Des Weiteren sollte die zu entwickelnde L\u00f6sung m\u00f6glichst allgemein einsetzbar sein, da die Kombination von Moodle und ownCloud an zahlreichen Universit\u00e4ten genutzt wird. Aus diesem Grunde wird nachfolgend nicht mehr von Learnweb und sciebo, sondern von Moodle und ownCloud gesprochen.", 
            "title": "Motivation"
        }, 
        {
            "location": "/#authentifizierung-und-autorisierung", 
            "text": "Grundlegend f\u00fcr die Integration beider Systeme ist die Authentifizierung und Autorisierung. Unter den Verfahren, die untersucht wurden, befinden sich:   OAuth 2.0  JSON Web Tokens  Macaroons  Federated Single Sign-on mit beispielsweise  Shibboleth   F\u00fcr das Projekt wurde das OAuth 2.0 Verfahren ausgew\u00e4hlt, da mit ihm ein standardisiertes Verfahren zur tokenbasierten Authentifizierung und\nAutorisierung vorliegt, das sich gut in bestehende Applikationen auf Basis vieler verschiedener Programmiersprachen einf\u00fcgen l\u00e4sst und damit keine weiteren Anforderungen an die Infrastruktur stellt.", 
            "title": "Authentifizierung und Autorisierung"
        }, 
        {
            "location": "/#integrationsszenarien", 
            "text": "Zu Beginn wurden verschiedene Integrationsszenarien zwischen den beiden Systemen entwickelt. Diese haben wir nach Schwierigkeit, Interesse, Benutzbarkeit und Implementierungsaufwand priorisiert. Als Integrationsrichtung konzentrierte wir uns dabei auf die Richtung Learnweb   sciebo.  Es wurden folgende Integrationsszenarien realisiert.    Als  Nutzer  m\u00f6chte ich OAuth 2.0 benutzen k\u00f6nnen, um Moodle Zugriff auf ownCloud zu gew\u00e4hren.   \nDieses Integrationsszenario behandelt die passwortlose Authentifizierung mit dem OAuth 2.0 Verfahren, was die Grundlage f\u00fcr alle weiteren Szenarien war. Auf Seiten von ownCloud wurde dazu eine  App  entwickelt und  Anpassungen am ownCloud Core  durchgef\u00fchrt. Auf der anderen Seite ist in Moodle ein  Admin Tool  implementiert worden, das s\u00e4mtliche Aufgaben zur Authentifizierung und Autorisierung mittels OAuth 2.0 \u00fcbernimmt. Alle anderen entwickelten Plugins nutzen dieses Tool.    Als  Nutzer  m\u00f6chte ich in der Dateiauswahl in Moodle eine Datei aus meiner ownCloud Instanz  hochladen .  \nF\u00fcr dieses Szenario wurde f\u00fcr Moodle ein  Repository Plugin  entwickelt, mithilfe dessen der Nutzer, nach Autorisierung von Moodle f\u00fcr den Zugriff auf ownCloud, Dateien aus ownCloud hochladen kann.    Als  Nutzer  m\u00f6chte ich in der Dateiauswahl in Moodle eine Datei aus meiner ownCloud Instanz  verlinken .  \nEine Erweiterung des vorherigen Szenarios ist die Verlinkung von Dateien. Hierzu wird zu einer Datei ein \u00f6ffentlicher Link erstellt. Dieser kann daraufhin von Nutzern angeklickt werden. Diese Funktionalit\u00e4t ist auch Teil des  Repository Plugins . Das Verlinken ist\njedoch nur in der Moodle-Aktivit\u00e4t \u201eURL\u201c verf\u00fcgbar.    Als  Lehrender  m\u00f6chte ich Studierenden oder Gruppen von Studierenden Ordner f\u00fcr kollaboratives Arbeiten bereitstellen.  \nNach diesem Integrationsszenario wurde vermehrt von Lehrenden der Universit\u00e4t M\u00fcnster gefragt. Ein Lehrender kann mithilfe eines  Activity Plugins  f\u00fcr Moodle in einem Kurs Ordner erstellen, auf den Studierende Zugriff haben und den sie zu ihrer ownCloud hinzuf\u00fcgen k\u00f6nnen.", 
            "title": "Integrationsszenarien"
        }, 
        {
            "location": "/#komponenten", 
            "text": "Als \u00dcberblick werden nachfolgend die entwickelten Komponenten in den beiden Systemen dargestellt.   ownCloud  App  oauth2 : Implementierung des OAuth 2.0 Protokolls.  Core Anpassungen : Erm\u00f6glichen den Zugriff auf verschiedene Schnittstellen von ownCloud via OAuth 2.0.    Moodle  Admin Tool  oauth2owncloud : Verwaltung der Authentifizierung und Autorisierung mit OAuth 2.0.  Repository Plugin  owncloud : Herunterladen und Verlinken von Dateien aus ownCloud.  Activity Plugin  collaborativefolders : Erstellen von Ordnern in ownCloud f\u00fcr kollaboratives Arbeiten.", 
            "title": "Komponenten"
        }, 
        {
            "location": "/#weitere-integrationsszenarien", 
            "text": "Wegen zeitlicher Restriktionen konnten nicht alle Integrationsszenarien, \u00fcber deren Implementierung wir nachgedacht haben, realisiert werden. Zuk\u00fcnftige Arbeiten k\u00f6nnten sich jedoch mit folgenden Erweiterungen besch\u00e4ftigen.    Als  Lehrender  m\u00f6chte ich auf einen Button klicken, um hochgeladene Dateien zu aktualisieren.    Als  Studierender  m\u00f6chte ich Dateien aus Moodle direkt in meiner ownCloud Instanz speichern k\u00f6nnen.    Als  Studierender  m\u00f6chte ich anderen Studierenden Schreib- und Lese-Rechte geben um kollaborativ zu arbeiten.    Als  Lehrender  m\u00f6chte ich Nutzern auf Modul-Basis das Recht entziehen, eine Datei zu verlinken.    Als  Nutzer  m\u00f6chte ich in der Dateiauswahl in Moodle einen ganzen Ordner aus meiner ownCloud Instanz hochladen.    Als  Lehrender  m\u00f6chte ich in der Dateiauswahl in Moodle einen Ordner aus meiner ownCloud Instanz verlinken.    Als  Studierender  m\u00f6chte ich Lehrenden Schreib- oder Lese-Rechte auf mein Dokument geben k\u00f6nnen, um Feedback zu erhalten.    Als  Lehrender  m\u00f6chte ich die M\u00f6glichkeit haben, einen Zielordner in ownCloud zur Speicherung auszuw\u00e4hlen, um Abgaben herunterzuladen.    Als  Lehrender  m\u00f6chte ich ownCloud als prim\u00e4ren Speicher f\u00fcr alle Dateien im Kurs verwenden k\u00f6nnen.    Als  Lehrender  m\u00f6chte ich in ownCloud die Teilen-Funktion nutzen, um Dateien oder Dokumente f\u00fcr Kursteilnehmer freigeben zu k\u00f6nnen.", 
            "title": "Weitere Integrationsszenarien"
        }, 
        {
            "location": "/#zusammenfassung", 
            "text": "In diesem Projektseminar wurden die beiden Systeme ownCloud und Moodle integriert. Als Grundlage diente dabei das OAuth 2.0 Protokoll, um eine passwortlose Authentifizierung und Autorisierung zu erm\u00f6glichen. Es wurden verschiedene Integrationsszenarien betrachtet und vier von ihnen realisiert. Au\u00dferdem wurde die implementierte OAuth 2.0 ownCloud App in die offizielle  ownCloud GitHub Organisation  \u00fcbernommen, sowie die Anpassungen am ownCloud Core akzeptiert. Das in K\u00fcrze erscheinende ownCloud 10.0 wird die \u00c4nderungen enthalten und vollst\u00e4ndig kompatibel mit der OAuth 2.0 App sein. Des Weiteren k\u00f6nnte in Zukunft auch ownCloud 9.1.5 kompatibel mit der App sein, falls der Backport akzeptiert wird.  Am 15. M\u00e4rz 2017 wurde die Arbeit pr\u00e4sentiert. Nachfolgend finden Sie eine Aufzeichnung der Abschlusspr\u00e4sentation (wir entschuldigen uns f\u00fcr die Mikrofon-Probleme). Die Folien dazu k\u00f6nnen Sie sich  hier  ansehen.", 
            "title": "Zusammenfassung"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2/", 
            "text": "OAuth 2.0\n\n\nWie \neingangs begr\u00fcndet\n, wurde OAuth 2.0 als Verfahren f\u00fcr die Authentifizierung und Autorisierung zwischen den beiden Systemen Moodle und ownCloud gew\u00e4hlt. Diese Seite erl\u00e4utert den allgemeinen Protokollablauf von OAuth 2.0.\n\n\nAllgemeiner Protokollablauf\n\n\nDer allgemeine \nOAuth 2.0 Protokollablauf\n ist in der nachfolgenden Abbildung dargestellt.\n\n\n\n\n\n    \n[vgl. \nRFC 6749, S. 7f\n]\n\n\n\n\n\nZun\u00e4chst muss sich der Client (Moodle), der im Namen des Resource Owners (ownCloud Nutzer) auf eine gesch\u00fctzte Ressource auf dem Resource Server (ownCloud) zugreifen m\u00f6chte, bei dem Authorization Server (ownCloud) \nregistrieren\n. Danach werden nach dem Protokoll folgende Schritte durchlaufen:\n\n\n\n\nAuthorization Request\n: Der Client fordert eine Autorisierung vom Resource Owner an.\n\n\nAuthorization Response\n: Der Client erh\u00e4lt einen \nAuthorization Grant\n vom Resource Owner, mit dem er ein \nAccess Token\n anfordern kann.\n\n\nAccess Token Request\n: Der Client fordert ein Access Token vom Authorization Server an. Hierf\u00fcr nutzt er den Authorization Grant.\n\n\nAccess Token Response\n: Der Authorization Server authentifiziert den Client und pr\u00fcft den Authorization Grant. Ist die Pr\u00fcfung erfolgreich, wird ein Access Token ausgestellt.\n\n\nAnfrage mit Access Token\n: Der Client fragt die gesch\u00fctzten Daten beim Resource Server an. Zur Authentifizierung benutzt er den Access Token.\n\n\nGesch\u00fctzte Ressource\n: Der Resource Server pr\u00fcft den Access Token und stellt, wenn g\u00fcltig, die gesch\u00fctzte Ressource zur Verf\u00fcgung.", 
            "title": "OAuth 2.0"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2/#oauth-20", 
            "text": "Wie  eingangs begr\u00fcndet , wurde OAuth 2.0 als Verfahren f\u00fcr die Authentifizierung und Autorisierung zwischen den beiden Systemen Moodle und ownCloud gew\u00e4hlt. Diese Seite erl\u00e4utert den allgemeinen Protokollablauf von OAuth 2.0.", 
            "title": "OAuth 2.0"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2/#allgemeiner-protokollablauf", 
            "text": "Der allgemeine  OAuth 2.0 Protokollablauf  ist in der nachfolgenden Abbildung dargestellt.   \n     [vgl.  RFC 6749, S. 7f ]   Zun\u00e4chst muss sich der Client (Moodle), der im Namen des Resource Owners (ownCloud Nutzer) auf eine gesch\u00fctzte Ressource auf dem Resource Server (ownCloud) zugreifen m\u00f6chte, bei dem Authorization Server (ownCloud)  registrieren . Danach werden nach dem Protokoll folgende Schritte durchlaufen:   Authorization Request : Der Client fordert eine Autorisierung vom Resource Owner an.  Authorization Response : Der Client erh\u00e4lt einen  Authorization Grant  vom Resource Owner, mit dem er ein  Access Token  anfordern kann.  Access Token Request : Der Client fordert ein Access Token vom Authorization Server an. Hierf\u00fcr nutzt er den Authorization Grant.  Access Token Response : Der Authorization Server authentifiziert den Client und pr\u00fcft den Authorization Grant. Ist die Pr\u00fcfung erfolgreich, wird ein Access Token ausgestellt.  Anfrage mit Access Token : Der Client fragt die gesch\u00fctzten Daten beim Resource Server an. Zur Authentifizierung benutzt er den Access Token.  Gesch\u00fctzte Ressource : Der Resource Server pr\u00fcft den Access Token und stellt, wenn g\u00fcltig, die gesch\u00fctzte Ressource zur Verf\u00fcgung.", 
            "title": "Allgemeiner Protokollablauf"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/softwarearchitektur/", 
            "text": "Softwarearchitektur\n\n\nDa wir m\u00f6glichst keine neue Schnittstelle implementieren wollten, war es das Ziel, die bestehenden Schnittstellen in ownCloud um OAuth 2.0 zu erweitern. Zun\u00e4chst war daf\u00fcr die Implementierung des OAuth 2.0 Protokolls mit seinen Schnittstellen notwendig. Au\u00dferdem musste zur Umsetzung der \nIntegrationsszenarien\n der Zugriff auf \nWebDAV\n und die \nOCS Share API\n \u00fcber OAuth 2.0 bereitgestellt werden. Es wird damit folgendes Integrationsszenario realisiert:\n\n\n\n\nAls \nNutzer\n m\u00f6chte ich OAuth 2.0 benutzen k\u00f6nnen, um Moodle Zugriff auf ownCloud zu gew\u00e4hren.\n\n\n\n\nBestandteile\n\n\nOAuth 2.0 App\n\n\nZur Implementierung von OAuth 2.0 entschieden wir uns in Absprache mit einem ownCloud Entwickler, eine \nownCloud App\n namens \noauth2\n zu erstellen. Der Vorteil einer solchen L\u00f6sung ist, dass OAuth 2.0 zu einer bestehenden ownCloud Installation einfach hinzugef\u00fcgt und auch wieder entfernt werden kann. Die M\u00f6glichkeit, \nRESTful APIs\n und eigene \nDatenmodelle\n in Apps zu definieren, stellten alle notwendigen Werkzeuge f\u00fcr die Umsetzung des OAuth 2.0 Protokolls bereit. \nBackground Jobs\n, \nHooks\n und \nLogging\n erlaubten die Implementierung weiterer Funktionen.\n\n\nCore Anpassungen\n\n\nUm auf die WebDAV Schnittstelle und die OCS Share API \u00fcber OAuth 2.0 zugreifen zu k\u00f6nnen, untersuchten wir die Implementierungen dieser Schnittstellen im \nownCloud Core\n. Dabei haben wir \u00c4nderungen bei der ownCloud-internen \ndav\n App und dem Authentifizierungsmechanismus f\u00fcr ownCloud APIs durchgef\u00fchrt. Dabei war es ein wichtiges Anliegen, keine Abh\u00e4ngigkeiten zwischen dem ownCloud Core und der OAuth 2.0 App einzuf\u00fchren. F\u00fcr die \u00c4nderungen wurde der Pull Request \nowncloud/core#26742\n erstellt. Ein Backport f\u00fcr ownCloud 9.1 ist im Pull Request \nowncloud/core#27370\n zu finden.\n\n\nFolgende Tabelle fasst die Funktionen der einzelnen Bestandteile zusammen.\n\n\n\n\n\n\n\n\nBestandteil\n\n\nFunktion\n\n\n\n\n\n\n\n\n\n\nOAuth 2.0 App\n\n\nImplementierung des OAuth 2.0 Protokolls mit der notwendigen Authentifizierungslogik f\u00fcr die WebDAV Schnittstelle und ownCloud APIs\n\n\n\n\n\n\nCore Anpassungen\n\n\nErweiterung der Authentifizierung in der \ndav\n App und f\u00fcr ownCloud APIs um das Laden benutzerdefinierter Authentifizierungsmethoden", 
            "title": "Softwarearchitektur"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/softwarearchitektur/#softwarearchitektur", 
            "text": "Da wir m\u00f6glichst keine neue Schnittstelle implementieren wollten, war es das Ziel, die bestehenden Schnittstellen in ownCloud um OAuth 2.0 zu erweitern. Zun\u00e4chst war daf\u00fcr die Implementierung des OAuth 2.0 Protokolls mit seinen Schnittstellen notwendig. Au\u00dferdem musste zur Umsetzung der  Integrationsszenarien  der Zugriff auf  WebDAV  und die  OCS Share API  \u00fcber OAuth 2.0 bereitgestellt werden. Es wird damit folgendes Integrationsszenario realisiert:   Als  Nutzer  m\u00f6chte ich OAuth 2.0 benutzen k\u00f6nnen, um Moodle Zugriff auf ownCloud zu gew\u00e4hren.", 
            "title": "Softwarearchitektur"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/softwarearchitektur/#bestandteile", 
            "text": "", 
            "title": "Bestandteile"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/softwarearchitektur/#oauth-20-app", 
            "text": "Zur Implementierung von OAuth 2.0 entschieden wir uns in Absprache mit einem ownCloud Entwickler, eine  ownCloud App  namens  oauth2  zu erstellen. Der Vorteil einer solchen L\u00f6sung ist, dass OAuth 2.0 zu einer bestehenden ownCloud Installation einfach hinzugef\u00fcgt und auch wieder entfernt werden kann. Die M\u00f6glichkeit,  RESTful APIs  und eigene  Datenmodelle  in Apps zu definieren, stellten alle notwendigen Werkzeuge f\u00fcr die Umsetzung des OAuth 2.0 Protokolls bereit.  Background Jobs ,  Hooks  und  Logging  erlaubten die Implementierung weiterer Funktionen.", 
            "title": "OAuth 2.0 App"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/softwarearchitektur/#core-anpassungen", 
            "text": "Um auf die WebDAV Schnittstelle und die OCS Share API \u00fcber OAuth 2.0 zugreifen zu k\u00f6nnen, untersuchten wir die Implementierungen dieser Schnittstellen im  ownCloud Core . Dabei haben wir \u00c4nderungen bei der ownCloud-internen  dav  App und dem Authentifizierungsmechanismus f\u00fcr ownCloud APIs durchgef\u00fchrt. Dabei war es ein wichtiges Anliegen, keine Abh\u00e4ngigkeiten zwischen dem ownCloud Core und der OAuth 2.0 App einzuf\u00fchren. F\u00fcr die \u00c4nderungen wurde der Pull Request  owncloud/core#26742  erstellt. Ein Backport f\u00fcr ownCloud 9.1 ist im Pull Request  owncloud/core#27370  zu finden.  Folgende Tabelle fasst die Funktionen der einzelnen Bestandteile zusammen.     Bestandteil  Funktion      OAuth 2.0 App  Implementierung des OAuth 2.0 Protokolls mit der notwendigen Authentifizierungslogik f\u00fcr die WebDAV Schnittstelle und ownCloud APIs    Core Anpassungen  Erweiterung der Authentifizierung in der  dav  App und f\u00fcr ownCloud APIs um das Laden benutzerdefinierter Authentifizierungsmethoden", 
            "title": "Core Anpassungen"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/", 
            "text": "App: \noauth2\n\n\nZweck\n\n\nIn der App sollte der h\u00e4ufig f\u00fcr Webapplikationen eingesetzte \nAuthorization Code Flow\n implementiert werden. Dazu mussten folgende Nutzungsszenarien umgesetzt werden:\n\n\n\n\nClientregistrierung:\n Als ownCloud-Administrator m\u00f6chte ich Clients in den Administrator-Einstellungen hinzuf\u00fcgen und l\u00f6schen k\u00f6nnen, um die Kontrolle \u00fcber erlaubte Clients zu haben.\n\n\nLog-Eintr\u00e4ge\n: Als ownCloud-Administrator m\u00f6chte ich durch Log-Eintr\u00e4ge \u00fcber Ereignisse zu OAuth 2.0 informiert werden.\n\n\nAuthorization URL:\n Als Client-Entwickler m\u00f6chte ich eine Authorization URL zur Verf\u00fcgung haben, um Authorization Codes anfordern zu k\u00f6nnen.\n\n\nAccess Token URL:\n Als Client-Entwickler m\u00f6chte ich eine Access Token URL zur Verf\u00fcgung haben, um Access Tokens anfordern zu k\u00f6nnen.\n\n\nVerwaltung autorisierter Applikationen\n: Als ownCloud-Nutzer m\u00f6chte ich in den pers\u00f6nlichen Einstellungen autorisierte Applikationen verwalten k\u00f6nnen, um einen \u00dcberblick zu haben und Autorisierungen widerrufen zu k\u00f6nnen.\n\n\n\n\nAuthorization Code Flow\n\n\nDie nachfolgende Abbildung stellt den durch die \noauth2\n App implementierten \nOAuth 2.0 Authorization Code Flow\n dar.\n\n\n\n\nAnmerkung: Die Schritte 1, 2 und 3 sind zweigeteilt, da sie durch den User-Agent laufen.\n\n\n\n\n\n\n\n    \n[vgl. \nRFC 6749, S. 24\n]\n\n\n\n\n\nDer Authorization Code Flow kann von jedem Client, der registriert ist, angesto\u00dfen werden. Zur Registrierung eines Clients gibt der Administrator in den ownCloud Einstellungen folgende Informationen an:\n\n\n\n\nName des Clients: Zur Wiedererkennung\n\n\nRedirection URI: URI, an die nach erfolgter Autorisierung des Nutzers weitergeleitet wird.\n\n\nUmgang mit Subdomains: Zum Einstellen, ob Subdomains der Redirection URI erlaubt werden sollen.\n\n\n\n\nDie App generiert daraufhin die Zugangsdaten des Clients, bestehend aus Client Identifier und Client Secret.\n\n\nIm Flow sind folgende Rollen beteiligt:\n\n\n\n\nClient: Die Applikation, die f\u00fcr Zugriffe auf gesch\u00fctzte Ressourcen autorisiert werden m\u00f6chte. In unserem Integrationsszenario: Moodle.\n\n\nAuthorization Server: Die Applikation, die den Client f\u00fcr Zugriffe autorisiert. In unserem Integrationsszenario: ownCloud.\n\n\nResource Owner: Der Eigent\u00fcmer der gesch\u00fctzten Ressourcen. In unserem Integrationsszenario: ownCloud Nutzer.\n\n\nUser Agent: Durch ihn erfolgt die Kommunikation zwischen Client, Resource Owner und Authorization Server. In unserem Integrationsszenario: ein Webbrowser.\n\n\n\n\nFolgende Schritte werden durchlaufen:\n\n\n\n\nDer Client initiiert den Flow durch Weiterleitung des Resource Owners an die Authorization URL \n/index.php/apps/oauth2/authorize\n. URL Parameter:\n\n\nresponse_type\n: Da hier der Authorization Code Flow betrachtet wird, muss \ncode\n angegeben werden.\n\n\nclient_id\n: Der Client Identifier aus der Clientregistrierung.\n\n\nredirect_uri\n: Die Redirection URI aus der Clientregistrierung.\n\n\nstate\n: Kann vom Client optional angegeben werden, um die Anfrage bei Erhalt einer Antwort wiedererkennen zu k\u00f6nnen.\n\n\n\n\n\n\nDer Resource Owner authentifiziert sich daraufhin beim Authorization Server und entscheidet \u00fcber die Autorisierung des Clients.\n\n\nBei erfolgter Autorisierung, wird ein Authorization Code ausgestellt (ein Authorization Code ist f\u00fcr 10 Minuten g\u00fcltig). Die App leitet dann an die Redirection URI weiter. URL Parameter:\n\n\ncode\n: Der ausgestellte Authorization Code.\n\n\nstate\n: optional, falls unter 1. angegeben.\n\n\n\n\n\n\nMit dem Authorization Code kann der Client ein Access Token anfordern. Dazu sendet er einen \nPOST\n-Request an die Access Token URL \n/index.php/apps/oauth2/api/v1/token\n. Zus\u00e4tzlich ist eine Client Authentifizierung mittels Basic Authentication (Nutzername: Client Identifier, Passwort: Client Secret) notwendig. URL Parameter:\n\n\ngrant_type\n: entweder \nauthorization_code\n oder \nrefresh_token\n\n\ncode\n und \nredirect_uri\n (falls \nauthorization_code\n als Grant Type angegeben wurde)\n\n\nrefresh_token\n (falls \nrefresh_token\n als Grant Type angegeben wurde)\n\n\n\n\n\n\nBei g\u00fcltigen Angaben wird ein Access Token mit Refresh Token ausgestellt (ein Access Token ist f\u00fcr 1 Stunde g\u00fcltig). Abgelaufene Access Tokens k\u00f6nnen mithilfe des Refresh Tokens gegen neue eingetauscht werden.\n\n\n\n\nDatenmodell\n\n\nZun\u00e4chst musste ein Datenmodell zur Speicherung der ben\u00f6tigten Daten aufgestellt werden. Gem\u00e4\u00df dem Authorization Code Flow wurden folgende Entit\u00e4ten mit Attributen definiert:\n\n\n\n\nclient\n:\n Die Applikation, die f\u00fcr den Zugriff auf die WebDAV Schnittstelle autorisiert werden soll.\n\n\nidentifier\n: Zeichenkette, die einen Client eindeutig identifiziert.\n\n\nsecret\n: Zeichenkette, mit der ein Client sich beim Anfordern eines Access Tokens authentifizieren kann.\n\n\nredirect_uri\n: URI, an die nach erfolgter Autorisierung des Nutzers weitergeleitet wird.\n\n\nname\n: Ein Name f\u00fcr den Client zur Wiedererkennung.\n\n\nallow_subdomains\n: Zum Einstellen, ob Subdomains der \nredirect_uri\n erlaubt werden sollen.\n\n\n\n\n\n\nauthorization_code\n:\n Ein \nAuthorization Grant\n, \nmit dem der Client die Autorisierung des Nutzers darlegen und somit ein Access Token anfordern kann.\n\n\ncode\n: Zeichenkette, die als Authorization Code dient.\n\n\nclient_id\n: Client Identifier des Clients, f\u00fcr den der Authorization Code ausgegeben wird.\n\n\nuser_id\n: User ID des ownCloud-Nutzers, der den Client autorisiert hat.\n\n\nexpires\n: Zeitpunkt, zu dem der Authorization Code ung\u00fcltig wird.\n\n\n\n\n\n\naccess_token\n:\n Eine Zeichenkette, die den Zugriff auf die WebDAV Schnittstelle erlaubt.\n\n\ntoken\n: Zeichenkette, die als Access Token dient.\n\n\nclient_id\n: Client Identifier des Clients, f\u00fcr den der Access Token ausgegeben wird.\n\n\nuser_id\n: User ID des ownCloud-Nutzers, der den Client autorisiert hat.\n\n\nexpires\n: Zeitpunkt, zu dem der Access Token ung\u00fcltig wird.\n\n\n\n\n\n\nrefresh_token\n:\n Eine Zeichenkette, mit der ein abgelaufener Access Token gegen einen neuen ausgetauscht werden kann.\n\n\ntoken\n: Zeichenkette, die als Refresh Token dient.\n\n\nclient_id\n: Client Identifier des Clients, f\u00fcr den der Access Token ausgegeben wird.\n\n\nuser_id\n: User ID des ownCloud-Nutzers, der den Client autorisiert hat.\n\n\n\n\n\n\n\n\nFolgendes Entity-Relationship-Modell fasst das Datenmodell grafisch zusammen.\n\n\n\n\nVorgegebene Schnittstelle\n\n\nZur Erweiterung von ownCloud wird das Konzept von \nApps\n geboten. ownCloud Apps liegen im Verzeichnis \napps\n einer ownCloud Installation und besitzen folgende \nStruktur\n:\n\n\nappinfo\n  \u251c\u2500\u2500 app.php               # Die erste Datei, die beim Laden der App ausgef\u00fchrt wird\n  \u251c\u2500\u2500 database.xml          # Definiert das Datenbankschema\n  \u251c\u2500\u2500 info.xml              # Enth\u00e4lt Metadaten\n  \u2514\u2500\u2500 routes.php            # Definiert die Routes\ncss                         # Enth\u00e4lt alle CSS-Dateien\nimg                         # Enth\u00e4lt alle Bilder\njs                          # Enth\u00e4lt alle JavaScript-Dateien\nl10n                        # Enth\u00e4lt die \u00dcbersetzungen\nlib                         # Enth\u00e4lt alle Klassen-Dateien\n  \u251c\u2500\u2500 Controller            # Enth\u00e4lt die Controller\n  \u2514\u2500\u2500 ...\ntemplates                   # Enth\u00e4lt die Templates\ntests                       # Enth\u00e4lt die Tests\n\n\n\n\nAuf die Implementierung der Hauptbestandteile wird in den n\u00e4chsten Abschnitten eingegangen.\n\n\nImplementierung\n\n\nMapper und Entities\n\n\nF\u00fcr den Datenbank-Zugriff im PHP-Code ist es in ownCloud m\u00f6glich, \nMapper\n und \n\nEntities\n zu schreiben. \nDadurch werden Tupel in einer Datenbank-Tabelle automatisch in ein Objekt umgewandelt.\n\n\nFolgendes Codebeispiel zeigt am Beispiel des Entitys \nClient\n, wie eine PHP-Klasse dazu aussehen muss.\n\n\n?php\nnamespace OCA\\OAuth2\\Db;\n\nuse OCP\\AppFramework\\Db\\Entity;\n\n/**\n * @method string getIdentifier()\n * @method void setIdentifier(string $identifier)\n * @method string getSecret()\n * @method void setSecret(string $secret)\n * @method string getRedirectUri()\n * @method void setRedirectUri(string $redirectUri)\n * @method string getName()\n * @method void setName(string $name)\n * @method boolean getAllowSubdomains()\n * @method void setAllowSubdomains(boolean $value)\n */\nclass Client extends Entity {\n\n    protected $identifier;\n    protected $secret;\n    protected $redirectUri;\n    protected $name;\n    protected $allowSubdomains;\n\n    public function __construct() {\n        $this-\naddType('id', 'int');\n        $this-\naddType('identifier', 'string');\n        $this-\naddType('secret', 'string');\n        $this-\naddType('redirect_uri', 'string');\n        $this-\naddType('name', 'string');\n        $this-\naddType('allow_subdomains', 'boolean');\n    }\n\n}\n\n\n\n\nWichtig ist, dass die Klasse von \nEntity\n erbt und sowohl der Klassenname als auch die Attribute mit denen der Tabelle \u00fcbereinstimmen. \nPascal bzw. Camel case im PHP-Code wird automatisch zu Snake case f\u00fcr die Datenbank umgewandelt. \nGetter und Setter werden ebenfalls automatisch generiert. Die PHPDoc Kommentare dienen lediglich dazu, \nin der Entwicklungsumgebung eine automatische Vervollst\u00e4ndigung zu haben. \nDie Angabe von \nTypen\n im Konstruktor dient dazu, \nbeim Lesen aus der Datenbank die richtige Umwandlung zu erhalten.\n\n\nDas folgende Codebeispiel zeigt einen Ausschnitt aus dem zur \nClient\n-Entity geh\u00f6renden Mapper.\n\n\n?php\nnamespace OCA\\OAuth2\\Db;\n\nuse InvalidArgumentException;\nuse OCP\\AppFramework\\Db\\Entity;\nuse OCP\\AppFramework\\Db\\Mapper;\nuse OCP\\IDb;\n\nclass ClientMapper extends Mapper {\n\n    /**\n     * ClientMapper constructor.\n     *\n     * @param IDb $db Database Connection.\n     */\n    public function __construct(IDb $db) {\n        parent::__construct($db, 'oauth2_clients');\n    }\n\n    /**\n     * Selects a client by its ID.\n     *\n     * @param int $id The client's ID.\n     *\n     * @return Entity The client entity.\n     *\n     * @throws \\OCP\\AppFramework\\Db\\DoesNotExistException if not found.\n     * @throws \\OCP\\AppFramework\\Db\\MultipleObjectsReturnedException if more\n     * than one result.\n     */\n    public function find($id) {\n        if (!is_int($id)) {\n            throw new InvalidArgumentException('id must not be null');\n        }\n\n        $sql = 'SELECT * FROM `' . $this-\ntableName . '` WHERE `id` = ?';\n        return $this-\nfindEntity($sql, [$id], null, null);\n    }\n\n    /**\n     * Selects clients by the given user ID.\n     *\n     * @param string $userId The user ID.\n     *\n     * @return array The client entities.\n     */\n    public function findByUser($userId) {\n        if (!is_string($userId)) {\n            throw new InvalidArgumentException('userId must not be null');\n        }\n\n        $sql = 'SELECT * FROM `' . $this-\ntableName . '` '\n            . 'WHERE `id` IN ( '\n                . 'SELECT `client_id` FROM `oc_oauth2_authorization_codes` WHERE `user_id` = ? '\n                . 'UNION '\n                . 'SELECT `client_id` FROM `oc_oauth2_access_tokens` WHERE `user_id` = ? '\n            . ')';\n        return $this-\nfindEntities($sql, [$userId, $userId], null, null);\n    }\n\n}\n\n\n\n\nBeim Mapper ist es wichtig, dass die Klasse von \nMapper\n erbt und eine Entity-Klasse zu ihm existiert. \nDazu wird das Wort vor \u201eMapper\u201c als Entityname verwendet. Im Konstruktur wird der Tabellenname angegeben. \nDie beiden Funktionen \nfind\n und \nfindByUser\n demonstrieren \nSELECT\n-Anweisungen. \nDazu wird die SQL-Anweisung zusammen mit ben\u00f6tigten Parametern an \nfindEntity\n bzw. \nfindEntities\n \u00fcbergeben, abh\u00e4ngig davon, ob mehrere Entities im Ergebnis enthalten sein sollten. \nFunktionen zum L\u00f6schen, Einf\u00fcgen und Aktualisieren werden von der Oberklasse bereits implementiert und mussten nicht angepasst werden.\n\n\nSchnittstellen und Routes\n\n\nUm in einer ownCloud App Schnittstellen anzubieten, m\u00fcssen \nRoutes\n registriert werden. \nZur Umsetzung der erw\u00e4hnten User Stories waren folgende Routes notwendig:\n\n\n\n\n\n\n\n\nMethode\n\n\nEndpunkt\n\n\nBeschreibung\n\n\n\n\n\n\n\n\n\n\nGET\n\n\nauthorize\n\n\nEndpunkt, zu dem der Client den Nutzer weiterleitet, um die Autorisierung anzufragen (Authorization URL).\n\n\n\n\n\n\nPOST\n\n\nauthorize\n\n\nEndpunkt, der aufgerufen wird, sobald der Nutzer den Client autorisiert hat.\n\n\n\n\n\n\nPOST\n\n\napi/v1/token\n\n\nEndpunkt, an dem ein Access Token angefordert wird (Access Token URL).\n\n\n\n\n\n\nPOST\n\n\nclients\n\n\nEndpunkt, durch den der Administrator einen Client hinzuf\u00fcgen kann.\n\n\n\n\n\n\nPOST\n\n\nclients/{id}/delete\n\n\nEndpunkt, durch den der Administrator den Client mit der ID \nid\n l\u00f6schen kann.\n\n\n\n\n\n\nPOST\n\n\nclients/{id}/revoke\n\n\nEndpunkt, durch den der Nutzer die Autorisierung des Clients mit der ID \nid\n widerrufen kann.\n\n\n\n\n\n\n\n\nRegistriert werden die Routes in der Datei \nroutes.php\n, indem ein Array mit den Routes zur\u00fcckgegeben wird. Nachfolgendes Codebeispiel zeigt einige der obigen Routes:\n\n\n?php\nreturn [\n    'routes' =\n [\n        ['name' =\n 'page#authorize', 'url' =\n '/authorize', 'verb' =\n 'GET'],\n        ['name' =\n 'o_auth_api#generate_token', 'url' =\n '/api/v1/token', 'verb' =\n 'POST'],\n        ['name' =\n 'settings#deleteClient', 'url' =\n '/clients/{id}/delete', 'verb' =\n 'POST']\n    ]\n];\n\n\n\n\nDurch \nname\n wird f\u00fcr jede Route der Name des dazugeh\u00f6rigen \nControllers\n sowie die aufzurufende Funktion angegeben: Vor dem \n#\n-Zeichen steht der Controllername in Snake case und hinter dem \n#\n-Zeichen steht der Funktionsname (ebenfalls in Snake case). Mithilfe von \nurl\n wird der Endpunkt festgelegt und \nverb\n definiert die HTTP-Methode.\n\n\nController\n\n\nWenn an einem Endpunkt eine HTTP-Anfrage ankommt, so wird der in den Routes definierte \nController\n aufgerufen. Wichtig ist hierbei, dass von der Klasse \nController\n oder \neiner Unterklasse wie \nApiController\n geerbt wird.\n\n\nF\u00fcr den Controller notwendige Parameter wie \nMapper\n k\u00f6nnen im Konstruktor als Parameter angegeben und so durch \n\nDependency Injection\n erhalten werden. \nNachfolgendes Codebeispiel zeigt den Konstruktor vom \nPageController\n.\n\n\n?php\n/**\n * PageController constructor.\n *\n * @param string $AppName The app's name.\n * @param IRequest $request The request.\n * @param ClientMapper $clientMapper The client mapper.\n * @param AuthorizationCodeMapper $authorizationCodeMapper The authorization code mapper.\n * @param AccessTokenMapper $accessTokenMapper The access token mapper.\n * @param RefreshTokenMapper $refreshTokenMapper The refresh token mapper.\n * @param string $UserId The user ID.\n * @param ILogger $logger The logger.\n */\npublic function __construct($AppName, IRequest $request,\n                            ClientMapper $clientMapper,\n                            AuthorizationCodeMapper $authorizationCodeMapper,\n                            AccessTokenMapper $accessTokenMapper,\n                            RefreshTokenMapper $refreshTokenMapper,\n                            $UserId,\n                            ILogger $logger) {\n    parent::__construct($AppName, $request);\n\n    $this-\nclientMapper = $clientMapper;\n    $this-\nauthorizationCodeMapper = $authorizationCodeMapper;\n    $this-\naccessTokenMapper = $accessTokenMapper;\n    $this-\nrefreshTokenMapper = $refreshTokenMapper;\n    $this-\nuserId = $UserId;\n    $this-\nlogger = $logger;\n}\n\n\n\n\nDie hier notwendigen Parameter sind der Name der App, die Anfrage (Objekt, das die Schnittstelle \nIRequest\n implementiert), verschiedene Mapper Instanzen, die ID des Nutzers, \num bei der Autorisierung des Clients speichern zu k\u00f6nnen, welcher Nutzer dies veranlasst hat, und ein Logger (Objekt, das die Schnittstelle \nILogger\n implementiert). Letzterer ist notwendig um in die Log-Datei von ownCloud zu schreiben.\n\n\nDie mit den Routes verkn\u00fcpften Funktionen k\u00f6nnen zur Zugriffskontrolle mit \nPHPDoc Annotationen\n versehen werden. Folgendes Codebeispiel zeigt die Annotationen f\u00fcr die Funktion \ngenerateToken\n im \nOAuthApiController\n.\n\n\n?php\n/**\n * Implements the OAuth 2.0 Access Token Response.\n *\n * @param string $grant_type The authorization grant type.\n * @param string $code The authorization code.\n * @param string $redirect_uri The redirect URI.\n * @param string $refresh_token The refresh token.\n * @return JSONResponse The Access Token or an empty JSON Object.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n * @PublicPage\n * @CORS\n */\npublic function generateToken($grant_type, $code = null,\n                              $redirect_uri = null, $refresh_token = null) { }\n\n\n\n\nDie Annotationen haben dabei folgende Bedeutungen.\n\n\n\n\n\n\n\n\nAnnotation\n\n\nBedeutung\n\n\n\n\n\n\n\n\n\n\n@NoAdminRequired\n\n\nAufruf auch von normalen Nutzern m\u00f6glich.\n\n\n\n\n\n\n@NoCSRFRequired\n\n\nZeigt an, dass die \u00dcberpr\u00fcfung des CSRF Tokens nicht gewollt ist.\n\n\n\n\n\n\n@PublicPage\n\n\nZugriff auch ohne Login m\u00f6glich.\n\n\n\n\n\n\n@CORS\n\n\nAufruf der API durch andere Web Applikationen von au\u00dfen m\u00f6glich.\n\n\n\n\n\n\n\n\nIn den Controller-Funktionen k\u00f6nnen verschiedene Inhalte zur\u00fcckgegeben werden. Hier genutzte R\u00fcckgabetypen sind in der folgenden Tabelle zusammengefasst.\n\n\n\n\n\n\n\n\nTyp\n\n\nBeschreibung\n\n\n\n\n\n\n\n\n\n\nTemplateResponse\n\n\nZur R\u00fcckgabe eines Templates, das dem Nutzer angezeigt werden soll.\n\n\n\n\n\n\nRedirectResponse\n\n\nZur Weiterleitung des Nutzers an eine andere URL.\n\n\n\n\n\n\nJSONResponse\n\n\nZur R\u00fcckgabe eines JSON Strings.\n\n\n\n\n\n\n\n\nEin Beispiel f\u00fcr den R\u00fcckgabetyp \nTemplateResponse\n und gibt die Funktion \nauthorize\n im \nPageController\n, die im folgenden Codebeispiel zu sehen ist.\n\n\n?php\n/**\n * Shows a view for the user to authorize a client.\n *\n * @param string $response_type The expected response type.\n * @param string $client_id The client identifier.\n * @param string $redirect_uri The redirection URI.\n * @param string $state The state.\n *\n * @return TemplateResponse|RedirectResponse The authorize view or a\n * redirection to the ownCloud main page.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n */\npublic function authorize($response_type, $client_id, $redirect_uri,\n                          $state = null) {\n    if (!is_string($response_type) || !is_string($client_id)\n        || !is_string($redirect_uri) || (isset($state) \n !is_string($state))\n    ) {\n        return new TemplateResponse(\n            $this-\nappName,\n            'authorize-error',\n            ['client_name' =\n null, 'back_url' =\n OC_Util::getDefaultPageUrl()]\n        );\n    }\n\n    try {\n        /** @var Client $client */\n        $client = $this-\nclientMapper-\nfindByIdentifier($client_id);\n    } catch (DoesNotExistException $exception) {\n        return new TemplateResponse(\n            $this-\nappName,\n            'authorize-error',\n            ['client_name' =\n null, 'back_url' =\n OC_Util::getDefaultPageUrl()]\n        );\n    }\n\n    if (!Utilities::validateRedirectUri(\n            $client-\ngetRedirectUri(),\n            urldecode($redirect_uri),\n            $client-\ngetAllowSubdomains())\n    ) {\n        return new TemplateResponse(\n            $this-\nappName,\n            'authorize-error',\n            ['client_name' =\n $client-\ngetName(), 'back_url' =\n OC_Util::getDefaultPageUrl()]\n        );\n    }\n\n    if (strcmp($response_type, 'code') !== 0) {\n        return new TemplateResponse(\n            $this-\nappName,\n            'authorize-error',\n            ['client_name' =\n $client-\ngetName(), 'back_url' =\n OC_Util::getDefaultPageUrl()]\n        );\n    }\n\n    return new TemplateResponse($this-\nappName, 'authorize', ['client_name' =\n $client-\ngetName()]);\n}\n\n\n\n\nHier werden zun\u00e4chst die Parameter auf G\u00fcltigkeit \u00fcberpr\u00fcft. Sollten die Parameter nicht g\u00fcltig sein (beispielsweise deshalb, weil der angegebene Client nicht existiert oder dessen Redirection URI falsch angegeben wurde), wird mit einem \nTemplateResponse\n das Template \nauthorize-error\n zur\u00fcckgegeben. Andernfalls kommt das Template \nauthorize\n zum Einsatz. F\u00fcr das Rendern des Templates k\u00f6nnen Parameter \u00fcbergeben werden. Hier wurden die Parameter \nclient_name\n f\u00fcr den Namen des Clients und \nback_url\n f\u00fcr die URL des Zur\u00fcck-Buttons verwendet.\n\n\nDer R\u00fcckgabetyp \nRedirectResponse\n wird f\u00fcr die Ausstellung eines Authorization Codes in der Funktion \ngenerateAuthorizationCode\n im \nPageController\n genutzt. Folgendes Codebeispiel macht dies deutlich. Zudem wird der Einsatz von Entities und Mappern gezeigt.\n\n\n?php\n/**\n * Implements the OAuth 2.0 Authorization Response.\n *\n * @param string $response_type The expected response type.\n * @param string $client_id The client identifier.\n * @param string $redirect_uri The redirection URI.\n * @param string $state The state.\n *\n * @return RedirectResponse|JSONResponse Redirection to the given\n * redirect_uri or a JSON with an error message.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n */\npublic function generateAuthorizationCode($response_type, $client_id, $redirect_uri, $state = null) {\n    if (!is_string($response_type) || !is_string($client_id)\n        || !is_string($redirect_uri) || (isset($state) \n !is_string($state))\n    ) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    switch ($response_type) {\n        case 'code':\n            try {\n                /** @var Client $client */\n                $client = $this-\nclientMapper-\nfindByIdentifier($client_id);\n            } catch (DoesNotExistException $exception) {\n                return new RedirectResponse(OC_Util::getDefaultPageUrl());\n            }\n\n            if (!Utilities::validateRedirectUri(\n                    $client-\ngetRedirectUri(),\n                    urldecode($redirect_uri),\n                    $client-\ngetAllowSubdomains())\n            ) {\n                return new RedirectResponse(OC_Util::getDefaultPageUrl());\n            }\n\n            $this-\nauthorizationCodeMapper-\ndeleteByClientUser($client-\ngetId(), $this-\nuserId);\n            $this-\naccessTokenMapper-\ndeleteByClientUser($client-\ngetId(), $this-\nuserId);\n            $this-\nrefreshTokenMapper-\ndeleteByClientUser($client-\ngetId(), $this-\nuserId);\n\n            $code = Utilities::generateRandom();\n            $authorizationCode = new AuthorizationCode();\n            $authorizationCode-\nsetCode($code);\n            $authorizationCode-\nsetClientId($client-\ngetId());\n            $authorizationCode-\nsetUserId($this-\nuserId);\n            $authorizationCode-\nresetExpires();\n            $this-\nauthorizationCodeMapper-\ninsert($authorizationCode);\n\n            $result = urldecode($redirect_uri);\n            $result = $result . '?code=' . $code;\n            if (!is_null($state)) {\n                $result = $result . '\nstate=' . urlencode($state);\n            }\n\n            $this-\nlogger-\ninfo(\n                'An authorization code has been issued for the client \n' . $client-\ngetName() .'\n.',\n                ['app' =\n $this-\nappName]\n            );\n\n            return new RedirectResponse($result);\n        default:\n            return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n}\n\n\n\n\nIn dieser Funktion werden die Parameter \u00fcberpr\u00fcft. Falls diese nicht g\u00fcltig sind (beispielsweise deshalb, \nweil der angegebene Client nicht existiert oder dessen Redirection URI falsch angegeben wurde), wird an die ownCloud Startseite weitergeleitet. \nAnsonsten wird ein Authorization Code ausgestellt und als Parameter der Redirection URI angeh\u00e4ngt, zu welcher schlie\u00dflich weitergeleitet wird.\n\n\nDer R\u00fcckgabetyp \nJSONResponse\n wird f\u00fcr die R\u00fcckgabe des Access Tokens in der Funktion \ngenerateToken\n im \nOAuthApiController\n genutzt, wie nachfolgendes Codebeispiel zeigt. Zudem ist erneut das Zusammenspiel mit Entities und Mappern zu sehen.\n\n\n?php\n/**\n * Implements the OAuth 2.0 Access Token Response.\n *\n * @param string $grant_type The authorization grant type.\n * @param string $code The authorization code.\n * @param string $redirect_uri The redirect URI.\n * @param string $refresh_token The refresh token.\n * @return JSONResponse The Access Token or an empty JSON Object.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n * @PublicPage\n * @CORS\n */\npublic function generateToken($grant_type, $code = null,\n                              $redirect_uri = null, $refresh_token = null) {\n    if (!is_string($grant_type)) {\n        return new JSONResponse(['error' =\n 'invalid_request'], Http::STATUS_BAD_REQUEST);\n    }\n\n    if (is_null($_SERVER['PHP_AUTH_USER']) || is_null($_SERVER['PHP_AUTH_PW'])) {\n        return new JSONResponse(['error' =\n 'invalid_request'], Http::STATUS_BAD_REQUEST);\n    }\n\n    try {\n        /** @var Client $client */\n        $client = $this-\nclientMapper-\nfindByIdentifier($_SERVER['PHP_AUTH_USER']);\n    } catch (DoesNotExistException $exception) {\n        return new JSONResponse(['error' =\n 'invalid_client'], Http::STATUS_BAD_REQUEST);\n    }\n\n    if (strcmp($client-\ngetSecret(), $_SERVER['PHP_AUTH_PW']) !== 0) {\n        return new JSONResponse(['error' =\n 'invalid_client'], Http::STATUS_BAD_REQUEST);\n    }\n\n    switch ($grant_type) {\n        case 'authorization_code':\n            if (!is_string($code) || !is_string($redirect_uri)) {\n                return new JSONResponse(['error' =\n 'invalid_request'], Http::STATUS_BAD_REQUEST);\n            }\n\n            try {\n                /** @var AuthorizationCode $authorizationCode */\n                $authorizationCode = $this-\nauthorizationCodeMapper-\nfindByCode($code);\n            } catch (DoesNotExistException $exception) {\n                return new JSONResponse(['error' =\n 'invalid_grant'], Http::STATUS_BAD_REQUEST);\n            }\n\n            if (strcmp($authorizationCode-\ngetClientId(), $client-\ngetId()) !== 0) {\n                return new JSONResponse(['error' =\n 'invalid_grant'], Http::STATUS_BAD_REQUEST);\n            }\n\n            if ($authorizationCode-\nhasExpired()) {\n                return new JSONResponse(['error' =\n 'invalid_grant'], Http::STATUS_BAD_REQUEST);\n            }\n\n            if (!Utilities::validateRedirectUri(\n                    $client-\ngetRedirectUri(),\n                    urldecode($redirect_uri),\n                    $client-\ngetAllowSubdomains())\n            ) {\n                return new JSONResponse(['error' =\n 'invalid_grant'], Http::STATUS_BAD_REQUEST);\n            }\n\n            $this-\nlogger-\ninfo(\n                'An authorization code has been used by the client \n'\n                    . $client-\ngetName() . '\n to request an access token.',\n                ['app' =\n $this-\nappName]\n            );\n\n            $userId = $authorizationCode-\ngetUserId();\n            break;\n        case 'refresh_token':\n            if (!is_string($refresh_token)) {\n                return new JSONResponse(['error' =\n 'invalid_request'], Http::STATUS_BAD_REQUEST);\n            }\n\n            try {\n                /** @var RefreshToken $refreshToken */\n                $refreshToken = $this-\nrefreshTokenMapper-\nfindByToken($refresh_token);\n            } catch (DoesNotExistException $exception) {\n                return new JSONResponse(['error' =\n 'invalid_grant'], Http::STATUS_BAD_REQUEST);\n            }\n\n            if (strcmp($refreshToken-\ngetClientId(), $client-\ngetId()) !== 0) {\n                return new JSONResponse(['error' =\n 'invalid_grant'], Http::STATUS_BAD_REQUEST);\n            }\n\n            $this-\nlogger-\ninfo(\n                'A refresh token has been used by the client \n'\n                    . $client-\ngetName() . '\n to request an access token.',\n                ['app' =\n $this-\nappName]\n            );\n\n            $userId = $refreshToken-\ngetUserId();\n            break;\n        default:\n            return new JSONResponse(['error' =\n 'invalid_grant'], Http::STATUS_BAD_REQUEST);\n    }\n\n    $this-\nauthorizationCodeMapper-\ndeleteByClientUser($client-\ngetId(), $userId);\n    $this-\naccessTokenMapper-\ndeleteByClientUser($client-\ngetId(), $userId);\n    $this-\nrefreshTokenMapper-\ndeleteByClientUser($client-\ngetId(), $userId);\n\n    $token = Utilities::generateRandom();\n    $accessToken = new AccessToken();\n    $accessToken-\nsetToken($token);\n    $accessToken-\nsetClientId($client-\ngetId());\n    $accessToken-\nsetUserId($userId);\n    $accessToken-\nresetExpires();\n    $this-\naccessTokenMapper-\ninsert($accessToken);\n\n    $token = Utilities::generateRandom();\n    $refreshToken = new RefreshToken();\n    $refreshToken-\nsetToken($token);\n    $refreshToken-\nsetClientId($client-\ngetId());\n    $refreshToken-\nsetUserId($userId);\n    $this-\nrefreshTokenMapper-\ninsert($refreshToken);\n\n    return new JSONResponse(\n        [\n            'access_token' =\n $accessToken-\ngetToken(),\n            'token_type' =\n 'Bearer',\n            'expires_in' =\n 3600,\n            'refresh_token' =\n $refreshToken-\ngetToken(),\n            'user_id' =\n $userId\n        ]\n    );\n}\n\n\n\n\nHier werden zun\u00e4chst die Parameter auf G\u00fcltigkeit \u00fcberpr\u00fcft. Dabei gibt es die zwei F\u00e4lle \nauthorization_code\n und \nrefresh_token\n, \ndie durch die \nswitch\n-Anweisung abgedeckt werden. Bei fehlerhaften Angaben wird eine entsprechende Fehlermeldung im JSON-Format zur\u00fcckgegeben. \nAndernfalls wird eine neuer Access Token erstellt und in der Datenbank gespeichert. Der verwendete Authorization Code bzw. der Refresh Token wird zudem gel\u00f6scht. \nIm JSON Response wird dann der Access Token, der Token Typ (\nBearer\n wegen des Authorization Code Flow), die Lebensdauer, der Refresh Token und die ID des Nutzers zur\u00fcckgegeben. Nachfolgend ist ein Beispiel dazu angegeben.\n\n\n{\n    \naccess_token\n : \n1vtnuo1NkIsbndAjVnhl7y0wJha59JyaAiFIVQDvcBY2uvKmj5EPBEhss0pauzdQ\n,\n    \ntoken_type\n : \nBearer\n,\n    \nexpires_in\n : 3600,\n    \nrefresh_token\n : \n7y0wJuvKmj5E1vjVnhlPBEhha59JyaAiFIVQDvcBY2ss0pauzdQtnuo1NkIsbndA\n,\n    \nuser_id\n : \nadmin\n\n}\n\n\n\n\nF\u00fcr die Token-Generierung wurde die Hilfsklasse \nUtilities\n mit der statischen Funktion \ngenerateRandom\n geschrieben, die mithilfe einer ownCloud-internen Funktion 64-stellige zuf\u00e4llige Zeichenketten erzeugt. Folgendes Codebeispiel zeigt diese Funktion.\n\n\n?php\n/**\n * Generates a random string with 64 characters.\n *\n * @return string The random string.\n */\npublic static function generateRandom() {\n    return \\OC::$server-\ngetSecureRandom()-\ngenerate(64,\n        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789');\n}\n\n\n\n\nZusammenfassend werden im folgenden UML-Klassendiagramm die Controller mit ihren Beziehungen, die Entities und die Mapper, sowie die Klasse \nUtilities\n dargestellt.\n\n\n\n\nTemplates\n\n\nIn den \nTemplates\n einer ownCloud App wird die f\u00fcr den Nutzer sichtbare Oberfl\u00e4che definiert. Es k\u00f6nnen die vom \nController\n \u00fcbergebenen Parameter genutzt werden. Dazu gibt es ein Array mit dem Namen \n$_\n. Zur Vermeidung von Cross-Site-Scripting existiert zudem die ownCloud-interne Funktion \np()\n, mithilfe derer Werte ausgegeben werden k\u00f6nnen.\n\n\nFolgende Templates wurden in der App definiert:\n\n\n\n\nauthorize\n: Zur Darstellung des Authorization Requests, bei dem der Nutzer um Autorisierung eines Clients gebeten wird. Es werden ein Text zur Erkl\u00e4rung sowie Buttons zum Akzeptieren oder Ablehnen angezeigt.\n\n\nauthorize-error\n: Zur Information des Nutzers mit einer Fehlermeldung, falls der Authorization Request wegen fehlerhafter Parameter ung\u00fcltig ist.\n\n\nsettings-admin\n: Stellt zur Verwaltung der Clients eine tabellarische Auflistung der Clients sowie ein Formular zum Hinzuf\u00fcgen von Clients dar.\n\n\nsettings-personal\n: Stellt eine tabellarische Auflistung der vom Nutzer autorisierten Clients dar, mit der M\u00f6glichkeit, die Autorisierung zu widerrufen.\n\n\n\n\nFolgendes Codebeispiel zeigt das Template \nsettings-admin\n.\n\n\n?php\n/** @var \\OCA\\OAuth2\\Db\\Client $client */\nscript('oauth2', 'settings');\nstyle('oauth2', 'main');\nstyle('oauth2', 'settings-admin');\n?\n\n\n\ndiv class=\nsection\n id=\noauth2\n\n    \nh2\n?php p($l-\nt('OAuth 2.0')); ?\n/h2\n\n\n    \nh3\n?php p($l-\nt('Registered clients')); ?\n/h3\n\n    \n?php if (empty($_['clients'])) {\n        p($l-\nt('No clients registered.'));\n    }\n    else { ?\n\n    \ntable class=\ngrid\n\n        \nthead\n\n        \ntr\n\n            \nth id=\nheaderName\n scope=\ncol\n?php p($l-\nt('Name')); ?\n/th\n\n            \nth id=\nheaderRedirectUri\n scope=\ncol\n?php p($l-\nt('Redirection URI')); ?\n/th\n\n            \nth id=\nheaderClientIdentifier\n scope=\ncol\n?php p($l-\nt('Client Identifier')); ?\n/th\n\n            \nth id=\nheaderSecret\n scope=\ncol\n?php p($l-\nt('Secret')); ?\n/th\n\n            \nth id=\nheaderSubdomains\n scope=\ncol\n?php p($l-\nt('Subdomains allowed')); ?\n/th\n\n            \nth id=\nheaderRemove\nnbsp;\n/th\n\n        \n/tr\n\n        \n/thead\n\n        \ntbody\n\n            \n?php foreach ($_['clients'] as $client) { ?\n\n                \ntr\n\n                    \ntd\n?php p($client-\ngetName()); ?\n/td\n\n                    \ntd\n?php p($client-\ngetRedirectUri()); ?\n/td\n\n                    \ntd\ncode\n?php p($client-\ngetIdentifier()); ?\n/code\n/td\n\n                    \ntd\ncode\n?php p($client-\ngetSecret()); ?\n/code\n/td\n\n                        \ntd id=\ntd-allow-subdomains\n\n                            \n?php if ($client-\ngetAllowSubdomains()) {?\n\n                                \nimg alt=\n src=\n/core/img/actions/checkmark.svg\n\n                            \n?php } ?\n\n                        \n/td\n\n                    \ntd\n\n                        \nform id=\nform-inline\n class=\ndelete\n\n                            data-confirm=\n?php\n                                p($l-\nt('Are you sure you want to delete this item?'));\n                            ?\n\n                            action=\n../apps/oauth2/clients/\n?php p($client-\ngetId()); ?\n/delete\n\n                            method=\npost\n\n                            \ninput type=\nsubmit\n class=\nbutton icon-delete\n value=\n\n                        \n/form\n\n                    \n/td\n\n                \n/tr\n\n            \n?php } ?\n\n        \n/tbody\n\n    \n/table\n\n    \n?php } ?\n\n\n    \nh3\n?php p($l-\nt('Add client')); ?\n/h3\n\n    \nform action=\n../apps/oauth2/clients\n method=\npost\n\n        \ninput id=\nname\n name=\nname\n type=\ntext\n placeholder=\n?php p($l-\nt('Name')); ?\n\n        \ninput id=\nredirect_uri\n name=\nredirect_uri\n type=\nurl\n\n            placeholder=\n?php p($l-\nt('Redirection URI')); ?\n\n        \ninput type=\ncheckbox\n class=\ncheckbox\n name=\nallow_subdomains\n\n            id=\nallow_subdomains\n value=\n1\n/\n\n        \nlabel for=\nallow_subdomains\n?php p($l-\nt('Allow subdomains'));?\n/label\n\n        \ninput type=\nsubmit\n class=\nbutton\n value=\n?php p($l-\nt('Add')); ?\n\n    \n/form\n\n\n/div\n\n\n\n\n\nIn diesem Template wird eine Tabelle mit den registrierten Clients angezeigt. Zu Beginn werden mit den Funktionen \nscript\n und \nstyle\n zus\u00e4tzliche JavaScript- bzw. CSS-Dateien aus den Verzeichnissen \njs\n bzw. \ncss\n geladen. Durch eine \nfor\n-Schleife wird dann f\u00fcr jeden Client aus dem Parameter \nclients\n ein Tabelleneintrag angezeigt. Sollten noch keine Clients registriert worden sein, sorgt die \nif\n-Anweisung daf\u00fcr, dass die Meldung \u201eNo clients registered\u201c angezeigt wird. Durch Nutzung der Funktion \nt\n der globalen Variable \n$l\n k\u00f6nnen die Strings auch \nin andere Sprachen \u00dcbersetzt werden\n. Im Zuge des Transfers der App in die ownCloud GitHub-Organisation wurde Transifex als \u00dcbersetzungsplattform integriert. Dies bedeutet, dass nun im \nl1on\n-Verzeichnis der OAuth 2.0 App \u00dcbersetzungen der originalen (von uns erstellten) englischen Strings aus den Templates von der Transifex-Community hinzugef\u00fcgt und ge\u00e4ndert werden k\u00f6nnen. Dadurch liegen bereits zum aktuellen Zeitpunkt \u00fcber 15 \u00dcbersetzungen der App vor. Diese werden je nach Spracheinstellung der ownCloud-Instanz angezeigt. Des Weiteren gibt es unter der Tabelle ein Formular f\u00fcr das Hinzuf\u00fcgen von Clients. Die in dem Formular angegebene Aktion l\u00f6st die Funktion \naddClient\n im \nSettingsController\n aus. Analog dazu gibt es f\u00fcr jeden Tabelleneintrag ein Formular zum L\u00f6schen des Eintrags, das die Funktion \ndeleteClient\n im \nSettingsController\n ausl\u00f6st.\n\n\nHooks\n\n\nBei der Implementierung der App mussten wir bedenken, dass Nutzer aus ownCloud auch gel\u00f6scht werden k\u00f6nnen. Deshalb musste sichergestellt werden, dass beim L\u00f6schen eines Nutzers auch alle mit ihm verkn\u00fcpften Authorization Codes, Access Tokens und Refresh Tokens gel\u00f6scht werden.\n\n\nHierf\u00fcr gibt es in ownCloud das Konzept der \nHooks\n, welche bei bestimmten Ereignissen ausgel\u00f6st werden. Eigene Hooks werden in der \napp.php\n registriert.\n\n\nDa wir vor dem L\u00f6schen eines Nutzers eine Datenbankbereinigung durchf\u00fchren m\u00fcssen, war der \npreDelete\n-Hook von Interesse. Dazu wurde die Klasse \nUserHooks\n implementiert. Folgendes Codebeispiel zeigt dessen Funktion \nregister\n, in der die vor dem L\u00f6schen durchzuf\u00fchrenden Aktionen definiert werden.\n\n\n/**\n * Registers a pre-delete hook for users to delete authorization codes,\n * access tokens and refresh tokens that reference the user.\n */\npublic function register() {\n    /**\n     * @param User $user .\n     */\n    $callback = function ($user) {\n        if (!is_null($user-\ngetUID())) {\n            $this-\nlogger-\ninfo(\n                'Deleting authorization codes, access tokens and refresh tokens referencing the user to be deleted \n' . $user-\ngetUID() . '\n.',\n                ['app' =\n $this-\nappName]);\n\n            $this-\nauthorizationCodeMapper-\ndeleteByUser($user-\ngetUID());\n            $this-\naccessTokenMapper-\ndeleteByUser($user-\ngetUID());\n            $this-\nrefreshTokenMapper-\ndeleteByUser($user-\ngetUID());\n        }\n    };\n\n    $this-\nuserManager-\nlisten('\\OC\\User', 'preDelete', $callback);\n}\n\n\n\n\nHier wird mithilfe des ownCloud-internen \nUserManager\ns ein Callback f\u00fcr den \npreDelete\n-Hook registriert. In dem Callback werden nach Erstellung eines Log-Eintrags mithilfe der Mapper alle Datenbank-Eintr\u00e4ge zu dem Nutzer gel\u00f6scht. Dazu wurde die Funktion \ndeleteByUser\n im \nAuthorizationCodeMapper\n, \nAccessTokenMapper\n und \nRefreshTokenMapper\n implementiert.\n\n\nBackground Job\n\n\nDa Authorization Codes und Access Tokens eine begrenzte Lebensdauer haben, entstehen mit der Zeit ungenutzte Eintr\u00e4ge in der Datenbank. Zur Bereinigung wurde ein \nBackground Job\n erstellt, der regelm\u00e4\u00dfig ausgef\u00fchrt wird. Die Registrierung erfolgt dabei auch in der \napp.php\n. Folgendes Codebeispiel zeigt die Implementierung der Klasse \nCleanUp\n, in der der auszuf\u00fchrende Code definiert wird.\n\n\n?php\nnamespace OCA\\OAuth2\\BackgroundJob;\n\nuse OCA\\OAuth2\\AppInfo\\Application;\n\nclass CleanUp {\n\n    /**\n     * Cleans up expired authorization codes and access tokens.\n     */\n    public static function run() {\n        $app = new Application();\n        $container = $app-\ngetContainer();\n\n        $container-\nquery('OCA\\OAuth2\\Db\\AuthorizationCodeMapper')-\ncleanUp();\n        $container-\nquery('OCA\\OAuth2\\Db\\AccessTokenMapper')-\ncleanUp();\n    }\n\n}\n\n\n\n\nBei Ausf\u00fchrung des Background Jobs wird die \nrun\n Methode aufgerufen. Hier werden \u00fcber den \nContainer\n der App der \nAuthorizationCodeMapper\n und \nAccessTokenMapper\n abgefragt, sowie deren \ncleanUp\n Funktion aufgerufen. In dieser Funktion werden alle Eintr\u00e4ge, die vor einer Woche abgelaufen sind, aus der Datenbank gel\u00f6scht.\n\n\nLogging\n\n\nZur Information des Administrators wird bei folgenden Ereignissen in die Log-Datei geschrieben:\n\n\n\n\nHinzuf\u00fcgen bzw. L\u00f6schen von Clients.\n\n\nAusstellung von Authorization Codes.\n\n\nEinl\u00f6sung von Authorization Codes bzw. Refresh Tokens.\n\n\nBereinigung der Datenbank von abgelaufenen Authorization Codes bzw. Access Tokens.\n\n\n\n\nAls Log-Level wurde \ninfo\n gew\u00e4hlt.\n\n\nAuthentifizierungslogik\n\n\nNach der Implementierung des OAuth 2.0 Protokolls musste die Authentifizierung von WebDAV und von ownCloud APIs (f\u00fcr die Nutzung der OCS Share API) Erweitert werden. Diese Erweiterung basiert auf den durchgef\u00fchrten \nCore Anpassungen\n.\n\n\nZun\u00e4chst sahen wir uns die Umsetzung der bestehenden Basic Authentication in der \ndav\n App an. Dabei stellten wir fest, dass sabre den \nAustausch des Authentifizierungsmechanismus\n durch Implementierung eines Interfaces bietet. F\u00fcr unser Szenario war das Interface \nAbstractBearer\n relevant, da die Access Tokens aus dem Authorization Code Flow des OAuth 2.0 Protokolls f\u00fcr Bearer Authentication genutzt werden. Dazu haben wir die Funktion \nvalidateBearerToken\n in der Klasse \nOAuth2\n implementieren. Die Logik und das Session-Management lehnen sich stark an die bestehende Implementierung der Basic Authentication an. F\u00fcr die Authentifizierung einer Anfrage wird hier jedoch auf \nAuthModule\ns zur\u00fcckgegriffen.\n\n\nEin \nAuthModule\n kann von ownCloud Apps implementiert und registriert werden. Es wird auch bei der Authentifizierung von API Zugriffen eingesetzt. Eine App muss dazu die Funktionen \nauth\n und \ngetUserPassword\n implementieren. Erstere authentifiziert eine Anfrage, w\u00e4hrend letztere das Passwort des Nutzers zu einer Anfrage ermittelt. Da die App \nencryption\n in bestimmten Nutzungsszenarien auf das Passwort des Nutzers angewiesen ist, existiert die Funktion \ngetUserPassword\n. Sie gibt jedoch in unserer Implementierung eine leere Zeichenkette zur\u00fcck, da wir an keiner Stelle mit Passw\u00f6rtern umgehen (siehe \nEinschr\u00e4nkungen\n). \ngetUserPassword\n gibt bei erfolgreicher Authentifizierung ein \nUser\n-Objekt zur\u00fcck, wie in folgendem Codebeispiel zu sehen ist.\n\n\n?php\n/**\n * Authenticates a request.\n *\n * @param IRequest $request The request.\n *\n * @return null|IUser The user if the request is authenticated, null otherwise.\n */\npublic function auth(IRequest $request) {\n    $authHeader = $request-\ngetHeader('Authorization');\n    if (strpos($authHeader, 'Bearer ') === false) {\n        return null;\n    } else {\n        $bearerToken = substr($authHeader, 7);\n    }\n    $app = new Application();\n    $container = $app-\ngetContainer();\n    /** @var AccessTokenMapper $accessTokenMapper */\n    $accessTokenMapper = $container-\nquery('OCA\\OAuth2\\Db\\AccessTokenMapper');\n    try {\n        /** @var AccessToken $accessToken */\n        $accessToken = $accessTokenMapper-\nfindByToken($bearerToken);\n        if ($accessToken-\nhasExpired()) {\n            return null;\n        }\n    } catch (DoesNotExistException $exception) {\n        return null;\n    }\n    /** @var IUserManager $userManager */\n    $userManager = $container-\nquery('UserManager');\n    $user = $userManager-\nget($accessToken-\ngetUserId());\n    return $user;\n}\n\n\n\n\nNach Extraktion des Bearer Tokens aus den Authorization Header, wird durch R\u00fcckgriff auf den \nAccessTokenMapper\n die \nuser_id\n ermittelt. Mithilfe des ownCloud-internen \nUserManager\ns kann daraufhin das \nUser\n-Objekt abgefragt werden.\n\n\nZur Registrierung eines \nAuthModules\n muss dessen Namespace in der \ninfo.xml\n angegeben werden, wie im folgenden Codebeispiel gezeigt wird:\n\n\nauth-modules\n\n  \nmodule\nOCA\\OAuth2\\AuthModule\n/module\n\n\n/auth-modules\n\n\n\n\n\nDamit die OAuth 2.0 Implementierung f\u00fcr die Authentifizierung in der \ndav\n App genutzt werden kann, musste sie f\u00fcr diese bekannt gemacht werden. Dazu wurde im Konstruktur der Klasse \nApplication\n, von der in der \napp.php\n eine Instanz erzeugt wird, ein Event Listener hinzugef\u00fcgt, der das \nauthInit\n-Event des WebDAV-Server abgreift. Folgendes Codebeispiel macht dies deutlich.\n\n\n?php\n$dispatcher = $this-\ngetContainer()-\ngetServer()-\ngetEventDispatcher();\n$dispatcher-\naddListener('OCA\\DAV\\Connector\\Sabre::authInit', function ($event) use ($container) {\n    if ($event instanceof SabrePluginEvent) {\n        $authPlugin = $event-\ngetServer()-\ngetPlugin('auth');\n        if ($authPlugin instanceof Plugin) {\n            $authPlugin-\naddBackend(\n                new OAuth2(\\OC::$server-\ngetSession(),\n                    \\OC::$server-\ngetUserSession(),\n                    \\OC::$server-\ngetRequest(),\n                    'principals/')\n            );\n        }\n    }\n});\n\n\n\n\nBeim Ausl\u00f6sen des \nauthInit\n-Events wird der hier definierte Code ausgef\u00fchrt, der daf\u00fcr sorgt, dass ein zus\u00e4tzliches Backend f\u00fcr die Authentifizierung mittels OAuth 2.0 hinzugef\u00fcgt wird. Da die App damit ein Authentication Backend bereitstellt, war es notwendig, dies in der \ninfo.xml\n bei den \nTypes\n bekanntzugeben, wie folgendes Codebeispiel zeigt.\n\n\ntypes\n\n    \nauthentication/\n\n\n/types\n\n\n\n\n\nTests und Continuous Integration\n\n\nZum Testen der PHP-Klassen wurde das Framework \nPHPUnit\n verwendet. Die aktuelle Testabdeckung ist bei Codecov einsehbar: \n.\n\n\nAls Continuous Integration Tool wurde Travis CI verwendet. Bei jeder \u00c4nderung im \nGitHub Repository\n wird ein Build angesto\u00dfen, in dem die App mithilfe eines Makefiles f\u00fcr den App Store gebaut wird und anschlie\u00dfend in verschiedenen Umgebungen installiert und getestet wird. Folgende Parameter werden variiert:\n\n\n\n\nPHP Versionen\n: 5.6, 7.0, 7.1, nightly\n\n\nDatenbanken\n: PostgreSQL, MySQL, SQLite\n\n\nBranches des ownCloud Core\n: \nmaster\n\n\n\n\nDer aktuelle Build-Status ist bei Travis einsehbar: \n.\n\n\nEinschr\u00e4nkungen\n\n\nDa in der App nicht mit Passw\u00f6rtern des Nutzers umgegangen wird, k\u00f6nnen beim Login eines Nutzers der \npreLogin\n- und der \npostLogin\n-Hook nicht mit dem Passwort des Nutzers ausgel\u00f6st werden. Dies f\u00fchrt dazu, dass die \nencryption\n App nur mit der Master Key Encryption genutzt werden kann.", 
            "title": "OAuth 2.0 App"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#app-oauth2", 
            "text": "", 
            "title": "App: oauth2"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#zweck", 
            "text": "In der App sollte der h\u00e4ufig f\u00fcr Webapplikationen eingesetzte  Authorization Code Flow  implementiert werden. Dazu mussten folgende Nutzungsszenarien umgesetzt werden:   Clientregistrierung:  Als ownCloud-Administrator m\u00f6chte ich Clients in den Administrator-Einstellungen hinzuf\u00fcgen und l\u00f6schen k\u00f6nnen, um die Kontrolle \u00fcber erlaubte Clients zu haben.  Log-Eintr\u00e4ge : Als ownCloud-Administrator m\u00f6chte ich durch Log-Eintr\u00e4ge \u00fcber Ereignisse zu OAuth 2.0 informiert werden.  Authorization URL:  Als Client-Entwickler m\u00f6chte ich eine Authorization URL zur Verf\u00fcgung haben, um Authorization Codes anfordern zu k\u00f6nnen.  Access Token URL:  Als Client-Entwickler m\u00f6chte ich eine Access Token URL zur Verf\u00fcgung haben, um Access Tokens anfordern zu k\u00f6nnen.  Verwaltung autorisierter Applikationen : Als ownCloud-Nutzer m\u00f6chte ich in den pers\u00f6nlichen Einstellungen autorisierte Applikationen verwalten k\u00f6nnen, um einen \u00dcberblick zu haben und Autorisierungen widerrufen zu k\u00f6nnen.", 
            "title": "Zweck"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#authorization-code-flow", 
            "text": "Die nachfolgende Abbildung stellt den durch die  oauth2  App implementierten  OAuth 2.0 Authorization Code Flow  dar.   Anmerkung: Die Schritte 1, 2 und 3 sind zweigeteilt, da sie durch den User-Agent laufen.    \n     [vgl.  RFC 6749, S. 24 ]   Der Authorization Code Flow kann von jedem Client, der registriert ist, angesto\u00dfen werden. Zur Registrierung eines Clients gibt der Administrator in den ownCloud Einstellungen folgende Informationen an:   Name des Clients: Zur Wiedererkennung  Redirection URI: URI, an die nach erfolgter Autorisierung des Nutzers weitergeleitet wird.  Umgang mit Subdomains: Zum Einstellen, ob Subdomains der Redirection URI erlaubt werden sollen.   Die App generiert daraufhin die Zugangsdaten des Clients, bestehend aus Client Identifier und Client Secret.  Im Flow sind folgende Rollen beteiligt:   Client: Die Applikation, die f\u00fcr Zugriffe auf gesch\u00fctzte Ressourcen autorisiert werden m\u00f6chte. In unserem Integrationsszenario: Moodle.  Authorization Server: Die Applikation, die den Client f\u00fcr Zugriffe autorisiert. In unserem Integrationsszenario: ownCloud.  Resource Owner: Der Eigent\u00fcmer der gesch\u00fctzten Ressourcen. In unserem Integrationsszenario: ownCloud Nutzer.  User Agent: Durch ihn erfolgt die Kommunikation zwischen Client, Resource Owner und Authorization Server. In unserem Integrationsszenario: ein Webbrowser.   Folgende Schritte werden durchlaufen:   Der Client initiiert den Flow durch Weiterleitung des Resource Owners an die Authorization URL  /index.php/apps/oauth2/authorize . URL Parameter:  response_type : Da hier der Authorization Code Flow betrachtet wird, muss  code  angegeben werden.  client_id : Der Client Identifier aus der Clientregistrierung.  redirect_uri : Die Redirection URI aus der Clientregistrierung.  state : Kann vom Client optional angegeben werden, um die Anfrage bei Erhalt einer Antwort wiedererkennen zu k\u00f6nnen.    Der Resource Owner authentifiziert sich daraufhin beim Authorization Server und entscheidet \u00fcber die Autorisierung des Clients.  Bei erfolgter Autorisierung, wird ein Authorization Code ausgestellt (ein Authorization Code ist f\u00fcr 10 Minuten g\u00fcltig). Die App leitet dann an die Redirection URI weiter. URL Parameter:  code : Der ausgestellte Authorization Code.  state : optional, falls unter 1. angegeben.    Mit dem Authorization Code kann der Client ein Access Token anfordern. Dazu sendet er einen  POST -Request an die Access Token URL  /index.php/apps/oauth2/api/v1/token . Zus\u00e4tzlich ist eine Client Authentifizierung mittels Basic Authentication (Nutzername: Client Identifier, Passwort: Client Secret) notwendig. URL Parameter:  grant_type : entweder  authorization_code  oder  refresh_token  code  und  redirect_uri  (falls  authorization_code  als Grant Type angegeben wurde)  refresh_token  (falls  refresh_token  als Grant Type angegeben wurde)    Bei g\u00fcltigen Angaben wird ein Access Token mit Refresh Token ausgestellt (ein Access Token ist f\u00fcr 1 Stunde g\u00fcltig). Abgelaufene Access Tokens k\u00f6nnen mithilfe des Refresh Tokens gegen neue eingetauscht werden.", 
            "title": "Authorization Code Flow"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#datenmodell", 
            "text": "Zun\u00e4chst musste ein Datenmodell zur Speicherung der ben\u00f6tigten Daten aufgestellt werden. Gem\u00e4\u00df dem Authorization Code Flow wurden folgende Entit\u00e4ten mit Attributen definiert:   client :  Die Applikation, die f\u00fcr den Zugriff auf die WebDAV Schnittstelle autorisiert werden soll.  identifier : Zeichenkette, die einen Client eindeutig identifiziert.  secret : Zeichenkette, mit der ein Client sich beim Anfordern eines Access Tokens authentifizieren kann.  redirect_uri : URI, an die nach erfolgter Autorisierung des Nutzers weitergeleitet wird.  name : Ein Name f\u00fcr den Client zur Wiedererkennung.  allow_subdomains : Zum Einstellen, ob Subdomains der  redirect_uri  erlaubt werden sollen.    authorization_code :  Ein  Authorization Grant , \nmit dem der Client die Autorisierung des Nutzers darlegen und somit ein Access Token anfordern kann.  code : Zeichenkette, die als Authorization Code dient.  client_id : Client Identifier des Clients, f\u00fcr den der Authorization Code ausgegeben wird.  user_id : User ID des ownCloud-Nutzers, der den Client autorisiert hat.  expires : Zeitpunkt, zu dem der Authorization Code ung\u00fcltig wird.    access_token :  Eine Zeichenkette, die den Zugriff auf die WebDAV Schnittstelle erlaubt.  token : Zeichenkette, die als Access Token dient.  client_id : Client Identifier des Clients, f\u00fcr den der Access Token ausgegeben wird.  user_id : User ID des ownCloud-Nutzers, der den Client autorisiert hat.  expires : Zeitpunkt, zu dem der Access Token ung\u00fcltig wird.    refresh_token :  Eine Zeichenkette, mit der ein abgelaufener Access Token gegen einen neuen ausgetauscht werden kann.  token : Zeichenkette, die als Refresh Token dient.  client_id : Client Identifier des Clients, f\u00fcr den der Access Token ausgegeben wird.  user_id : User ID des ownCloud-Nutzers, der den Client autorisiert hat.     Folgendes Entity-Relationship-Modell fasst das Datenmodell grafisch zusammen.", 
            "title": "Datenmodell"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#vorgegebene-schnittstelle", 
            "text": "Zur Erweiterung von ownCloud wird das Konzept von  Apps  geboten. ownCloud Apps liegen im Verzeichnis  apps  einer ownCloud Installation und besitzen folgende  Struktur :  appinfo\n  \u251c\u2500\u2500 app.php               # Die erste Datei, die beim Laden der App ausgef\u00fchrt wird\n  \u251c\u2500\u2500 database.xml          # Definiert das Datenbankschema\n  \u251c\u2500\u2500 info.xml              # Enth\u00e4lt Metadaten\n  \u2514\u2500\u2500 routes.php            # Definiert die Routes\ncss                         # Enth\u00e4lt alle CSS-Dateien\nimg                         # Enth\u00e4lt alle Bilder\njs                          # Enth\u00e4lt alle JavaScript-Dateien\nl10n                        # Enth\u00e4lt die \u00dcbersetzungen\nlib                         # Enth\u00e4lt alle Klassen-Dateien\n  \u251c\u2500\u2500 Controller            # Enth\u00e4lt die Controller\n  \u2514\u2500\u2500 ...\ntemplates                   # Enth\u00e4lt die Templates\ntests                       # Enth\u00e4lt die Tests  Auf die Implementierung der Hauptbestandteile wird in den n\u00e4chsten Abschnitten eingegangen.", 
            "title": "Vorgegebene Schnittstelle"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#implementierung", 
            "text": "", 
            "title": "Implementierung"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#mapper-und-entities", 
            "text": "F\u00fcr den Datenbank-Zugriff im PHP-Code ist es in ownCloud m\u00f6glich,  Mapper  und  Entities  zu schreiben. \nDadurch werden Tupel in einer Datenbank-Tabelle automatisch in ein Objekt umgewandelt.  Folgendes Codebeispiel zeigt am Beispiel des Entitys  Client , wie eine PHP-Klasse dazu aussehen muss.  ?php\nnamespace OCA\\OAuth2\\Db;\n\nuse OCP\\AppFramework\\Db\\Entity;\n\n/**\n * @method string getIdentifier()\n * @method void setIdentifier(string $identifier)\n * @method string getSecret()\n * @method void setSecret(string $secret)\n * @method string getRedirectUri()\n * @method void setRedirectUri(string $redirectUri)\n * @method string getName()\n * @method void setName(string $name)\n * @method boolean getAllowSubdomains()\n * @method void setAllowSubdomains(boolean $value)\n */\nclass Client extends Entity {\n\n    protected $identifier;\n    protected $secret;\n    protected $redirectUri;\n    protected $name;\n    protected $allowSubdomains;\n\n    public function __construct() {\n        $this- addType('id', 'int');\n        $this- addType('identifier', 'string');\n        $this- addType('secret', 'string');\n        $this- addType('redirect_uri', 'string');\n        $this- addType('name', 'string');\n        $this- addType('allow_subdomains', 'boolean');\n    }\n\n}  Wichtig ist, dass die Klasse von  Entity  erbt und sowohl der Klassenname als auch die Attribute mit denen der Tabelle \u00fcbereinstimmen. \nPascal bzw. Camel case im PHP-Code wird automatisch zu Snake case f\u00fcr die Datenbank umgewandelt. \nGetter und Setter werden ebenfalls automatisch generiert. Die PHPDoc Kommentare dienen lediglich dazu, \nin der Entwicklungsumgebung eine automatische Vervollst\u00e4ndigung zu haben. \nDie Angabe von  Typen  im Konstruktor dient dazu, \nbeim Lesen aus der Datenbank die richtige Umwandlung zu erhalten.  Das folgende Codebeispiel zeigt einen Ausschnitt aus dem zur  Client -Entity geh\u00f6renden Mapper.  ?php\nnamespace OCA\\OAuth2\\Db;\n\nuse InvalidArgumentException;\nuse OCP\\AppFramework\\Db\\Entity;\nuse OCP\\AppFramework\\Db\\Mapper;\nuse OCP\\IDb;\n\nclass ClientMapper extends Mapper {\n\n    /**\n     * ClientMapper constructor.\n     *\n     * @param IDb $db Database Connection.\n     */\n    public function __construct(IDb $db) {\n        parent::__construct($db, 'oauth2_clients');\n    }\n\n    /**\n     * Selects a client by its ID.\n     *\n     * @param int $id The client's ID.\n     *\n     * @return Entity The client entity.\n     *\n     * @throws \\OCP\\AppFramework\\Db\\DoesNotExistException if not found.\n     * @throws \\OCP\\AppFramework\\Db\\MultipleObjectsReturnedException if more\n     * than one result.\n     */\n    public function find($id) {\n        if (!is_int($id)) {\n            throw new InvalidArgumentException('id must not be null');\n        }\n\n        $sql = 'SELECT * FROM `' . $this- tableName . '` WHERE `id` = ?';\n        return $this- findEntity($sql, [$id], null, null);\n    }\n\n    /**\n     * Selects clients by the given user ID.\n     *\n     * @param string $userId The user ID.\n     *\n     * @return array The client entities.\n     */\n    public function findByUser($userId) {\n        if (!is_string($userId)) {\n            throw new InvalidArgumentException('userId must not be null');\n        }\n\n        $sql = 'SELECT * FROM `' . $this- tableName . '` '\n            . 'WHERE `id` IN ( '\n                . 'SELECT `client_id` FROM `oc_oauth2_authorization_codes` WHERE `user_id` = ? '\n                . 'UNION '\n                . 'SELECT `client_id` FROM `oc_oauth2_access_tokens` WHERE `user_id` = ? '\n            . ')';\n        return $this- findEntities($sql, [$userId, $userId], null, null);\n    }\n\n}  Beim Mapper ist es wichtig, dass die Klasse von  Mapper  erbt und eine Entity-Klasse zu ihm existiert. \nDazu wird das Wort vor \u201eMapper\u201c als Entityname verwendet. Im Konstruktur wird der Tabellenname angegeben. \nDie beiden Funktionen  find  und  findByUser  demonstrieren  SELECT -Anweisungen. \nDazu wird die SQL-Anweisung zusammen mit ben\u00f6tigten Parametern an  findEntity  bzw.  findEntities  \u00fcbergeben, abh\u00e4ngig davon, ob mehrere Entities im Ergebnis enthalten sein sollten. \nFunktionen zum L\u00f6schen, Einf\u00fcgen und Aktualisieren werden von der Oberklasse bereits implementiert und mussten nicht angepasst werden.", 
            "title": "Mapper und Entities"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#schnittstellen-und-routes", 
            "text": "Um in einer ownCloud App Schnittstellen anzubieten, m\u00fcssen  Routes  registriert werden. \nZur Umsetzung der erw\u00e4hnten User Stories waren folgende Routes notwendig:     Methode  Endpunkt  Beschreibung      GET  authorize  Endpunkt, zu dem der Client den Nutzer weiterleitet, um die Autorisierung anzufragen (Authorization URL).    POST  authorize  Endpunkt, der aufgerufen wird, sobald der Nutzer den Client autorisiert hat.    POST  api/v1/token  Endpunkt, an dem ein Access Token angefordert wird (Access Token URL).    POST  clients  Endpunkt, durch den der Administrator einen Client hinzuf\u00fcgen kann.    POST  clients/{id}/delete  Endpunkt, durch den der Administrator den Client mit der ID  id  l\u00f6schen kann.    POST  clients/{id}/revoke  Endpunkt, durch den der Nutzer die Autorisierung des Clients mit der ID  id  widerrufen kann.     Registriert werden die Routes in der Datei  routes.php , indem ein Array mit den Routes zur\u00fcckgegeben wird. Nachfolgendes Codebeispiel zeigt einige der obigen Routes:  ?php\nreturn [\n    'routes' =  [\n        ['name' =  'page#authorize', 'url' =  '/authorize', 'verb' =  'GET'],\n        ['name' =  'o_auth_api#generate_token', 'url' =  '/api/v1/token', 'verb' =  'POST'],\n        ['name' =  'settings#deleteClient', 'url' =  '/clients/{id}/delete', 'verb' =  'POST']\n    ]\n];  Durch  name  wird f\u00fcr jede Route der Name des dazugeh\u00f6rigen  Controllers  sowie die aufzurufende Funktion angegeben: Vor dem  # -Zeichen steht der Controllername in Snake case und hinter dem  # -Zeichen steht der Funktionsname (ebenfalls in Snake case). Mithilfe von  url  wird der Endpunkt festgelegt und  verb  definiert die HTTP-Methode.", 
            "title": "Schnittstellen und Routes"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#controller", 
            "text": "Wenn an einem Endpunkt eine HTTP-Anfrage ankommt, so wird der in den Routes definierte  Controller  aufgerufen. Wichtig ist hierbei, dass von der Klasse  Controller  oder \neiner Unterklasse wie  ApiController  geerbt wird.  F\u00fcr den Controller notwendige Parameter wie  Mapper  k\u00f6nnen im Konstruktor als Parameter angegeben und so durch  Dependency Injection  erhalten werden. \nNachfolgendes Codebeispiel zeigt den Konstruktor vom  PageController .  ?php\n/**\n * PageController constructor.\n *\n * @param string $AppName The app's name.\n * @param IRequest $request The request.\n * @param ClientMapper $clientMapper The client mapper.\n * @param AuthorizationCodeMapper $authorizationCodeMapper The authorization code mapper.\n * @param AccessTokenMapper $accessTokenMapper The access token mapper.\n * @param RefreshTokenMapper $refreshTokenMapper The refresh token mapper.\n * @param string $UserId The user ID.\n * @param ILogger $logger The logger.\n */\npublic function __construct($AppName, IRequest $request,\n                            ClientMapper $clientMapper,\n                            AuthorizationCodeMapper $authorizationCodeMapper,\n                            AccessTokenMapper $accessTokenMapper,\n                            RefreshTokenMapper $refreshTokenMapper,\n                            $UserId,\n                            ILogger $logger) {\n    parent::__construct($AppName, $request);\n\n    $this- clientMapper = $clientMapper;\n    $this- authorizationCodeMapper = $authorizationCodeMapper;\n    $this- accessTokenMapper = $accessTokenMapper;\n    $this- refreshTokenMapper = $refreshTokenMapper;\n    $this- userId = $UserId;\n    $this- logger = $logger;\n}  Die hier notwendigen Parameter sind der Name der App, die Anfrage (Objekt, das die Schnittstelle  IRequest  implementiert), verschiedene Mapper Instanzen, die ID des Nutzers, \num bei der Autorisierung des Clients speichern zu k\u00f6nnen, welcher Nutzer dies veranlasst hat, und ein Logger (Objekt, das die Schnittstelle  ILogger  implementiert). Letzterer ist notwendig um in die Log-Datei von ownCloud zu schreiben.  Die mit den Routes verkn\u00fcpften Funktionen k\u00f6nnen zur Zugriffskontrolle mit  PHPDoc Annotationen  versehen werden. Folgendes Codebeispiel zeigt die Annotationen f\u00fcr die Funktion  generateToken  im  OAuthApiController .  ?php\n/**\n * Implements the OAuth 2.0 Access Token Response.\n *\n * @param string $grant_type The authorization grant type.\n * @param string $code The authorization code.\n * @param string $redirect_uri The redirect URI.\n * @param string $refresh_token The refresh token.\n * @return JSONResponse The Access Token or an empty JSON Object.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n * @PublicPage\n * @CORS\n */\npublic function generateToken($grant_type, $code = null,\n                              $redirect_uri = null, $refresh_token = null) { }  Die Annotationen haben dabei folgende Bedeutungen.     Annotation  Bedeutung      @NoAdminRequired  Aufruf auch von normalen Nutzern m\u00f6glich.    @NoCSRFRequired  Zeigt an, dass die \u00dcberpr\u00fcfung des CSRF Tokens nicht gewollt ist.    @PublicPage  Zugriff auch ohne Login m\u00f6glich.    @CORS  Aufruf der API durch andere Web Applikationen von au\u00dfen m\u00f6glich.     In den Controller-Funktionen k\u00f6nnen verschiedene Inhalte zur\u00fcckgegeben werden. Hier genutzte R\u00fcckgabetypen sind in der folgenden Tabelle zusammengefasst.     Typ  Beschreibung      TemplateResponse  Zur R\u00fcckgabe eines Templates, das dem Nutzer angezeigt werden soll.    RedirectResponse  Zur Weiterleitung des Nutzers an eine andere URL.    JSONResponse  Zur R\u00fcckgabe eines JSON Strings.     Ein Beispiel f\u00fcr den R\u00fcckgabetyp  TemplateResponse  und gibt die Funktion  authorize  im  PageController , die im folgenden Codebeispiel zu sehen ist.  ?php\n/**\n * Shows a view for the user to authorize a client.\n *\n * @param string $response_type The expected response type.\n * @param string $client_id The client identifier.\n * @param string $redirect_uri The redirection URI.\n * @param string $state The state.\n *\n * @return TemplateResponse|RedirectResponse The authorize view or a\n * redirection to the ownCloud main page.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n */\npublic function authorize($response_type, $client_id, $redirect_uri,\n                          $state = null) {\n    if (!is_string($response_type) || !is_string($client_id)\n        || !is_string($redirect_uri) || (isset($state)   !is_string($state))\n    ) {\n        return new TemplateResponse(\n            $this- appName,\n            'authorize-error',\n            ['client_name' =  null, 'back_url' =  OC_Util::getDefaultPageUrl()]\n        );\n    }\n\n    try {\n        /** @var Client $client */\n        $client = $this- clientMapper- findByIdentifier($client_id);\n    } catch (DoesNotExistException $exception) {\n        return new TemplateResponse(\n            $this- appName,\n            'authorize-error',\n            ['client_name' =  null, 'back_url' =  OC_Util::getDefaultPageUrl()]\n        );\n    }\n\n    if (!Utilities::validateRedirectUri(\n            $client- getRedirectUri(),\n            urldecode($redirect_uri),\n            $client- getAllowSubdomains())\n    ) {\n        return new TemplateResponse(\n            $this- appName,\n            'authorize-error',\n            ['client_name' =  $client- getName(), 'back_url' =  OC_Util::getDefaultPageUrl()]\n        );\n    }\n\n    if (strcmp($response_type, 'code') !== 0) {\n        return new TemplateResponse(\n            $this- appName,\n            'authorize-error',\n            ['client_name' =  $client- getName(), 'back_url' =  OC_Util::getDefaultPageUrl()]\n        );\n    }\n\n    return new TemplateResponse($this- appName, 'authorize', ['client_name' =  $client- getName()]);\n}  Hier werden zun\u00e4chst die Parameter auf G\u00fcltigkeit \u00fcberpr\u00fcft. Sollten die Parameter nicht g\u00fcltig sein (beispielsweise deshalb, weil der angegebene Client nicht existiert oder dessen Redirection URI falsch angegeben wurde), wird mit einem  TemplateResponse  das Template  authorize-error  zur\u00fcckgegeben. Andernfalls kommt das Template  authorize  zum Einsatz. F\u00fcr das Rendern des Templates k\u00f6nnen Parameter \u00fcbergeben werden. Hier wurden die Parameter  client_name  f\u00fcr den Namen des Clients und  back_url  f\u00fcr die URL des Zur\u00fcck-Buttons verwendet.  Der R\u00fcckgabetyp  RedirectResponse  wird f\u00fcr die Ausstellung eines Authorization Codes in der Funktion  generateAuthorizationCode  im  PageController  genutzt. Folgendes Codebeispiel macht dies deutlich. Zudem wird der Einsatz von Entities und Mappern gezeigt.  ?php\n/**\n * Implements the OAuth 2.0 Authorization Response.\n *\n * @param string $response_type The expected response type.\n * @param string $client_id The client identifier.\n * @param string $redirect_uri The redirection URI.\n * @param string $state The state.\n *\n * @return RedirectResponse|JSONResponse Redirection to the given\n * redirect_uri or a JSON with an error message.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n */\npublic function generateAuthorizationCode($response_type, $client_id, $redirect_uri, $state = null) {\n    if (!is_string($response_type) || !is_string($client_id)\n        || !is_string($redirect_uri) || (isset($state)   !is_string($state))\n    ) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    switch ($response_type) {\n        case 'code':\n            try {\n                /** @var Client $client */\n                $client = $this- clientMapper- findByIdentifier($client_id);\n            } catch (DoesNotExistException $exception) {\n                return new RedirectResponse(OC_Util::getDefaultPageUrl());\n            }\n\n            if (!Utilities::validateRedirectUri(\n                    $client- getRedirectUri(),\n                    urldecode($redirect_uri),\n                    $client- getAllowSubdomains())\n            ) {\n                return new RedirectResponse(OC_Util::getDefaultPageUrl());\n            }\n\n            $this- authorizationCodeMapper- deleteByClientUser($client- getId(), $this- userId);\n            $this- accessTokenMapper- deleteByClientUser($client- getId(), $this- userId);\n            $this- refreshTokenMapper- deleteByClientUser($client- getId(), $this- userId);\n\n            $code = Utilities::generateRandom();\n            $authorizationCode = new AuthorizationCode();\n            $authorizationCode- setCode($code);\n            $authorizationCode- setClientId($client- getId());\n            $authorizationCode- setUserId($this- userId);\n            $authorizationCode- resetExpires();\n            $this- authorizationCodeMapper- insert($authorizationCode);\n\n            $result = urldecode($redirect_uri);\n            $result = $result . '?code=' . $code;\n            if (!is_null($state)) {\n                $result = $result . ' state=' . urlencode($state);\n            }\n\n            $this- logger- info(\n                'An authorization code has been issued for the client  ' . $client- getName() .' .',\n                ['app' =  $this- appName]\n            );\n\n            return new RedirectResponse($result);\n        default:\n            return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n}  In dieser Funktion werden die Parameter \u00fcberpr\u00fcft. Falls diese nicht g\u00fcltig sind (beispielsweise deshalb, \nweil der angegebene Client nicht existiert oder dessen Redirection URI falsch angegeben wurde), wird an die ownCloud Startseite weitergeleitet. \nAnsonsten wird ein Authorization Code ausgestellt und als Parameter der Redirection URI angeh\u00e4ngt, zu welcher schlie\u00dflich weitergeleitet wird.  Der R\u00fcckgabetyp  JSONResponse  wird f\u00fcr die R\u00fcckgabe des Access Tokens in der Funktion  generateToken  im  OAuthApiController  genutzt, wie nachfolgendes Codebeispiel zeigt. Zudem ist erneut das Zusammenspiel mit Entities und Mappern zu sehen.  ?php\n/**\n * Implements the OAuth 2.0 Access Token Response.\n *\n * @param string $grant_type The authorization grant type.\n * @param string $code The authorization code.\n * @param string $redirect_uri The redirect URI.\n * @param string $refresh_token The refresh token.\n * @return JSONResponse The Access Token or an empty JSON Object.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n * @PublicPage\n * @CORS\n */\npublic function generateToken($grant_type, $code = null,\n                              $redirect_uri = null, $refresh_token = null) {\n    if (!is_string($grant_type)) {\n        return new JSONResponse(['error' =  'invalid_request'], Http::STATUS_BAD_REQUEST);\n    }\n\n    if (is_null($_SERVER['PHP_AUTH_USER']) || is_null($_SERVER['PHP_AUTH_PW'])) {\n        return new JSONResponse(['error' =  'invalid_request'], Http::STATUS_BAD_REQUEST);\n    }\n\n    try {\n        /** @var Client $client */\n        $client = $this- clientMapper- findByIdentifier($_SERVER['PHP_AUTH_USER']);\n    } catch (DoesNotExistException $exception) {\n        return new JSONResponse(['error' =  'invalid_client'], Http::STATUS_BAD_REQUEST);\n    }\n\n    if (strcmp($client- getSecret(), $_SERVER['PHP_AUTH_PW']) !== 0) {\n        return new JSONResponse(['error' =  'invalid_client'], Http::STATUS_BAD_REQUEST);\n    }\n\n    switch ($grant_type) {\n        case 'authorization_code':\n            if (!is_string($code) || !is_string($redirect_uri)) {\n                return new JSONResponse(['error' =  'invalid_request'], Http::STATUS_BAD_REQUEST);\n            }\n\n            try {\n                /** @var AuthorizationCode $authorizationCode */\n                $authorizationCode = $this- authorizationCodeMapper- findByCode($code);\n            } catch (DoesNotExistException $exception) {\n                return new JSONResponse(['error' =  'invalid_grant'], Http::STATUS_BAD_REQUEST);\n            }\n\n            if (strcmp($authorizationCode- getClientId(), $client- getId()) !== 0) {\n                return new JSONResponse(['error' =  'invalid_grant'], Http::STATUS_BAD_REQUEST);\n            }\n\n            if ($authorizationCode- hasExpired()) {\n                return new JSONResponse(['error' =  'invalid_grant'], Http::STATUS_BAD_REQUEST);\n            }\n\n            if (!Utilities::validateRedirectUri(\n                    $client- getRedirectUri(),\n                    urldecode($redirect_uri),\n                    $client- getAllowSubdomains())\n            ) {\n                return new JSONResponse(['error' =  'invalid_grant'], Http::STATUS_BAD_REQUEST);\n            }\n\n            $this- logger- info(\n                'An authorization code has been used by the client  '\n                    . $client- getName() . '  to request an access token.',\n                ['app' =  $this- appName]\n            );\n\n            $userId = $authorizationCode- getUserId();\n            break;\n        case 'refresh_token':\n            if (!is_string($refresh_token)) {\n                return new JSONResponse(['error' =  'invalid_request'], Http::STATUS_BAD_REQUEST);\n            }\n\n            try {\n                /** @var RefreshToken $refreshToken */\n                $refreshToken = $this- refreshTokenMapper- findByToken($refresh_token);\n            } catch (DoesNotExistException $exception) {\n                return new JSONResponse(['error' =  'invalid_grant'], Http::STATUS_BAD_REQUEST);\n            }\n\n            if (strcmp($refreshToken- getClientId(), $client- getId()) !== 0) {\n                return new JSONResponse(['error' =  'invalid_grant'], Http::STATUS_BAD_REQUEST);\n            }\n\n            $this- logger- info(\n                'A refresh token has been used by the client  '\n                    . $client- getName() . '  to request an access token.',\n                ['app' =  $this- appName]\n            );\n\n            $userId = $refreshToken- getUserId();\n            break;\n        default:\n            return new JSONResponse(['error' =  'invalid_grant'], Http::STATUS_BAD_REQUEST);\n    }\n\n    $this- authorizationCodeMapper- deleteByClientUser($client- getId(), $userId);\n    $this- accessTokenMapper- deleteByClientUser($client- getId(), $userId);\n    $this- refreshTokenMapper- deleteByClientUser($client- getId(), $userId);\n\n    $token = Utilities::generateRandom();\n    $accessToken = new AccessToken();\n    $accessToken- setToken($token);\n    $accessToken- setClientId($client- getId());\n    $accessToken- setUserId($userId);\n    $accessToken- resetExpires();\n    $this- accessTokenMapper- insert($accessToken);\n\n    $token = Utilities::generateRandom();\n    $refreshToken = new RefreshToken();\n    $refreshToken- setToken($token);\n    $refreshToken- setClientId($client- getId());\n    $refreshToken- setUserId($userId);\n    $this- refreshTokenMapper- insert($refreshToken);\n\n    return new JSONResponse(\n        [\n            'access_token' =  $accessToken- getToken(),\n            'token_type' =  'Bearer',\n            'expires_in' =  3600,\n            'refresh_token' =  $refreshToken- getToken(),\n            'user_id' =  $userId\n        ]\n    );\n}  Hier werden zun\u00e4chst die Parameter auf G\u00fcltigkeit \u00fcberpr\u00fcft. Dabei gibt es die zwei F\u00e4lle  authorization_code  und  refresh_token , \ndie durch die  switch -Anweisung abgedeckt werden. Bei fehlerhaften Angaben wird eine entsprechende Fehlermeldung im JSON-Format zur\u00fcckgegeben. \nAndernfalls wird eine neuer Access Token erstellt und in der Datenbank gespeichert. Der verwendete Authorization Code bzw. der Refresh Token wird zudem gel\u00f6scht. \nIm JSON Response wird dann der Access Token, der Token Typ ( Bearer  wegen des Authorization Code Flow), die Lebensdauer, der Refresh Token und die ID des Nutzers zur\u00fcckgegeben. Nachfolgend ist ein Beispiel dazu angegeben.  {\n     access_token  :  1vtnuo1NkIsbndAjVnhl7y0wJha59JyaAiFIVQDvcBY2uvKmj5EPBEhss0pauzdQ ,\n     token_type  :  Bearer ,\n     expires_in  : 3600,\n     refresh_token  :  7y0wJuvKmj5E1vjVnhlPBEhha59JyaAiFIVQDvcBY2ss0pauzdQtnuo1NkIsbndA ,\n     user_id  :  admin \n}  F\u00fcr die Token-Generierung wurde die Hilfsklasse  Utilities  mit der statischen Funktion  generateRandom  geschrieben, die mithilfe einer ownCloud-internen Funktion 64-stellige zuf\u00e4llige Zeichenketten erzeugt. Folgendes Codebeispiel zeigt diese Funktion.  ?php\n/**\n * Generates a random string with 64 characters.\n *\n * @return string The random string.\n */\npublic static function generateRandom() {\n    return \\OC::$server- getSecureRandom()- generate(64,\n        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789');\n}  Zusammenfassend werden im folgenden UML-Klassendiagramm die Controller mit ihren Beziehungen, die Entities und die Mapper, sowie die Klasse  Utilities  dargestellt.", 
            "title": "Controller"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#templates", 
            "text": "In den  Templates  einer ownCloud App wird die f\u00fcr den Nutzer sichtbare Oberfl\u00e4che definiert. Es k\u00f6nnen die vom  Controller  \u00fcbergebenen Parameter genutzt werden. Dazu gibt es ein Array mit dem Namen  $_ . Zur Vermeidung von Cross-Site-Scripting existiert zudem die ownCloud-interne Funktion  p() , mithilfe derer Werte ausgegeben werden k\u00f6nnen.  Folgende Templates wurden in der App definiert:   authorize : Zur Darstellung des Authorization Requests, bei dem der Nutzer um Autorisierung eines Clients gebeten wird. Es werden ein Text zur Erkl\u00e4rung sowie Buttons zum Akzeptieren oder Ablehnen angezeigt.  authorize-error : Zur Information des Nutzers mit einer Fehlermeldung, falls der Authorization Request wegen fehlerhafter Parameter ung\u00fcltig ist.  settings-admin : Stellt zur Verwaltung der Clients eine tabellarische Auflistung der Clients sowie ein Formular zum Hinzuf\u00fcgen von Clients dar.  settings-personal : Stellt eine tabellarische Auflistung der vom Nutzer autorisierten Clients dar, mit der M\u00f6glichkeit, die Autorisierung zu widerrufen.   Folgendes Codebeispiel zeigt das Template  settings-admin .  ?php\n/** @var \\OCA\\OAuth2\\Db\\Client $client */\nscript('oauth2', 'settings');\nstyle('oauth2', 'main');\nstyle('oauth2', 'settings-admin');\n?  div class= section  id= oauth2 \n     h2 ?php p($l- t('OAuth 2.0')); ? /h2 \n\n     h3 ?php p($l- t('Registered clients')); ? /h3 \n     ?php if (empty($_['clients'])) {\n        p($l- t('No clients registered.'));\n    }\n    else { ? \n     table class= grid \n         thead \n         tr \n             th id= headerName  scope= col ?php p($l- t('Name')); ? /th \n             th id= headerRedirectUri  scope= col ?php p($l- t('Redirection URI')); ? /th \n             th id= headerClientIdentifier  scope= col ?php p($l- t('Client Identifier')); ? /th \n             th id= headerSecret  scope= col ?php p($l- t('Secret')); ? /th \n             th id= headerSubdomains  scope= col ?php p($l- t('Subdomains allowed')); ? /th \n             th id= headerRemove nbsp; /th \n         /tr \n         /thead \n         tbody \n             ?php foreach ($_['clients'] as $client) { ? \n                 tr \n                     td ?php p($client- getName()); ? /td \n                     td ?php p($client- getRedirectUri()); ? /td \n                     td code ?php p($client- getIdentifier()); ? /code /td \n                     td code ?php p($client- getSecret()); ? /code /td \n                         td id= td-allow-subdomains \n                             ?php if ($client- getAllowSubdomains()) {? \n                                 img alt=  src= /core/img/actions/checkmark.svg \n                             ?php } ? \n                         /td \n                     td \n                         form id= form-inline  class= delete \n                            data-confirm= ?php\n                                p($l- t('Are you sure you want to delete this item?'));\n                            ? \n                            action= ../apps/oauth2/clients/ ?php p($client- getId()); ? /delete \n                            method= post \n                             input type= submit  class= button icon-delete  value= \n                         /form \n                     /td \n                 /tr \n             ?php } ? \n         /tbody \n     /table \n     ?php } ? \n\n     h3 ?php p($l- t('Add client')); ? /h3 \n     form action= ../apps/oauth2/clients  method= post \n         input id= name  name= name  type= text  placeholder= ?php p($l- t('Name')); ? \n         input id= redirect_uri  name= redirect_uri  type= url \n            placeholder= ?php p($l- t('Redirection URI')); ? \n         input type= checkbox  class= checkbox  name= allow_subdomains \n            id= allow_subdomains  value= 1 / \n         label for= allow_subdomains ?php p($l- t('Allow subdomains'));? /label \n         input type= submit  class= button  value= ?php p($l- t('Add')); ? \n     /form  /div   In diesem Template wird eine Tabelle mit den registrierten Clients angezeigt. Zu Beginn werden mit den Funktionen  script  und  style  zus\u00e4tzliche JavaScript- bzw. CSS-Dateien aus den Verzeichnissen  js  bzw.  css  geladen. Durch eine  for -Schleife wird dann f\u00fcr jeden Client aus dem Parameter  clients  ein Tabelleneintrag angezeigt. Sollten noch keine Clients registriert worden sein, sorgt die  if -Anweisung daf\u00fcr, dass die Meldung \u201eNo clients registered\u201c angezeigt wird. Durch Nutzung der Funktion  t  der globalen Variable  $l  k\u00f6nnen die Strings auch  in andere Sprachen \u00dcbersetzt werden . Im Zuge des Transfers der App in die ownCloud GitHub-Organisation wurde Transifex als \u00dcbersetzungsplattform integriert. Dies bedeutet, dass nun im  l1on -Verzeichnis der OAuth 2.0 App \u00dcbersetzungen der originalen (von uns erstellten) englischen Strings aus den Templates von der Transifex-Community hinzugef\u00fcgt und ge\u00e4ndert werden k\u00f6nnen. Dadurch liegen bereits zum aktuellen Zeitpunkt \u00fcber 15 \u00dcbersetzungen der App vor. Diese werden je nach Spracheinstellung der ownCloud-Instanz angezeigt. Des Weiteren gibt es unter der Tabelle ein Formular f\u00fcr das Hinzuf\u00fcgen von Clients. Die in dem Formular angegebene Aktion l\u00f6st die Funktion  addClient  im  SettingsController  aus. Analog dazu gibt es f\u00fcr jeden Tabelleneintrag ein Formular zum L\u00f6schen des Eintrags, das die Funktion  deleteClient  im  SettingsController  ausl\u00f6st.", 
            "title": "Templates"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#hooks", 
            "text": "Bei der Implementierung der App mussten wir bedenken, dass Nutzer aus ownCloud auch gel\u00f6scht werden k\u00f6nnen. Deshalb musste sichergestellt werden, dass beim L\u00f6schen eines Nutzers auch alle mit ihm verkn\u00fcpften Authorization Codes, Access Tokens und Refresh Tokens gel\u00f6scht werden.  Hierf\u00fcr gibt es in ownCloud das Konzept der  Hooks , welche bei bestimmten Ereignissen ausgel\u00f6st werden. Eigene Hooks werden in der  app.php  registriert.  Da wir vor dem L\u00f6schen eines Nutzers eine Datenbankbereinigung durchf\u00fchren m\u00fcssen, war der  preDelete -Hook von Interesse. Dazu wurde die Klasse  UserHooks  implementiert. Folgendes Codebeispiel zeigt dessen Funktion  register , in der die vor dem L\u00f6schen durchzuf\u00fchrenden Aktionen definiert werden.  /**\n * Registers a pre-delete hook for users to delete authorization codes,\n * access tokens and refresh tokens that reference the user.\n */\npublic function register() {\n    /**\n     * @param User $user .\n     */\n    $callback = function ($user) {\n        if (!is_null($user- getUID())) {\n            $this- logger- info(\n                'Deleting authorization codes, access tokens and refresh tokens referencing the user to be deleted  ' . $user- getUID() . ' .',\n                ['app' =  $this- appName]);\n\n            $this- authorizationCodeMapper- deleteByUser($user- getUID());\n            $this- accessTokenMapper- deleteByUser($user- getUID());\n            $this- refreshTokenMapper- deleteByUser($user- getUID());\n        }\n    };\n\n    $this- userManager- listen('\\OC\\User', 'preDelete', $callback);\n}  Hier wird mithilfe des ownCloud-internen  UserManager s ein Callback f\u00fcr den  preDelete -Hook registriert. In dem Callback werden nach Erstellung eines Log-Eintrags mithilfe der Mapper alle Datenbank-Eintr\u00e4ge zu dem Nutzer gel\u00f6scht. Dazu wurde die Funktion  deleteByUser  im  AuthorizationCodeMapper ,  AccessTokenMapper  und  RefreshTokenMapper  implementiert.", 
            "title": "Hooks"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#background-job", 
            "text": "Da Authorization Codes und Access Tokens eine begrenzte Lebensdauer haben, entstehen mit der Zeit ungenutzte Eintr\u00e4ge in der Datenbank. Zur Bereinigung wurde ein  Background Job  erstellt, der regelm\u00e4\u00dfig ausgef\u00fchrt wird. Die Registrierung erfolgt dabei auch in der  app.php . Folgendes Codebeispiel zeigt die Implementierung der Klasse  CleanUp , in der der auszuf\u00fchrende Code definiert wird.  ?php\nnamespace OCA\\OAuth2\\BackgroundJob;\n\nuse OCA\\OAuth2\\AppInfo\\Application;\n\nclass CleanUp {\n\n    /**\n     * Cleans up expired authorization codes and access tokens.\n     */\n    public static function run() {\n        $app = new Application();\n        $container = $app- getContainer();\n\n        $container- query('OCA\\OAuth2\\Db\\AuthorizationCodeMapper')- cleanUp();\n        $container- query('OCA\\OAuth2\\Db\\AccessTokenMapper')- cleanUp();\n    }\n\n}  Bei Ausf\u00fchrung des Background Jobs wird die  run  Methode aufgerufen. Hier werden \u00fcber den  Container  der App der  AuthorizationCodeMapper  und  AccessTokenMapper  abgefragt, sowie deren  cleanUp  Funktion aufgerufen. In dieser Funktion werden alle Eintr\u00e4ge, die vor einer Woche abgelaufen sind, aus der Datenbank gel\u00f6scht.", 
            "title": "Background Job"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#logging", 
            "text": "Zur Information des Administrators wird bei folgenden Ereignissen in die Log-Datei geschrieben:   Hinzuf\u00fcgen bzw. L\u00f6schen von Clients.  Ausstellung von Authorization Codes.  Einl\u00f6sung von Authorization Codes bzw. Refresh Tokens.  Bereinigung der Datenbank von abgelaufenen Authorization Codes bzw. Access Tokens.   Als Log-Level wurde  info  gew\u00e4hlt.", 
            "title": "Logging"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#authentifizierungslogik", 
            "text": "Nach der Implementierung des OAuth 2.0 Protokolls musste die Authentifizierung von WebDAV und von ownCloud APIs (f\u00fcr die Nutzung der OCS Share API) Erweitert werden. Diese Erweiterung basiert auf den durchgef\u00fchrten  Core Anpassungen .  Zun\u00e4chst sahen wir uns die Umsetzung der bestehenden Basic Authentication in der  dav  App an. Dabei stellten wir fest, dass sabre den  Austausch des Authentifizierungsmechanismus  durch Implementierung eines Interfaces bietet. F\u00fcr unser Szenario war das Interface  AbstractBearer  relevant, da die Access Tokens aus dem Authorization Code Flow des OAuth 2.0 Protokolls f\u00fcr Bearer Authentication genutzt werden. Dazu haben wir die Funktion  validateBearerToken  in der Klasse  OAuth2  implementieren. Die Logik und das Session-Management lehnen sich stark an die bestehende Implementierung der Basic Authentication an. F\u00fcr die Authentifizierung einer Anfrage wird hier jedoch auf  AuthModule s zur\u00fcckgegriffen.  Ein  AuthModule  kann von ownCloud Apps implementiert und registriert werden. Es wird auch bei der Authentifizierung von API Zugriffen eingesetzt. Eine App muss dazu die Funktionen  auth  und  getUserPassword  implementieren. Erstere authentifiziert eine Anfrage, w\u00e4hrend letztere das Passwort des Nutzers zu einer Anfrage ermittelt. Da die App  encryption  in bestimmten Nutzungsszenarien auf das Passwort des Nutzers angewiesen ist, existiert die Funktion  getUserPassword . Sie gibt jedoch in unserer Implementierung eine leere Zeichenkette zur\u00fcck, da wir an keiner Stelle mit Passw\u00f6rtern umgehen (siehe  Einschr\u00e4nkungen ).  getUserPassword  gibt bei erfolgreicher Authentifizierung ein  User -Objekt zur\u00fcck, wie in folgendem Codebeispiel zu sehen ist.  ?php\n/**\n * Authenticates a request.\n *\n * @param IRequest $request The request.\n *\n * @return null|IUser The user if the request is authenticated, null otherwise.\n */\npublic function auth(IRequest $request) {\n    $authHeader = $request- getHeader('Authorization');\n    if (strpos($authHeader, 'Bearer ') === false) {\n        return null;\n    } else {\n        $bearerToken = substr($authHeader, 7);\n    }\n    $app = new Application();\n    $container = $app- getContainer();\n    /** @var AccessTokenMapper $accessTokenMapper */\n    $accessTokenMapper = $container- query('OCA\\OAuth2\\Db\\AccessTokenMapper');\n    try {\n        /** @var AccessToken $accessToken */\n        $accessToken = $accessTokenMapper- findByToken($bearerToken);\n        if ($accessToken- hasExpired()) {\n            return null;\n        }\n    } catch (DoesNotExistException $exception) {\n        return null;\n    }\n    /** @var IUserManager $userManager */\n    $userManager = $container- query('UserManager');\n    $user = $userManager- get($accessToken- getUserId());\n    return $user;\n}  Nach Extraktion des Bearer Tokens aus den Authorization Header, wird durch R\u00fcckgriff auf den  AccessTokenMapper  die  user_id  ermittelt. Mithilfe des ownCloud-internen  UserManager s kann daraufhin das  User -Objekt abgefragt werden.  Zur Registrierung eines  AuthModules  muss dessen Namespace in der  info.xml  angegeben werden, wie im folgenden Codebeispiel gezeigt wird:  auth-modules \n   module OCA\\OAuth2\\AuthModule /module  /auth-modules   Damit die OAuth 2.0 Implementierung f\u00fcr die Authentifizierung in der  dav  App genutzt werden kann, musste sie f\u00fcr diese bekannt gemacht werden. Dazu wurde im Konstruktur der Klasse  Application , von der in der  app.php  eine Instanz erzeugt wird, ein Event Listener hinzugef\u00fcgt, der das  authInit -Event des WebDAV-Server abgreift. Folgendes Codebeispiel macht dies deutlich.  ?php\n$dispatcher = $this- getContainer()- getServer()- getEventDispatcher();\n$dispatcher- addListener('OCA\\DAV\\Connector\\Sabre::authInit', function ($event) use ($container) {\n    if ($event instanceof SabrePluginEvent) {\n        $authPlugin = $event- getServer()- getPlugin('auth');\n        if ($authPlugin instanceof Plugin) {\n            $authPlugin- addBackend(\n                new OAuth2(\\OC::$server- getSession(),\n                    \\OC::$server- getUserSession(),\n                    \\OC::$server- getRequest(),\n                    'principals/')\n            );\n        }\n    }\n});  Beim Ausl\u00f6sen des  authInit -Events wird der hier definierte Code ausgef\u00fchrt, der daf\u00fcr sorgt, dass ein zus\u00e4tzliches Backend f\u00fcr die Authentifizierung mittels OAuth 2.0 hinzugef\u00fcgt wird. Da die App damit ein Authentication Backend bereitstellt, war es notwendig, dies in der  info.xml  bei den  Types  bekanntzugeben, wie folgendes Codebeispiel zeigt.  types \n     authentication/  /types", 
            "title": "Authentifizierungslogik"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#tests-und-continuous-integration", 
            "text": "Zum Testen der PHP-Klassen wurde das Framework  PHPUnit  verwendet. Die aktuelle Testabdeckung ist bei Codecov einsehbar:  .  Als Continuous Integration Tool wurde Travis CI verwendet. Bei jeder \u00c4nderung im  GitHub Repository  wird ein Build angesto\u00dfen, in dem die App mithilfe eines Makefiles f\u00fcr den App Store gebaut wird und anschlie\u00dfend in verschiedenen Umgebungen installiert und getestet wird. Folgende Parameter werden variiert:   PHP Versionen : 5.6, 7.0, 7.1, nightly  Datenbanken : PostgreSQL, MySQL, SQLite  Branches des ownCloud Core :  master   Der aktuelle Build-Status ist bei Travis einsehbar:  .", 
            "title": "Tests und Continuous Integration"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#einschrankungen", 
            "text": "Da in der App nicht mit Passw\u00f6rtern des Nutzers umgegangen wird, k\u00f6nnen beim Login eines Nutzers der  preLogin - und der  postLogin -Hook nicht mit dem Passwort des Nutzers ausgel\u00f6st werden. Dies f\u00fchrt dazu, dass die  encryption  App nur mit der Master Key Encryption genutzt werden kann.", 
            "title": "Einschr\u00e4nkungen"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/core-anpassungen/", 
            "text": "Core Anpassungen\n\n\nZweck\n\n\nUm das durch die \noauth2\n App implementierte OAuth 2.0 Protokoll f\u00fcr den Zugriff auf die \nWebDAV Schnittstelle\n und die \nOCS Share API\n nutzen zu k\u00f6nnen, mussten Anpassungen am \nownCloud Core\n durchgef\u00fchrt werden. Diese \u00c4nderungen liegen im Pull Request \nowncloud/core#26742\n vor. Ein Backport f\u00fcr ownCloud 9.1 ist im Pull Request \nowncloud/core#27370\n zu finden.\n\n\nVorgegebene Schnittstelle\n\n\nBevor wir ownCloud um OAuth 2.0 erweitern konnten, mussten wir die vorgegebene Schnittstelle untersuchen. Dazu schauten wir uns die Implementierungen von WebDAV und der OCS Share API an.\n\n\nWebDAV\n\n\nBei der Untersuchung der WebDAV Schnittstelle stellte sich heraus, dass hierf\u00fcr eine ownCloud App namens \ndav\n verwendet wurde, die die \nsabre/dav\n Bibliothek zur Implementierung des WebDAV-Serves nutzt. Da die Bibliothek den Austausch der Authentifizierung \u00fcber eigene Authentication Backends unterst\u00fctzt, entschieden wir uns daf\u00fcr, diesen Mechanismus auch f\u00fcr die Bereitstellung von OAuth 2.0 zu nutzen. Die Implementierung eines solchen Backends wird auf der Seite zur \nOAuth 2.0 App\n beschrieben.\n\n\nownCloud APIs\n\n\nDie Implementierung der OCS Share API wird gr\u00f6\u00dftenteils durch die ownCloud App \nfiles_sharing\n bereitgestellt. Daher mussten \u00c4nderungen auf Ebene von ownCloud Apps und im Speziellen bei der Authentifizierung der von ihnen definierten APIs durchgef\u00fchrt werden. Wir folgten dem Vorschlag eines ownCloud Entwicklers, daf\u00fcr einen Plugin Mechanismus zu implementieren, sodass Apps weitere Authentifizierungsmethoden bereitstellen k\u00f6nnen.\n\n\nImplementierung\n\n\nWebDAV\n\n\nUm eigene Authentication Backends f\u00fcr die \ndav\n App bekannt zu machen und gleichzeitig keine Abh\u00e4ngigkeit zu schaffen, nutzten wir Event Listener. Vor dem Start des WebDAV-Servers in der Datei \nappinfo/v1/webdav.php\n l\u00f6sten wir das \nauthInit\n-Event aus, wie folgendes Codebeispiel zeigt.\n\n\n?php\n$event = new \\OCP\\SabrePluginEvent($server);\n\\OC::$server-\ngetEventDispatcher()-\ndispatch('OCA\\DAV\\Connector\\Sabre::authInit', $event);\n\n\n\n\nDadurch ist es ownCloud Apps m\u00f6glich, das Event abzugreifen und vor dem Start des WebDAV-Servers weitere Authentication Backends hinzuzuf\u00fcgen. Wie dies in der OAuth 2.0 App implementiert wurde, beschreibt \ndessen Seite\n.\n\n\nownCloud APIs\n\n\nDie Authentifizierung von API-Zugriffen in ownCloud geschieht in der Datei \nlib/private/legacy/api.php\n, welche auf \nlib/private/User/Session.php\n zur\u00fcckgreift. Analog zu den bestehenden Funktionen \ntryTokenLogin\n und \ntryBasicAuthLogin\n f\u00fcgten wir die Funktion \ntryAuthModuleLogin\n hinzu. Ein \nAuthModule\n kann dabei von ownCloud Apps bereitgestellt werden, indem eine Implementierung des Interfaces \nIAuthModule\n (zu finden in der Datei \nlib/public/Authentication/IAuthModule.php\n) registriert wird. Nachfolgendes Codebeispiel zeigt dieses Interface.\n\n\n?php\nnamespace OCP\\Authentication;\n\nuse OCP\\IRequest;\nuse OCP\\IUser;\n\n/**\n * Interface IAuthModule\n *\n * @package OCP\\Authentication\n * @since 10.0.0\n */\ninterface IAuthModule {\n\n    /**\n     * Authenticates a request.\n     *\n     * @param IRequest $request The request.\n     *\n     * @return null|IUser The user if the request is authenticated, null otherwise.\n     * @since 10.0.0\n     */\n    public function auth(IRequest $request);\n\n    /**\n     * Returns the user's password.\n     *\n     * @param IRequest $request The request.\n     *\n     * @return String The user's password.\n     * @since 10.0.0\n     */\n    public function getUserPassword(IRequest $request);\n\n}\n\n\n\n\nDie Funktion \nauth\n authentifiziert eine Anfrage und ermittelt (bei erfolgreicher Authentifizierung) den zugeh\u00f6rigen Nutzer. Zus\u00e4tzlich gibt es noch die Funktion \ngetUserPassword\n, welche zu einer Anfrage das Passwort des Nutzers bestimmt. Sie wurde hinzugef\u00fcgt, da die App \nencryption\n in bestimmten Nutzungsszenarien auf das Passwort des Nutzers angewiesen ist.\n\n\nIn der Funktion \ntryAuthModuleLogin\n der Klasse \nSession\n werden nun alle von ownCloud Apps bereitgestellten Implementierungen von \nIAuthModule\n geladen und zur Authentifizierung genutzt, wie im folgenden Codebeispiel zu sehen.\n\n\n?php\n/**\n * Tries to login with an AuthModule provided by an app\n *\n * @param IRequest $request The request\n * @return bool True if request can be authenticated, false otherwise\n * @throws Exception If the auth module could not be loaded\n */\npublic function tryAuthModuleLogin(IRequest $request) {\n    /** @var IAppManager $appManager */\n    $appManager = OC::$server-\nquery('AppManager');\n    $allApps = $appManager-\ngetInstalledApps();\n\n    foreach ($allApps as $appId) {\n        $info = $appManager-\ngetAppInfo($appId);\n\n        if (isset($info['auth-modules'])) {\n            $authModules = $info['auth-modules'];\n\n            foreach ($authModules as $class) {\n                try {\n                    if (!OC_App::isAppLoaded($appId)) {\n                        OC_App::loadApp($appId);\n                    }\n\n                    /** @var IAuthModule $authModule */\n                    $authModule = OC::$server-\nquery($class);\n\n                    if ($authModule instanceof IAuthModule) {\n                        return $this-\nloginUser(\n                            $authModule-\nauth($request),\n                            $authModule-\ngetUserPassword($request)\n                        );\n                    } else {\n                        throw new Exception(\nCould not load the auth module $class\n);\n                    }\n                } catch (QueryException $exc) {\n                    throw new Exception(\nCould not load the auth module $class\n);\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\n\n\n\nHier wird in allen installierten Apps in der \ninfo.xml\n nach dem Tag \nauth-modules\n gesucht. Durch Nutzung von Registrierungen in der \ninfo.xml\n war es m\u00f6glich, Abh\u00e4ngigkeiten zu anderen Apps zu vermeiden. Falls die App ein \nAuthModule\n implementiert und registriert hat, wird die registrierte Klasse geladen und f\u00fcr die Funktion \nloginUser\n genutzt.\n\n\nDie Funktion \nloginUser\n ist analog zu der bestehenden Funktion \nloginWithToken\n implementiert worden und nutzt die R\u00fcckgabewerte der beiden Funktionen aus dem \nAuthModule\n, wie folgendes Codebeispiel zeigt.\n\n\n/**\n * Logs a user in\n *\n * @param IUser $user The user\n * @param String $password The user's password\n * @return boolean True if the user can be authenticated, false otherwise\n * @throws LoginException if an app canceled the login process or the user is not enabled\n */\nprivate function loginUser($user, $password) {\n    if (is_null($user)) {\n        return false;\n    }\n\n    $this-\nmanager-\nemit('\\OC\\User', 'preLogin', [$user, $password]);\n\n    if (!$user-\nisEnabled()) {\n        $message = \\OC::$server-\ngetL10N('lib')-\nt('User disabled');\n        throw new LoginException($message);\n    }\n\n    $this-\nsetUser($user);\n    $this-\nsetLoginName($user-\ngetDisplayName());\n\n    $this-\nmanager-\nemit('\\OC\\User', 'postLogin', [$user, $password]);\n\n    if ($this-\nisLoggedIn()) {\n        $this-\nprepareUserLogin(false);\n    } else {\n        $message = \\OC::$server-\ngetL10N('lib')-\nt('Login canceled by app');\n        throw new LoginException($message);\n    }\n\n    return true;\n}\n\n\n\n\nDie Implementierung und Registrierung eines \nAuthModule\ns in der OAuth 2.0 App wird auf \ndessen Seite\n beschrieben.\n\n\nTests und Continuous Integration\n\n\nDie \u00c4nderungen in den Pull Requests durchliefen die Tests zum ownCloud Core, die bei \nJenkins\n und \nTravis\n ausgef\u00fchrt wurden.", 
            "title": "Core Anpassungen"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/core-anpassungen/#core-anpassungen", 
            "text": "", 
            "title": "Core Anpassungen"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/core-anpassungen/#zweck", 
            "text": "Um das durch die  oauth2  App implementierte OAuth 2.0 Protokoll f\u00fcr den Zugriff auf die  WebDAV Schnittstelle  und die  OCS Share API  nutzen zu k\u00f6nnen, mussten Anpassungen am  ownCloud Core  durchgef\u00fchrt werden. Diese \u00c4nderungen liegen im Pull Request  owncloud/core#26742  vor. Ein Backport f\u00fcr ownCloud 9.1 ist im Pull Request  owncloud/core#27370  zu finden.", 
            "title": "Zweck"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/core-anpassungen/#vorgegebene-schnittstelle", 
            "text": "Bevor wir ownCloud um OAuth 2.0 erweitern konnten, mussten wir die vorgegebene Schnittstelle untersuchen. Dazu schauten wir uns die Implementierungen von WebDAV und der OCS Share API an.", 
            "title": "Vorgegebene Schnittstelle"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/core-anpassungen/#webdav", 
            "text": "Bei der Untersuchung der WebDAV Schnittstelle stellte sich heraus, dass hierf\u00fcr eine ownCloud App namens  dav  verwendet wurde, die die  sabre/dav  Bibliothek zur Implementierung des WebDAV-Serves nutzt. Da die Bibliothek den Austausch der Authentifizierung \u00fcber eigene Authentication Backends unterst\u00fctzt, entschieden wir uns daf\u00fcr, diesen Mechanismus auch f\u00fcr die Bereitstellung von OAuth 2.0 zu nutzen. Die Implementierung eines solchen Backends wird auf der Seite zur  OAuth 2.0 App  beschrieben.", 
            "title": "WebDAV"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/core-anpassungen/#owncloud-apis", 
            "text": "Die Implementierung der OCS Share API wird gr\u00f6\u00dftenteils durch die ownCloud App  files_sharing  bereitgestellt. Daher mussten \u00c4nderungen auf Ebene von ownCloud Apps und im Speziellen bei der Authentifizierung der von ihnen definierten APIs durchgef\u00fchrt werden. Wir folgten dem Vorschlag eines ownCloud Entwicklers, daf\u00fcr einen Plugin Mechanismus zu implementieren, sodass Apps weitere Authentifizierungsmethoden bereitstellen k\u00f6nnen.", 
            "title": "ownCloud APIs"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/core-anpassungen/#implementierung", 
            "text": "", 
            "title": "Implementierung"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/core-anpassungen/#webdav_1", 
            "text": "Um eigene Authentication Backends f\u00fcr die  dav  App bekannt zu machen und gleichzeitig keine Abh\u00e4ngigkeit zu schaffen, nutzten wir Event Listener. Vor dem Start des WebDAV-Servers in der Datei  appinfo/v1/webdav.php  l\u00f6sten wir das  authInit -Event aus, wie folgendes Codebeispiel zeigt.  ?php\n$event = new \\OCP\\SabrePluginEvent($server);\n\\OC::$server- getEventDispatcher()- dispatch('OCA\\DAV\\Connector\\Sabre::authInit', $event);  Dadurch ist es ownCloud Apps m\u00f6glich, das Event abzugreifen und vor dem Start des WebDAV-Servers weitere Authentication Backends hinzuzuf\u00fcgen. Wie dies in der OAuth 2.0 App implementiert wurde, beschreibt  dessen Seite .", 
            "title": "WebDAV"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/core-anpassungen/#owncloud-apis_1", 
            "text": "Die Authentifizierung von API-Zugriffen in ownCloud geschieht in der Datei  lib/private/legacy/api.php , welche auf  lib/private/User/Session.php  zur\u00fcckgreift. Analog zu den bestehenden Funktionen  tryTokenLogin  und  tryBasicAuthLogin  f\u00fcgten wir die Funktion  tryAuthModuleLogin  hinzu. Ein  AuthModule  kann dabei von ownCloud Apps bereitgestellt werden, indem eine Implementierung des Interfaces  IAuthModule  (zu finden in der Datei  lib/public/Authentication/IAuthModule.php ) registriert wird. Nachfolgendes Codebeispiel zeigt dieses Interface.  ?php\nnamespace OCP\\Authentication;\n\nuse OCP\\IRequest;\nuse OCP\\IUser;\n\n/**\n * Interface IAuthModule\n *\n * @package OCP\\Authentication\n * @since 10.0.0\n */\ninterface IAuthModule {\n\n    /**\n     * Authenticates a request.\n     *\n     * @param IRequest $request The request.\n     *\n     * @return null|IUser The user if the request is authenticated, null otherwise.\n     * @since 10.0.0\n     */\n    public function auth(IRequest $request);\n\n    /**\n     * Returns the user's password.\n     *\n     * @param IRequest $request The request.\n     *\n     * @return String The user's password.\n     * @since 10.0.0\n     */\n    public function getUserPassword(IRequest $request);\n\n}  Die Funktion  auth  authentifiziert eine Anfrage und ermittelt (bei erfolgreicher Authentifizierung) den zugeh\u00f6rigen Nutzer. Zus\u00e4tzlich gibt es noch die Funktion  getUserPassword , welche zu einer Anfrage das Passwort des Nutzers bestimmt. Sie wurde hinzugef\u00fcgt, da die App  encryption  in bestimmten Nutzungsszenarien auf das Passwort des Nutzers angewiesen ist.  In der Funktion  tryAuthModuleLogin  der Klasse  Session  werden nun alle von ownCloud Apps bereitgestellten Implementierungen von  IAuthModule  geladen und zur Authentifizierung genutzt, wie im folgenden Codebeispiel zu sehen.  ?php\n/**\n * Tries to login with an AuthModule provided by an app\n *\n * @param IRequest $request The request\n * @return bool True if request can be authenticated, false otherwise\n * @throws Exception If the auth module could not be loaded\n */\npublic function tryAuthModuleLogin(IRequest $request) {\n    /** @var IAppManager $appManager */\n    $appManager = OC::$server- query('AppManager');\n    $allApps = $appManager- getInstalledApps();\n\n    foreach ($allApps as $appId) {\n        $info = $appManager- getAppInfo($appId);\n\n        if (isset($info['auth-modules'])) {\n            $authModules = $info['auth-modules'];\n\n            foreach ($authModules as $class) {\n                try {\n                    if (!OC_App::isAppLoaded($appId)) {\n                        OC_App::loadApp($appId);\n                    }\n\n                    /** @var IAuthModule $authModule */\n                    $authModule = OC::$server- query($class);\n\n                    if ($authModule instanceof IAuthModule) {\n                        return $this- loginUser(\n                            $authModule- auth($request),\n                            $authModule- getUserPassword($request)\n                        );\n                    } else {\n                        throw new Exception( Could not load the auth module $class );\n                    }\n                } catch (QueryException $exc) {\n                    throw new Exception( Could not load the auth module $class );\n                }\n            }\n        }\n    }\n\n    return false;\n}  Hier wird in allen installierten Apps in der  info.xml  nach dem Tag  auth-modules  gesucht. Durch Nutzung von Registrierungen in der  info.xml  war es m\u00f6glich, Abh\u00e4ngigkeiten zu anderen Apps zu vermeiden. Falls die App ein  AuthModule  implementiert und registriert hat, wird die registrierte Klasse geladen und f\u00fcr die Funktion  loginUser  genutzt.  Die Funktion  loginUser  ist analog zu der bestehenden Funktion  loginWithToken  implementiert worden und nutzt die R\u00fcckgabewerte der beiden Funktionen aus dem  AuthModule , wie folgendes Codebeispiel zeigt.  /**\n * Logs a user in\n *\n * @param IUser $user The user\n * @param String $password The user's password\n * @return boolean True if the user can be authenticated, false otherwise\n * @throws LoginException if an app canceled the login process or the user is not enabled\n */\nprivate function loginUser($user, $password) {\n    if (is_null($user)) {\n        return false;\n    }\n\n    $this- manager- emit('\\OC\\User', 'preLogin', [$user, $password]);\n\n    if (!$user- isEnabled()) {\n        $message = \\OC::$server- getL10N('lib')- t('User disabled');\n        throw new LoginException($message);\n    }\n\n    $this- setUser($user);\n    $this- setLoginName($user- getDisplayName());\n\n    $this- manager- emit('\\OC\\User', 'postLogin', [$user, $password]);\n\n    if ($this- isLoggedIn()) {\n        $this- prepareUserLogin(false);\n    } else {\n        $message = \\OC::$server- getL10N('lib')- t('Login canceled by app');\n        throw new LoginException($message);\n    }\n\n    return true;\n}  Die Implementierung und Registrierung eines  AuthModule s in der OAuth 2.0 App wird auf  dessen Seite  beschrieben.", 
            "title": "ownCloud APIs"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/core-anpassungen/#tests-und-continuous-integration", 
            "text": "Die \u00c4nderungen in den Pull Requests durchliefen die Tests zum ownCloud Core, die bei  Jenkins  und  Travis  ausgef\u00fchrt wurden.", 
            "title": "Tests und Continuous Integration"
        }, 
        {
            "location": "/owncloud/benutzung/", 
            "text": "Benutzung\n\n\nInstallation\n\n\nDa die Anpassungen durch den Pull Request \nowncloud/core#26742\n erst k\u00fcrzlich in den ownCloud Core aufgenommen wurden, sind sie noch in keiner Hauptversion enthalten. Erst die \nin K\u00fcrze erscheinende\n Version 10.0 wird die \u00c4nderungen enthalten.\n\n\nUm die OAuth 2.0 in ownCloud schon jetzt nutzen zu k\u00f6nnen, muss daher der aktuelle Stand aus dem \ncore\n Repository\n heruntergeladen werden:\n\n\n$ git clone https://github.com/owncloud/core.git\n\n\n\n\nDanach m\u00fcssen die Abh\u00e4ngigkeiten aufgel\u00f6st werden. Dazu gen\u00fcgt es, im Verzeichnis des Repositorys folgenden Befehl auszuf\u00fchren:\n\n\n$ make\n\n\n\n\nDie restlichen Installationsschritte von ownCloud unterscheiden sich nicht von denen im \nownCloud Handbuch\n.\n\n\nDie \noauth2\n App wird dadurch installiert, dass der Inhalt des \noauth2\n Repositorys\n in das Verzeichnis \napps\n kopiert wird:\n\n\n$ cd apps\n$ git clone https://github.com/owncloud/oauth2.git\n\n\n\n\nDanach l\u00e4sst sie sich wie jede andere ownCloud App in der Administrator-Ansicht aktivieren.\n\n\nClientregistrierung\n\n\nZur Clientregistrierung muss in der Eingabemaske der OAuth2 App in den \nAdminsettings\n dem Client ein Name gegeben werden und eine g\u00fcltige URL als \nredirect URI\n angegeben werden. \nEine \nredirect URI\n bezeichnet eine Adresse, zu der der jeweilige Client nach der erfolgreichen Autorisierung weitergeleitet wird. Setzt man einen Haken im Feld \nErlaube Subdomains\n, so \nk\u00f6nnen auch Subdomains der eingegebenen \nredirect URI\n angesprochen werden. Werden beispielsweise verschiedene Anmeldeverfahren wie \nSSO\n oder \nXSSO\n \u00fcber Subdomains aufgerufen, so funktioniert\ndie Authentifizierung \u00fcber OAuth 2.0 auch bei diesen Anmeldeverfahren und nicht nur mit dem Anmeldeverfahren der \"Hauptdomain\".\nMit Klick auf \nHinzuf\u00fcgen\n wird der Client registriert, erh\u00e4lt eine \nClientID\n und ein \nClientSecret\n zugewiesen und wird nun in der Tabelle mit den entsprechenden Attributen dargestellt.\n\n\nScreenshot zur Darstellung der Eingabemaske zur Clientregistrierung:\n\n\n\n    \n\n\n\n\n\nScreenshot zur Darstellung der Clients:\n\n\n\n\nGr\u00f6\u00dfere Darstellung des Clients:\n\n\n\n    \n\n\n\n\n\n\n[Zu beachten ist der Zeilenumbruch und die moodle-typische `redirect URI`.]\n\n\n\n\nAutorisierung eines Clients\n\n\nNach der Clientregistrierung kann der Client entsprechend verwendet werden. Es k\u00f6nnen also Anwendungen autorisiert werden um Zugriff auf die\nownCloud-Instanz zu erhalten. Dies wird \u00fcber Abfragen geregelt, welche der Endnutzer best\u00e4tigen oder ablehnen muss.\n\n\nScreenshot einer Autorisierungsabfrage\n\n\n    \n\n\n\n\nScreenshot einer fehlerhaften Autorisierungsabfrage\n\n\n    \n\n\n\n\nWiderrufung der Autorisierung\n\n\nZur Widerrufung der Autorisierung muss diese in den Einstellungen per Klick auf den entsprechenden Button widerrufen werden. \nDies ist f\u00fcr den Nutzer in den pers\u00f6nlichen Einstellungen m\u00f6glich, durch Klicken des M\u00fclleimer-Symbols rechts neben dem jeweiligen Eintrag.\nNachdem auf das Symbol geklickt wurde, erscheint auch hier eine Sicherheitsabfrage, in der man die L\u00f6schung best\u00e4tigen muss.\n\n\nScreenshot zur Darstellung der autorisierten Anwendungen:\n\n\n\n    \n\n\n\n\n\nScreenshot zur Sicherheitsabfrage bei L\u00f6schung einer autorisierten Anwendung:\n\n\n\n    \n\n\n\n\n\nL\u00f6schen der Clientregistrierung\n\n\nBei Bedarf kann ein Client beziehungsweise eine Clientregistrierung gel\u00f6scht werden. Dies kann notwendig sein, wenn sich\nbeim Client die \nredirect URI\n ge\u00e4ndert hat, oder man dem Client aus anderen Gr\u00fcnden den Zugriff entziehen m\u00f6chte. Dadurch, dass\nein Client gel\u00f6scht wird, kann dieser nun nicht mehr auf Dateien aus der ownCloud-Instanz zugreifen und die ausgestellten \nauthorization codes\n, \n\naccess tokens\n und \nrefresh tokens\n sind ung\u00fcltig. Bei irrt\u00fcmlicher L\u00f6schung des Clients muss bei erneuter Einpflegung jeder\nNutzer des Clients erneut das Authentifizierungsverfahren durchlaufen, da eine neue \nClientID\n und ein neues \nClientSecret\n generiert werden.\nUm eine Clientregistrierung zu l\u00f6schen muss in den Adminsettings die tabellarische Ansicht der registrierten Clients aufgerufen werden. \nNun kann man bei dem zu l\u00f6schenden Client rechts neben den zugeordneten Attributen auf ein M\u00fclleimer-Symbol klicken, um die entsprechende Clientregistrierung zu l\u00f6schen.\nNachdem auf das Symbol geklickt wurde, erscheint noch eine Sicherheitsabfrage, in der man die L\u00f6schung best\u00e4tigen muss.\n\n\nScreenshot zur Sicherheitsabfrage bei L\u00f6schung des Clients:", 
            "title": "Benutzung"
        }, 
        {
            "location": "/owncloud/benutzung/#benutzung", 
            "text": "", 
            "title": "Benutzung"
        }, 
        {
            "location": "/owncloud/benutzung/#installation", 
            "text": "Da die Anpassungen durch den Pull Request  owncloud/core#26742  erst k\u00fcrzlich in den ownCloud Core aufgenommen wurden, sind sie noch in keiner Hauptversion enthalten. Erst die  in K\u00fcrze erscheinende  Version 10.0 wird die \u00c4nderungen enthalten.  Um die OAuth 2.0 in ownCloud schon jetzt nutzen zu k\u00f6nnen, muss daher der aktuelle Stand aus dem  core  Repository  heruntergeladen werden:  $ git clone https://github.com/owncloud/core.git  Danach m\u00fcssen die Abh\u00e4ngigkeiten aufgel\u00f6st werden. Dazu gen\u00fcgt es, im Verzeichnis des Repositorys folgenden Befehl auszuf\u00fchren:  $ make  Die restlichen Installationsschritte von ownCloud unterscheiden sich nicht von denen im  ownCloud Handbuch .  Die  oauth2  App wird dadurch installiert, dass der Inhalt des  oauth2  Repositorys  in das Verzeichnis  apps  kopiert wird:  $ cd apps\n$ git clone https://github.com/owncloud/oauth2.git  Danach l\u00e4sst sie sich wie jede andere ownCloud App in der Administrator-Ansicht aktivieren.", 
            "title": "Installation"
        }, 
        {
            "location": "/owncloud/benutzung/#clientregistrierung", 
            "text": "Zur Clientregistrierung muss in der Eingabemaske der OAuth2 App in den  Adminsettings  dem Client ein Name gegeben werden und eine g\u00fcltige URL als  redirect URI  angegeben werden. \nEine  redirect URI  bezeichnet eine Adresse, zu der der jeweilige Client nach der erfolgreichen Autorisierung weitergeleitet wird. Setzt man einen Haken im Feld  Erlaube Subdomains , so \nk\u00f6nnen auch Subdomains der eingegebenen  redirect URI  angesprochen werden. Werden beispielsweise verschiedene Anmeldeverfahren wie  SSO  oder  XSSO  \u00fcber Subdomains aufgerufen, so funktioniert\ndie Authentifizierung \u00fcber OAuth 2.0 auch bei diesen Anmeldeverfahren und nicht nur mit dem Anmeldeverfahren der \"Hauptdomain\".\nMit Klick auf  Hinzuf\u00fcgen  wird der Client registriert, erh\u00e4lt eine  ClientID  und ein  ClientSecret  zugewiesen und wird nun in der Tabelle mit den entsprechenden Attributen dargestellt.  Screenshot zur Darstellung der Eingabemaske zur Clientregistrierung:  \n       Screenshot zur Darstellung der Clients:   Gr\u00f6\u00dfere Darstellung des Clients:  \n       \n[Zu beachten ist der Zeilenumbruch und die moodle-typische `redirect URI`.]", 
            "title": "Clientregistrierung"
        }, 
        {
            "location": "/owncloud/benutzung/#autorisierung-eines-clients", 
            "text": "Nach der Clientregistrierung kann der Client entsprechend verwendet werden. Es k\u00f6nnen also Anwendungen autorisiert werden um Zugriff auf die\nownCloud-Instanz zu erhalten. Dies wird \u00fcber Abfragen geregelt, welche der Endnutzer best\u00e4tigen oder ablehnen muss.  Screenshot einer Autorisierungsabfrage \n       Screenshot einer fehlerhaften Autorisierungsabfrage", 
            "title": "Autorisierung eines Clients"
        }, 
        {
            "location": "/owncloud/benutzung/#widerrufung-der-autorisierung", 
            "text": "Zur Widerrufung der Autorisierung muss diese in den Einstellungen per Klick auf den entsprechenden Button widerrufen werden. \nDies ist f\u00fcr den Nutzer in den pers\u00f6nlichen Einstellungen m\u00f6glich, durch Klicken des M\u00fclleimer-Symbols rechts neben dem jeweiligen Eintrag.\nNachdem auf das Symbol geklickt wurde, erscheint auch hier eine Sicherheitsabfrage, in der man die L\u00f6schung best\u00e4tigen muss.  Screenshot zur Darstellung der autorisierten Anwendungen:  \n       Screenshot zur Sicherheitsabfrage bei L\u00f6schung einer autorisierten Anwendung:", 
            "title": "Widerrufung der Autorisierung"
        }, 
        {
            "location": "/owncloud/benutzung/#loschen-der-clientregistrierung", 
            "text": "Bei Bedarf kann ein Client beziehungsweise eine Clientregistrierung gel\u00f6scht werden. Dies kann notwendig sein, wenn sich\nbeim Client die  redirect URI  ge\u00e4ndert hat, oder man dem Client aus anderen Gr\u00fcnden den Zugriff entziehen m\u00f6chte. Dadurch, dass\nein Client gel\u00f6scht wird, kann dieser nun nicht mehr auf Dateien aus der ownCloud-Instanz zugreifen und die ausgestellten  authorization codes ,  access tokens  und  refresh tokens  sind ung\u00fcltig. Bei irrt\u00fcmlicher L\u00f6schung des Clients muss bei erneuter Einpflegung jeder\nNutzer des Clients erneut das Authentifizierungsverfahren durchlaufen, da eine neue  ClientID  und ein neues  ClientSecret  generiert werden.\nUm eine Clientregistrierung zu l\u00f6schen muss in den Adminsettings die tabellarische Ansicht der registrierten Clients aufgerufen werden. \nNun kann man bei dem zu l\u00f6schenden Client rechts neben den zugeordneten Attributen auf ein M\u00fclleimer-Symbol klicken, um die entsprechende Clientregistrierung zu l\u00f6schen.\nNachdem auf das Symbol geklickt wurde, erscheint noch eine Sicherheitsabfrage, in der man die L\u00f6schung best\u00e4tigen muss.  Screenshot zur Sicherheitsabfrage bei L\u00f6schung des Clients:", 
            "title": "L\u00f6schen der Clientregistrierung"
        }, 
        {
            "location": "/moodle/technische-umsetzung/softwarearchitektur/", 
            "text": "Softwarearchitektur\n\n\nZur Umsetzung des Projektziels, musste Moodle um n\u00f6tige Funktionalit\u00e4ten erg\u00e4nzt werden. Im Folgenden kriegen sie eine strukturierte \u00dcbersicht zu den Plugins die in Moodle entwickelt wurden und welche Funktionalit\u00e4ten sie bereit stellen.\n\n\n\u00dcbersicht \u00fcber die Plugin-Struktur\n\n\nMoodle \nPlugins\n dienen dazu um im Core angebotene Funktionalit\u00e4ten dahingehend zu erweitern, dass diese den\nindividuellen Bed\u00fcrfnissen des Nutzers entsprechen. Daher eignete sich die Implementierung solcher Plugins ideal zur Umsetzung der definierten Integrationsszenarien.\nIn Moodle wird ein Plugin einer \nKategorie\n zugeordnet, welche eine bestimmte Art von Funktionalit\u00e4t repr\u00e4sentiert.\nDa unsere Use Cases verschiedene Arten von Funktionalit\u00e4ten ben\u00f6tigen haben wir uns f\u00fcr verschiedene Plugintypen entschieden.\n\n\n\n\n\n\n\n\nPlugintyp\n\n\nBeschreibung\n\n\nZweck f\u00fcr das Projekt\n\n\n\n\n\n\n\n\n\n\nadmin tool\n oauth2owncloud\n\n\nBietet Dienste zur Site-Administration an, d.h. die Einstellungen gelten global und k\u00f6nnen nur vom Administrator der Seite get\u00e4tigt werden\n\n\nVerwaltung der Authentifizierung mittels OAuth 2.0\n\n\n\n\n\n\nrepository\n owncloud\n\n\nStellt die Verbindung zu einer externen Datenquelle her\n\n\nDatenbeschaffung aus Sciebo\n\n\n\n\n\n\nactivity\n collaborativefolders\n\n\nStellt Aktivit\u00e4ten in einem Kurs zur Verf\u00fcgung\n\n\nErstellung von Ordnern f\u00fcr kollaboratives Arbeiten\n\n\n\n\n\n\n\n\nFunktions\u00fcbersicht\n\n\nDie in den verschiedenen Plugins angebotenen Funktionalit\u00e4ten k\u00f6nnen wie folgt zusammengefasst werden:\n\n\n\n\nAdmin Tool\n:\n \noauth2owncloud\n\n\nUmfasst sowohl OAuth 2.0, als auch einen WebDAV Client.\n\n\nSteuert den Protokollablauf von OAuth 2.0 und verwaltet alle dazu n\u00f6tigen Informationen.\n\n\nglobale Speicherung des Secrets, der ClientID und der WebDAV Zugangsdaten\n\n\n\n\n\n\nStellt das Verbindungsst\u00fcck von moodle zu ownCloud zur Verf\u00fcgung\n\n\n\n\n\n\nRepository\n:\n \nownCloud\n\n\nBewerkstelligt die Datenbeschaffung aus ownCloud nach Moodle.\n\n\nErm\u00f6glicht den Upload von Dateien aus einer pers\u00f6nlichen ownCloud Instanz.\n\n\nErm\u00f6glicht die Verlinkung von Dateien aus ownCloud in Moodle.\n\n\n\n\n\n\nActivity Module\n:\n \ncollaborative folders\n\n\nErm\u00f6glicht die Erstellung und Freigabe von Ordern in ownCloud f\u00fcr Kursteilnehmer in Moodle.\n\n\nErm\u00f6glicht das Erzeugen von separaten Ordnern f\u00fcr Gruppen.\n\n\nErm\u00f6glicht den Zugriff des Lehrenden auf diese Ordner sowie das Verbot des Zugriffes.\n\n\n\n\n\n\n\n\nAbh\u00e4ngigkeiten\n\n\nDie aus der Aufteilung der Funktionen in verschiedene Plugins resultierenden Abh\u00e4ngigkeiten werden in folgender Abbildung\ndargestellt:\n\n\n\n\nZu beachten ist, dass eine m\u00f6glichst hohe Flexibilit\u00e4t und Modularit\u00e4t bei dem Entwurf der Softwarearchitektur erzielt\nwerden sollte. Das f\u00fchrt zwar mit sich, dass funktionale Plugins (also das \nrepository\n und das \nactivity\n Plugin) nicht\neigenst\u00e4ndig ohne das \nadmin tool\n existieren k\u00f6nnen, allerdings wird weiteren, in Zukunft entwickelten Plugins ebenfalls\nZugriff auf die OAuth 2.0 Schnittstelle in Sciebo bzw. ownCloud erm\u00f6glicht,\nwodurch sich das Projektergebnis zu einer guten Wiederverwendbarkeit qualifiziert.", 
            "title": "Softwarearchitektur"
        }, 
        {
            "location": "/moodle/technische-umsetzung/softwarearchitektur/#softwarearchitektur", 
            "text": "Zur Umsetzung des Projektziels, musste Moodle um n\u00f6tige Funktionalit\u00e4ten erg\u00e4nzt werden. Im Folgenden kriegen sie eine strukturierte \u00dcbersicht zu den Plugins die in Moodle entwickelt wurden und welche Funktionalit\u00e4ten sie bereit stellen.", 
            "title": "Softwarearchitektur"
        }, 
        {
            "location": "/moodle/technische-umsetzung/softwarearchitektur/#ubersicht-uber-die-plugin-struktur", 
            "text": "Moodle  Plugins  dienen dazu um im Core angebotene Funktionalit\u00e4ten dahingehend zu erweitern, dass diese den\nindividuellen Bed\u00fcrfnissen des Nutzers entsprechen. Daher eignete sich die Implementierung solcher Plugins ideal zur Umsetzung der definierten Integrationsszenarien.\nIn Moodle wird ein Plugin einer  Kategorie  zugeordnet, welche eine bestimmte Art von Funktionalit\u00e4t repr\u00e4sentiert.\nDa unsere Use Cases verschiedene Arten von Funktionalit\u00e4ten ben\u00f6tigen haben wir uns f\u00fcr verschiedene Plugintypen entschieden.     Plugintyp  Beschreibung  Zweck f\u00fcr das Projekt      admin tool  oauth2owncloud  Bietet Dienste zur Site-Administration an, d.h. die Einstellungen gelten global und k\u00f6nnen nur vom Administrator der Seite get\u00e4tigt werden  Verwaltung der Authentifizierung mittels OAuth 2.0    repository  owncloud  Stellt die Verbindung zu einer externen Datenquelle her  Datenbeschaffung aus Sciebo    activity  collaborativefolders  Stellt Aktivit\u00e4ten in einem Kurs zur Verf\u00fcgung  Erstellung von Ordnern f\u00fcr kollaboratives Arbeiten", 
            "title": "\u00dcbersicht \u00fcber die Plugin-Struktur"
        }, 
        {
            "location": "/moodle/technische-umsetzung/softwarearchitektur/#funktionsubersicht", 
            "text": "Die in den verschiedenen Plugins angebotenen Funktionalit\u00e4ten k\u00f6nnen wie folgt zusammengefasst werden:   Admin Tool :   oauth2owncloud  Umfasst sowohl OAuth 2.0, als auch einen WebDAV Client.  Steuert den Protokollablauf von OAuth 2.0 und verwaltet alle dazu n\u00f6tigen Informationen.  globale Speicherung des Secrets, der ClientID und der WebDAV Zugangsdaten    Stellt das Verbindungsst\u00fcck von moodle zu ownCloud zur Verf\u00fcgung    Repository :   ownCloud  Bewerkstelligt die Datenbeschaffung aus ownCloud nach Moodle.  Erm\u00f6glicht den Upload von Dateien aus einer pers\u00f6nlichen ownCloud Instanz.  Erm\u00f6glicht die Verlinkung von Dateien aus ownCloud in Moodle.    Activity Module :   collaborative folders  Erm\u00f6glicht die Erstellung und Freigabe von Ordern in ownCloud f\u00fcr Kursteilnehmer in Moodle.  Erm\u00f6glicht das Erzeugen von separaten Ordnern f\u00fcr Gruppen.  Erm\u00f6glicht den Zugriff des Lehrenden auf diese Ordner sowie das Verbot des Zugriffes.", 
            "title": "Funktions\u00fcbersicht"
        }, 
        {
            "location": "/moodle/technische-umsetzung/softwarearchitektur/#abhangigkeiten", 
            "text": "Die aus der Aufteilung der Funktionen in verschiedene Plugins resultierenden Abh\u00e4ngigkeiten werden in folgender Abbildung\ndargestellt:   Zu beachten ist, dass eine m\u00f6glichst hohe Flexibilit\u00e4t und Modularit\u00e4t bei dem Entwurf der Softwarearchitektur erzielt\nwerden sollte. Das f\u00fchrt zwar mit sich, dass funktionale Plugins (also das  repository  und das  activity  Plugin) nicht\neigenst\u00e4ndig ohne das  admin tool  existieren k\u00f6nnen, allerdings wird weiteren, in Zukunft entwickelten Plugins ebenfalls\nZugriff auf die OAuth 2.0 Schnittstelle in Sciebo bzw. ownCloud erm\u00f6glicht,\nwodurch sich das Projektergebnis zu einer guten Wiederverwendbarkeit qualifiziert.", 
            "title": "Abh\u00e4ngigkeiten"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/", 
            "text": "Admin Tool: \noauth2owncloud\n\n\nZweck\n\n\nWie bereits im Kapitel \nSoftware Architektur\n angeschnitten, ist der Hauptzweck dieses Plugins\ndie Schnittstelle zu ownCloud bereitzustellen. Zu diesem Zweck wird die im Projekt implementierte ownCloud \nApp \noauth2\n mit Hilfe eines OAuth 2.0 Clients angesprochen. Zus\u00e4tzlich werden\nsowohl die WebDAV, als auch die OCS Share Schnittstelle, \u00fcber OAuth 2.0 abgesichert, in diesem Client umfasst.\nZwar ist der Client auf einen OAuth 2.0 Protokollablauf in Zusammenarbeit mit der entsprechenden ownCloud App angepasst,\njedoch k\u00f6nnte er in Zukunft auch als Ausgangspunkt genutzt werden, um \u00e4hnliche Schnittstellen zu erreichen.\n\n\nIm Wesentlichen implementiert dieses Plugin das folgende \nIntegrationsszenario\n:\n\n\n\n\nAls \nNutzer\n m\u00f6chte ich OAuth 2.0 benutzen k\u00f6nnen, um Moodle Zugriff auf ownCloud zu gew\u00e4hren.\n\n\n\n\nJedoch betrifft es auch alle anderen Szenarien indirekt, da diese erst durch die Authentifizierung mittels OAuth 2.0\nerm\u00f6glicht werden k\u00f6nnen.\n\n\nVorgegebene Schnittstelle\n\n\nF\u00fcr Admin Tools ist in Moodle lediglich eine schwach definierte Schnittstelle gegeben. Wie in jedem anderen Moodle Plugin \nauch, m\u00fcssen zun\u00e4chst einige Standarddateien implementiert werden: \n\n\n\n\nversion.php\n:\n Beschreibt die Versionsnummer des Plugins, die ben\u00f6tigte Moodle Version und Abh\u00e4ngigkeiten des Plugins.\n\n\naccess.php\n:\n Legt die Berechtigungen f\u00fcr definierte Aktionen innerhalb des Plugins anhand von Nutzerrollen fest.\n\n\ntool_oauth2sciebo.php\n:\n Beinhaltet Sprachstrings f\u00fcr unterschiedliche Regionen und Sprachen, sodass definierte Strings,\nabh\u00e4ngig von der jeweiligen Sprache, dynamisch angezeigt werden k\u00f6nnen.\n\n\n\n\nZus\u00e4tzlich zu den allgemeinen Plugindateien, sollte das Admin Tool auch mindestens noch eine Datei namens \nsettings.php\n\nbeinhalten. Diese umfasst alle Einstellungen, die f\u00fcr das Admin Tool geltend dem Administrator der Moodle Instanz zur \nVerf\u00fcgung gestellt werden sollen. Nach der Eingabe, wird diese Konfiguration Moodle-intern gespeichert und kann von dem\nClient, wenn n\u00f6tig abgerufen werden.\n\n\nInsgesamt ergibt sich folgende Struktur von Ordnern und Dateien, die mindestens f\u00fcr die Implementierung des ben\u00f6tigten\nAdmin Tools notwendig ist:\n\n\nclasses                             # Enth\u00e4lt alle implementierten Klassen\ndb  \n  \u2514\u2500\u2500 access.php                    # Enth\u00e4lt alle definierten Capabilities\nlang\n  \u2514\u2500\u2500 en\n      \u2514\u2500\u2500 tool_oauth2sciebo.php     # Enth\u00e4lt Sprach-Strings (englisch)                                         \npix                                 # Bilder und Icons\ntests                               # Test-Dateien und Generatoren\nsettings.php                        # Einstellungs-Seite                \nversion.php                         \n\n\n\n\nImplementierung\n\n\nIm Folgenden wird zun\u00e4chst ausgef\u00fchrt, wie die vorgegebenen Schnitstellen implementiert worden sind.\n\n\nEingabemaske\n\n\nUm die OAuth 2.0 und WebDAV Clients erfolgreich zum Zugriff auf eine entsprechende ownCloud Instanz zu bef\u00e4higen,\nm\u00fcssen diese zun\u00e4chst mit Hilfe ben\u00f6tigter Eingabedaten konfiguriert werden. Diese sollen zentral im Admin Tool eingegeben und\ngespeichert werden k\u00f6nnen, um sie anschlie\u00dfend von dem Client aus, und damit auch in den ihn verwendenden Plugins, nutzen zu k\u00f6nnen.\n\n\nBen\u00f6tigte Eingaben\n\n\nUm den OAuth 2.0 Protokollablauf zu erm\u00f6glichen, m\u00fcssen folgende Daten im Vorfeld erfasst werden:\n\n\n\n\nClient ID\n:\n wird in ownCloud generiert und dient der Identifizierung eines regstrierten Clients.\n\n\nSecret\n:\n wird ebenfalls in ownCloud generiert und zur Authentifizierung verwendet.\n\n\n\n\nBeide Datens\u00e4tze sind Strings bestehend aus Buchstaben und Zahlen. Daher eignet sich f\u00fcr beide ein Textfeld, welches ausschlie\u00dflich\nalphanumerische Werte erwartet, zur Eingabe.\n\n\nZur Nutzung des WebDAV Clients werden dar\u00fcber hinaus folgende Daten ben\u00f6tigt:\n\n\n\n\nServer Addresse\n:\n Url \u00fcber die der ownCloud Server erreicht werden kann.\n\n\nServer Pfad\n:\n der angehangene Pfad, \u00fcber den die WebDAV Schnittstelle erreicht werden kann.\n\n\nPort\n:\n Port des WebDAV-Servers.\n\n\nProtokoll\n:\n Wahl zwischen HTTP und HTTPS.\n\n\n\n\nW\u00e4hrend die Wahl des Protokolls mittels einer Auswahl aus vorhandenen Optionen abgeboten werden kann, m\u00fcssen die restlichen Werte\nin einem Textfeld erfragt werden. Auch in diesem Fall werden die Variablen nach den zu erwartenden Werten ges\u00e4ubert. Dar\u00fcber hinaus\nwerden alle Eingaben, bis auf den Port, als notwendig angesehen.\n\n\nSettings\n\n\nDie nun ben\u00f6tigten Eingabedaten m\u00fcssen in Moodle auf der Einstellungsseite des Plugins erfragt und entprechend gespeichert werden.\nUm dies zu bewerkstelligen wird in der settings.php jedes Eingabefeld einzeln definiert. In dem folgenden Beispiel wird das\nEingabfeld f\u00fcr die Client ID beschrieben:\n\n\n$setting = new admin_setting_configtext('tool_oauth2owncloud/clientid',\n        get_string('clientid', 'tool_oauth2owncloud'),\n        get_string('help_oauth_param', 'tool_oauth2owncloud', 'client identifier'), '', PARAM_ALPHANUM, '64');\n$settings-\nadd($setting);\n\n\n\n\nDie Definition des Feldes beinhaltet den Ort, an dem die Eingabe gespeichert wird und dementsprechend wiedergefunden werden kann.\nIn diesem Fall wird die Eingabe unter den Plugin-spezifischen Einstellungen hinterlegt. Weiterhin werden der Name des Feldes\n(so wie er dem Nutzer angezeigt wird), ein Beschreibungstext und Standardwert (in diesem Fall bleibt es leer) f\u00fcr das Feld angegeben.\nZuletzt werden der Typ (in diesem Fall alphanumerisch) und die L\u00e4nge der erwarteten Eingabe festgelegt.\n\n\nDie Einstellungsseite wird anschlie\u00dfend in die Kategorie der Admin Tools eingeordnet, wo sie von dem Seitenadministrator wiedergefunden\nwerden kann.\n\n\nDer Administrator kann die Einstellungen jederzeit \u00e4ndern und damit die gew\u00fcnschte Schnittstelle konfigurieren und gegebenenfalls anpassen.\n\n\nOAuth 2.0 Client\n\n\nDen funktionalen Kern des Plugins stellt der OAuth 2.0 ownCloud Client dar. Dieser befindet sich in Form der Klasse \nowncloud\n in der\nDatei \nsciebo.php\n in dem \nclasses\n Ordner des Plugins. Diese Klasse steuert sowohl den Moodle-seitigen Protokollablauf\nvon OAuth 2.0, als auch den Verbindungsaufbau zu ownCloud mittels WebDAV und OCS Share API. Dadurch, dass \nowncloud\n von der im Moodle Core\nenthaltenen Klasse \noauth2_client\n erbt, ist ein Gro\u00dfteil des Protokollablaufs bereits abgedeckt.\nDer Konstruktor der Klasse \noauth2_client\n muss mit den \nClient ID\n und \nSecret\n Daten aufgerufen werden.\nDiese werden aus den zuvor angewandten Einstellungen beschafft:\n\n\npublic function __construct($callback) {\n    $server = get_config('tool_oauth2owncloud', 'server');\n    $clientid = get_config('tool_oauth2owncloud', 'clientid');\n    $secret = get_config('tool_oauth2owncloud', 'secret');\n    $protocol = get_config('tool_oauth2owncloud', 'protocol');\n    $port = get_config('tool_oauth2owncloud', 'port');\n    $path = get_config('tool_oauth2owncloud', 'path');\n\n    parent::__construct($clientid, $secret, $callback, '');\n\n\n\n\nZu diesem Zweck wird die Methode \nget_config\n verwendet. Sie gibt den f\u00fcr ein Plugin und einen zuvor einzigartig definierten\nNamen aus den Einstellungen heraus den dazu gespeicherten Wert.\nDar\u00fcber hinaus muss eine \ncallback URL\n angef\u00fcgt werden, die den Pfad angibt, an den nach der Authentifizierung und Authorisierung\nder Nutzer weitergeleitet werden soll. Dieser wird allerdings extern in den Anwendungen erzeugt, die den \nowncloud\n Client benutzen.\n\n\nZu beachten ist, dass f\u00fcr die Klasse \nowncloud\n ein \nnamespace\n definiert wird, womit diese effizient in externen Plugins verwendet werden\nkann, die einen OAuth 2.0 ownCloud Client ben\u00f6tigen.\n\n\nWeiterhin m\u00fcssen die Methoden \nauth_url\n und \ntoken_url\n der Elternklasse zwingend implementiert werden, um bei der Authentifizierung\nund der Token-Beschaffung auf die richtigen Pfade zu verweisen:\n\n\nprotected function auth_url() {\n    // Dynamically generated from the admin tool settings.\n    return $this-\nprefixoc . 'index.php/apps/oauth2/authorize';\n}\n\nprotected function token_url() {\n    return $this-\nprefixoc . 'index.php/apps/oauth2/api/v1/token';\n}\n\n\n\n\nHierf\u00fcr werden die beiden Pfade aus der Serveraddresse, dem Port und dem Serverpfad berechnet, da der Endpunkt f\u00fcr die oauth2 App in\nownCloud gleich bleibt. Die ben\u00f6tigten Eingabdaten werden, soweit angegeben, der Eingabemaske entnommen.\n\n\nErweiterungen der Schnittstellen\n\n\nDa zur Umsetzung des Verfahrens die vorgegebenen Schnittstellen nicht ausreichten, mussten in Anpassungen in Moodle Core \nBibliotheken vorgenommen werden. Im Folgenden werden diese \u00c4nderungen beschrieben.\n\n\nOAuth 2.0 Client\n\n\nAnpassung der \npost\n Methode\n\n\nDie Moodle-interne Klasse \noauth2_client\n erbt von einer weiteren Klasse aus dem Moodle Core mit dem Namen \ncurl\n, welche mittels\n\ncURL\n HTTP Requests erstellen und verschicken kann. Dadurch ist die Klasse f\u00e4hig eigenst\u00e4ndig einen Access Token mit einem \nAuthorization Code mittels der HTTP POST Methode \u00fcber die \ntoken\n Schnittstelle in ownCloud zu beschaffen. Allerdings\nbietet die daf\u00fcr zust\u00e4ndige Methode \npost\n nicht die M\u00f6glichkeit einen Basic Authorization Header zur Anfrage hinzuzuf\u00fcgen,\nwelcher Client ID und Secret zur Autorisierung in der \noauth2\n ownCloud App mit verschickt. Daher musste die \npost\n Methode\nin der \nowncloud\n Klasse so \u00fcberschrieben werden, dass der ben\u00f6tigte Header vor dem Aufruf der geerbten Methode gesetzt wird:\n\n\npublic function post($url, $params = '', $options = array(), $auth = false) {\n\n    if ($auth == false) {\n        $this-\nsetHeader(array(\n                'Authorization: Basic ' . base64_encode($this-\nget_clientid() . ':' . $this-\nget_clientsecret())\n        ));\n\n        $this-\nlog_out();\n    }\n\n    return parent::post($url, $params, $options);\n}\n\n\n\n\nDer entsprechende Header wird nur dann gesetzt, wenn ein Access Token angefordert werden soll. Um nicht zus\u00e4tzlich einen\nAuthentication Header mit einem abgelaufenen Access Token zu versenden, muss dieses Access Token mittels \nlog_out()\n \nentfernt werden.\n\n\nErweiterung des Access Tokens\n\n\nEin in der Eltern-Klasse \noauth2_client\n erhaltenes Access Token verf\u00fcgt \u00fcber die Attribute \ntoken\n, was die Zeichenkette des Tokens\nbeinhaltet, und \nexpires\n, welches das Ablaufdatum des Tokens angibt. Da jedoch von der oauth2 ownCloud App dar\u00fcber hinaus noch die\nAttribute \nrefresh_token\n und \nuser_id\n versandt werden und f\u00fcr einige Integrationsszenarien gebraucht werden, musste das Access Token\nim OAuth 2.0 ownCloud Client, nach dem Upgrade aus einem Authorization Code, um eben diese Eigenschaften erweitert werden:\n\n\n$r = upgrade($code);\n\n$accesstoken = new stdClass;\n$accesstoken-\ntoken = $r-\naccess_token;\n$accesstoken-\nexpires = (time() + ($r-\nexpires_in - 10));\n$accesstoken-\nuser_id = $r-\nuser_id;\n$accesstoken-\nrefresh_token = $r-\nrefresh_token;\n\n$this-\nstore_token($accesstoken);\n\n\n\n\nEinf\u00fchrung des Refresh Tokens\n\n\nDa nun das Access Token um die fehlende Eigenschaft \nrefresh_token\n erg\u00e4nzt worden ist, musste der Client ebenfalls um die\nF\u00e4higkeit, ein Refresh Token zu einem Access Token aufzuwerten, erweitert werden. Hierzu musste einerseits an der Stelle\neingegriffen werden, an der das aktuelle Access Token gepr\u00fcft wird. Ist das aktuelle Access Token abgelaufen und ein Refresh\nToken vorhanden, so muss versucht werden ein neues Access Token mit Hilfe des Refresh Tokens anzufordern. Dabei wird dieselbe\nSchnittstelle verwendet, die auch zum Aufwerten eines Authorization Codes zum Einsatz kommt. Daher muss bei der Ausf\u00fchrung der\nMethode \nupgrade_token\n zwischen Refresh Token und Authorization Code unterschieden werden:\n\n\nif ($refresh == false) {\n    $grant = 'authorization_code';\n    $type = 'code';\n} else {\n    $grant = 'refresh_token';\n    $type = 'refresh_token';\n}\n\n$params = array(\n        'grant_type' =\n $grant,\n        $type =\n $code,\n        'redirect_uri' =\n $callbackurl-\nout(false),\n);\n\n$response = $this-\npost($this-\ntoken_url(), $params);\n\n\n\n\nDie \u00fcbergebenen Parameter der HTTP POST Methode m\u00fcssen, wie in dem Protokollablauf spezifiziert, jeweils auf den Typ der\naufzuwertenden Zeichenkette (\ncode\n vs. \nrefresh_token\n) angepasst werden. Im Fall eines Erfolges sollten beide Anfrage-Typen\nein Access Token zur\u00fcckliefern.\n\n\nSpeicherung Nutzer-spezifischer Access Tokens\n\n\nUm einen hohen Grad an Komfort und Sicherheit gew\u00e4hrleisten zu k\u00f6nnen, musste dem Nutzer die M\u00f6glichkeit eines einmaligen\nLogins gegeben werden. Durch die Einf\u00fchrung eines Refresh Tokens wurde der erste Schritt in diese Richtung get\u00e4tigt, da nun\ndas Access Token, im Normalfall, immer wieder aufgewertet werden kann, ohne dass man sich erneut in ownCloud authentifizieren muss.\nWeiterhin wurde der OAuth 2.0 ownCloud Client um eine Methode \ncheck_login\n erg\u00e4nzt, welche nach Erhalt eines Access Tokens\ndieses innerhalb der pers\u00f6nlichen Einstellungen des aktuellen Nutzers hinterlegt und, falls vorhanden, bei der Pr\u00fcfung des\nLogin-Status auch daraus bezieht.\n\n\nDar\u00fcber hinaus bietet die Methode \ncheck_login\n auch die M\u00f6glichkeit ein Access Token f\u00fcr ein spezielles, angegebenes Plugin\nzu speichern, um zum Beispiel einen technischen Nutzer in ownCloud zu verwenden.\n\n\nWebDAV Client\n\n\nDa ownCloud Datentransfer lediglich \u00fcber eine WebDAV Schnittstelle anbietet, musste auf diese in Moodle mittels eines daf\u00fcr\nvorgesehenen Clients zugegriffen werden k\u00f6nnen. Moodle bietet bereits einen WebDAV Client an, welcher als Basis f\u00fcr ownClouds\nWebDAV Schnittstelle verwendet werde konnte.\n\n\nAbsicherung mittels OAuth 2.0\n\n\nDer Moodle-interne Client bietet eine gro\u00dfe Auswahl an WebDAV Methoden, welche zum Gro\u00dfteil erfolgreichen Datentransfer mit\nownCloud erm\u00f6glichen. Der Nachteil des Client besteht darin, dass er ausschlie\u00dflich mit \nBasic Auth\n ausgestattet ist und somit\nbei jedem Zugriff Nutzername und Passwort des ownCloud Accounts versandt werden muss. Um eine passwortlose Authentifizierung\nzu erm\u00f6glichen, musste der WebDAV Client mittles OAuth 2.0 abgesichert werden.\n\n\nIn der Umsetzung wurde der Client mit einem Access Token ausgestattet, welches bei jedem Zugriff, innerhalb eines Bearer\nAuthentication Headers, an ownCloud mitversandt wird:\n\n\nprivate function create_basic_request($method) {\n    // ...F\u00fcge die ben\u00f6tigten Header hinzu.\n    if ($this-\n_auth == 'basic') {\n        $this-\nheader_add(sprintf('Authorization: Basic %s', \n                    base64_encode(\n$this-\n_user:$this-\n_pass\n)));\n    } else if ($this-\n_auth == 'bearer') {\n        $this-\nheader_add(sprintf('Authorization: Bearer %s', \n                    $this-\n_token));\n    }\n}\n\n\n\n\nownCloud-seitig wird der Header erkannt und statt einer Kombintion aus Nutzernamen und Passwort, das \u00fcbergebene Access Token\nausgewertet. Wenn das Access Token noch g\u00fcltig ist, wird die Anfrage ganz normal behandelt.\n\n\nWeiterleitungen\n\n\nUm den OAuth 2.0 und den WebDAV Client miteinander zu kombinieren, wurden Weiterleitungs-Methoden implementiert, welche die\nvon weiteren Integrationsszenarien ben\u00f6tigten Zugriffe auf die WebDAV Schnittstelle \u00fcber den OAuth 2.0 ownCloud Client\nweiterleiten. Dieser setzt zun\u00e4chst ein g\u00fcltiges Access Token und ruft dann die entsprechende WebDAV Methode \u00fcber den WebDAV\nClient auf. Im folgenden Beispiel wird der Aufruf der Methode MKCOL gezeigt:\n\n\npublic function make_folder($path) {\n    $this-\ndav-\nset_token($this-\nget_accesstoken()-\ntoken);\n    return $this-\ndav-\nmkcol($this-\nprefixwebdav . $path);\n}\n\n\n\n\nDer Pfad zur WebDAV Schnittstelle des ownCloud Servers wird bereits im Konstruktor der Klasse \nowncloud\n aus Angaben in der\nEingabemaske zusammengestellt.\n\n\nOCS Share API\n\n\nAuch ownClouds OCS Share API wird zur Abdeckung einiger Intergrationsszenarien ben\u00f6tigt, da sie sowohl zum Teilen von privaten\nInhalten, als auch zum Generieren \u00f6ffentlicher Links gebraucht werden kann. Mussten zuvor noch Nutzername und Passwort bei jedem\nZugriff auf diese Schnittstelle zwingend zur Authentifizierung angegeben werden, reicht durch das Setzen eines Bearer Authentication\nHeaders nun auch ein von ownCloud erhaltenes Access Token. Somit ist auch diese Schnittstelle nun mittels OAuth 2.0 abgesichert.\n\n\nIntegration mit ownCloud\n\n\nNachdem die n\u00f6tigen Schnittstellen individuell implementiert worden sind, k\u00f6nnen sie genutzt werden um den von OAuth 2.0 spezifizierten\nProtokollablauf Moodle-seitig durchzuf\u00fchren. Um beispielsweise \u00fcber eine WebDAV Anfrage Daten aus einer ownCloud Instanz \nbeschaffen zu k\u00f6nnen, m\u00fcssen im Wesentlich folgende Schritte in Moodle unternommen werden, nachdem die Eingabemaske korrekt \nausgef\u00fcllt worden ist:\n\n\n\n\nAnfrage auf \nAuthentifizierung und Autorisierung\n\n\nAnfrage eines \nAccess Tokens\n\n\nZugriff auf die \nWebDAV\n Schnittstelle\n\n\n\n\nDer damit vollzogene Ablauf l\u00e4sst sich in folgender Grafik erfassen:\n\n\n\n\nDiese Schritte werden im Folgenden erl\u00e4utert.\n\n\nAuthentifizierung und Autorisierung\n\n\nSobald ein Nutzer in Moodle zum ersten Mal mittels OAuth 2.0 auf ownCloud zugreifen m\u00f6chte, m\u00fcssen in ownCloud dessen\nAuthentifizierung und Autorisierung erfragt werden. Zu diesem Zweck wird der Nutzer mittels eines Links an die \nauthorize\n\nSchnittstelle der oauth2 App in ownCloud weitergeleitet. Dabei werden die im Authorization Code Flow aufgef\u00fchrten Parameter,\nwelche zur Bearbeitung der Autorisierungsanfrage n\u00f6tig sind, angef\u00fcgt. W\u00e4hrend \nrespone_type\n, \nclient_id\n und \nredirect_uri\n\nstets gleich bleiben, beziehungsweise von der vorgenommenen Konfiguration abh\u00e4ngig sind, wird der \nstate\n Moodle-intern\nvon der Anwendung gestellt, welche den Client benutzt. Der \nstate\n Parameter gibt an, wohin in Moodle weitergeleitet werden\nsoll, nachdem eine erfolgreiche Anfrage gestellt worden ist. Somit dient \nstate\n in Moodle der Wiederherstellung des Standes,\nan dem der Nutzer sich vor der Anfrage befand. Im Fall des ownCloud Repository Plugins wird, wie im folgenden gezeigt,\nauf eine Moodle-interne Adresse verwiesen, die den Status eines Repositories in dem File Picker wiederherstellt.\n\n\n$returnurl = new moodle_url('/repository/repository_callback.php', [\n        'callback'  =\n 'yes',\n        'repo_id'   =\n $repositoryid,\n        'sesskey'   =\n sesskey(),\n]);\n\n\n\n\nFalls die Anfrage erfolgreich verl\u00e4uft, erh\u00e4lt der Client einen Authorization Code, welcher ihn zur Anfrage eines Access Tokens\nbem\u00e4chtigt.\n\n\nDie Autorisierung durch den Nutzer stellt die einzige f\u00fcr diesen sichtbare Schnittstelle dar.\n\n\nAnfrage eines Access Tokens\n\n\nUm einen Authorization Code zu einem Access Token aufzuwerten muss mittels einer POST-Anfrage die \ntoken\n Schnittstelle\nder oauth2 App in ownCloud angesprochen werden. Erneut m\u00fcssen alle \n\nspezifizierten Angaben\n in dem Request \u00fcbergeben werden,\nunter Anderem der Authorization Code. Da ownCloud-seitig zus\u00e4tzlich ein Basic Authentication Header mit Client ID und\nClient Secret zur Authentifizierung erwartet wird, muss dieser zus\u00e4tzlich bei der Anfrage nach einem Access Token hinzugef\u00fcgt werden.\n\n\nDie Anfrage auf einen Access Token erfolgt Moodle-intern sobald ein Authorization Code erhalten worden ist, um ein\nAblaufen des Codes zu verhindern und dem Nutzer sofort Zugang zu ownCloud zu erm\u00f6glichen.\n\n\nZugriff auf WebDAV\n\n\nNachdem erfolreich ein Access Token angefordert worden ist, kann dieses verwendet werden um die WebDAV Schnittstelle abzusichern.\nWenn der Nutzer eine WebDAV Anfrage anfordert, setzt der OAuth 2.0 Client zun\u00e4chst das erhaltene Access Token im WebDAV Client.\nAnschlie\u00dfend leitet dieser die Anfrage an den WebDAV Client weiter, der den WebDAV Request, mitsamt eines Bearer Authentication\nHeaders, an ownClouds WebDAV Schnittstelle \u00e4u\u00dfert. Der Header ersetzt dabei den ansonsten versendeten Basic Authentication Header\nund beinhaltet das Access Token.\n\n\nZu beachten ist, dass sowohl bei Zugriffen \u00fcber WebDAV, als auch \u00fcber die OCS Share API nur die Authentifizierungsmethode ver\u00e4ndert\nwird. Ansonsten bleiben die Anfragen unver\u00e4ndert im Vergleich mit Basic Auth.\n\n\nTests und Continuous Integration", 
            "title": "Admin Tool"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#admin-tool-oauth2owncloud", 
            "text": "", 
            "title": "Admin Tool: oauth2owncloud"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#zweck", 
            "text": "Wie bereits im Kapitel  Software Architektur  angeschnitten, ist der Hauptzweck dieses Plugins\ndie Schnittstelle zu ownCloud bereitzustellen. Zu diesem Zweck wird die im Projekt implementierte ownCloud \nApp  oauth2  mit Hilfe eines OAuth 2.0 Clients angesprochen. Zus\u00e4tzlich werden\nsowohl die WebDAV, als auch die OCS Share Schnittstelle, \u00fcber OAuth 2.0 abgesichert, in diesem Client umfasst.\nZwar ist der Client auf einen OAuth 2.0 Protokollablauf in Zusammenarbeit mit der entsprechenden ownCloud App angepasst,\njedoch k\u00f6nnte er in Zukunft auch als Ausgangspunkt genutzt werden, um \u00e4hnliche Schnittstellen zu erreichen.  Im Wesentlichen implementiert dieses Plugin das folgende  Integrationsszenario :   Als  Nutzer  m\u00f6chte ich OAuth 2.0 benutzen k\u00f6nnen, um Moodle Zugriff auf ownCloud zu gew\u00e4hren.   Jedoch betrifft es auch alle anderen Szenarien indirekt, da diese erst durch die Authentifizierung mittels OAuth 2.0\nerm\u00f6glicht werden k\u00f6nnen.", 
            "title": "Zweck"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#vorgegebene-schnittstelle", 
            "text": "F\u00fcr Admin Tools ist in Moodle lediglich eine schwach definierte Schnittstelle gegeben. Wie in jedem anderen Moodle Plugin \nauch, m\u00fcssen zun\u00e4chst einige Standarddateien implementiert werden:    version.php :  Beschreibt die Versionsnummer des Plugins, die ben\u00f6tigte Moodle Version und Abh\u00e4ngigkeiten des Plugins.  access.php :  Legt die Berechtigungen f\u00fcr definierte Aktionen innerhalb des Plugins anhand von Nutzerrollen fest.  tool_oauth2sciebo.php :  Beinhaltet Sprachstrings f\u00fcr unterschiedliche Regionen und Sprachen, sodass definierte Strings,\nabh\u00e4ngig von der jeweiligen Sprache, dynamisch angezeigt werden k\u00f6nnen.   Zus\u00e4tzlich zu den allgemeinen Plugindateien, sollte das Admin Tool auch mindestens noch eine Datei namens  settings.php \nbeinhalten. Diese umfasst alle Einstellungen, die f\u00fcr das Admin Tool geltend dem Administrator der Moodle Instanz zur \nVerf\u00fcgung gestellt werden sollen. Nach der Eingabe, wird diese Konfiguration Moodle-intern gespeichert und kann von dem\nClient, wenn n\u00f6tig abgerufen werden.  Insgesamt ergibt sich folgende Struktur von Ordnern und Dateien, die mindestens f\u00fcr die Implementierung des ben\u00f6tigten\nAdmin Tools notwendig ist:  classes                             # Enth\u00e4lt alle implementierten Klassen\ndb  \n  \u2514\u2500\u2500 access.php                    # Enth\u00e4lt alle definierten Capabilities\nlang\n  \u2514\u2500\u2500 en\n      \u2514\u2500\u2500 tool_oauth2sciebo.php     # Enth\u00e4lt Sprach-Strings (englisch)                                         \npix                                 # Bilder und Icons\ntests                               # Test-Dateien und Generatoren\nsettings.php                        # Einstellungs-Seite                \nversion.php", 
            "title": "Vorgegebene Schnittstelle"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#implementierung", 
            "text": "Im Folgenden wird zun\u00e4chst ausgef\u00fchrt, wie die vorgegebenen Schnitstellen implementiert worden sind.", 
            "title": "Implementierung"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#eingabemaske", 
            "text": "Um die OAuth 2.0 und WebDAV Clients erfolgreich zum Zugriff auf eine entsprechende ownCloud Instanz zu bef\u00e4higen,\nm\u00fcssen diese zun\u00e4chst mit Hilfe ben\u00f6tigter Eingabedaten konfiguriert werden. Diese sollen zentral im Admin Tool eingegeben und\ngespeichert werden k\u00f6nnen, um sie anschlie\u00dfend von dem Client aus, und damit auch in den ihn verwendenden Plugins, nutzen zu k\u00f6nnen.", 
            "title": "Eingabemaske"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#benotigte-eingaben", 
            "text": "Um den OAuth 2.0 Protokollablauf zu erm\u00f6glichen, m\u00fcssen folgende Daten im Vorfeld erfasst werden:   Client ID :  wird in ownCloud generiert und dient der Identifizierung eines regstrierten Clients.  Secret :  wird ebenfalls in ownCloud generiert und zur Authentifizierung verwendet.   Beide Datens\u00e4tze sind Strings bestehend aus Buchstaben und Zahlen. Daher eignet sich f\u00fcr beide ein Textfeld, welches ausschlie\u00dflich\nalphanumerische Werte erwartet, zur Eingabe.  Zur Nutzung des WebDAV Clients werden dar\u00fcber hinaus folgende Daten ben\u00f6tigt:   Server Addresse :  Url \u00fcber die der ownCloud Server erreicht werden kann.  Server Pfad :  der angehangene Pfad, \u00fcber den die WebDAV Schnittstelle erreicht werden kann.  Port :  Port des WebDAV-Servers.  Protokoll :  Wahl zwischen HTTP und HTTPS.   W\u00e4hrend die Wahl des Protokolls mittels einer Auswahl aus vorhandenen Optionen abgeboten werden kann, m\u00fcssen die restlichen Werte\nin einem Textfeld erfragt werden. Auch in diesem Fall werden die Variablen nach den zu erwartenden Werten ges\u00e4ubert. Dar\u00fcber hinaus\nwerden alle Eingaben, bis auf den Port, als notwendig angesehen.", 
            "title": "Ben\u00f6tigte Eingaben"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#settings", 
            "text": "Die nun ben\u00f6tigten Eingabedaten m\u00fcssen in Moodle auf der Einstellungsseite des Plugins erfragt und entprechend gespeichert werden.\nUm dies zu bewerkstelligen wird in der settings.php jedes Eingabefeld einzeln definiert. In dem folgenden Beispiel wird das\nEingabfeld f\u00fcr die Client ID beschrieben:  $setting = new admin_setting_configtext('tool_oauth2owncloud/clientid',\n        get_string('clientid', 'tool_oauth2owncloud'),\n        get_string('help_oauth_param', 'tool_oauth2owncloud', 'client identifier'), '', PARAM_ALPHANUM, '64');\n$settings- add($setting);  Die Definition des Feldes beinhaltet den Ort, an dem die Eingabe gespeichert wird und dementsprechend wiedergefunden werden kann.\nIn diesem Fall wird die Eingabe unter den Plugin-spezifischen Einstellungen hinterlegt. Weiterhin werden der Name des Feldes\n(so wie er dem Nutzer angezeigt wird), ein Beschreibungstext und Standardwert (in diesem Fall bleibt es leer) f\u00fcr das Feld angegeben.\nZuletzt werden der Typ (in diesem Fall alphanumerisch) und die L\u00e4nge der erwarteten Eingabe festgelegt.  Die Einstellungsseite wird anschlie\u00dfend in die Kategorie der Admin Tools eingeordnet, wo sie von dem Seitenadministrator wiedergefunden\nwerden kann.  Der Administrator kann die Einstellungen jederzeit \u00e4ndern und damit die gew\u00fcnschte Schnittstelle konfigurieren und gegebenenfalls anpassen.", 
            "title": "Settings"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#oauth-20-client", 
            "text": "Den funktionalen Kern des Plugins stellt der OAuth 2.0 ownCloud Client dar. Dieser befindet sich in Form der Klasse  owncloud  in der\nDatei  sciebo.php  in dem  classes  Ordner des Plugins. Diese Klasse steuert sowohl den Moodle-seitigen Protokollablauf\nvon OAuth 2.0, als auch den Verbindungsaufbau zu ownCloud mittels WebDAV und OCS Share API. Dadurch, dass  owncloud  von der im Moodle Core\nenthaltenen Klasse  oauth2_client  erbt, ist ein Gro\u00dfteil des Protokollablaufs bereits abgedeckt.\nDer Konstruktor der Klasse  oauth2_client  muss mit den  Client ID  und  Secret  Daten aufgerufen werden.\nDiese werden aus den zuvor angewandten Einstellungen beschafft:  public function __construct($callback) {\n    $server = get_config('tool_oauth2owncloud', 'server');\n    $clientid = get_config('tool_oauth2owncloud', 'clientid');\n    $secret = get_config('tool_oauth2owncloud', 'secret');\n    $protocol = get_config('tool_oauth2owncloud', 'protocol');\n    $port = get_config('tool_oauth2owncloud', 'port');\n    $path = get_config('tool_oauth2owncloud', 'path');\n\n    parent::__construct($clientid, $secret, $callback, '');  Zu diesem Zweck wird die Methode  get_config  verwendet. Sie gibt den f\u00fcr ein Plugin und einen zuvor einzigartig definierten\nNamen aus den Einstellungen heraus den dazu gespeicherten Wert.\nDar\u00fcber hinaus muss eine  callback URL  angef\u00fcgt werden, die den Pfad angibt, an den nach der Authentifizierung und Authorisierung\nder Nutzer weitergeleitet werden soll. Dieser wird allerdings extern in den Anwendungen erzeugt, die den  owncloud  Client benutzen.  Zu beachten ist, dass f\u00fcr die Klasse  owncloud  ein  namespace  definiert wird, womit diese effizient in externen Plugins verwendet werden\nkann, die einen OAuth 2.0 ownCloud Client ben\u00f6tigen.  Weiterhin m\u00fcssen die Methoden  auth_url  und  token_url  der Elternklasse zwingend implementiert werden, um bei der Authentifizierung\nund der Token-Beschaffung auf die richtigen Pfade zu verweisen:  protected function auth_url() {\n    // Dynamically generated from the admin tool settings.\n    return $this- prefixoc . 'index.php/apps/oauth2/authorize';\n}\n\nprotected function token_url() {\n    return $this- prefixoc . 'index.php/apps/oauth2/api/v1/token';\n}  Hierf\u00fcr werden die beiden Pfade aus der Serveraddresse, dem Port und dem Serverpfad berechnet, da der Endpunkt f\u00fcr die oauth2 App in\nownCloud gleich bleibt. Die ben\u00f6tigten Eingabdaten werden, soweit angegeben, der Eingabemaske entnommen.", 
            "title": "OAuth 2.0 Client"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#erweiterungen-der-schnittstellen", 
            "text": "Da zur Umsetzung des Verfahrens die vorgegebenen Schnittstellen nicht ausreichten, mussten in Anpassungen in Moodle Core \nBibliotheken vorgenommen werden. Im Folgenden werden diese \u00c4nderungen beschrieben.", 
            "title": "Erweiterungen der Schnittstellen"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#oauth-20-client_1", 
            "text": "", 
            "title": "OAuth 2.0 Client"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#anpassung-der-post-methode", 
            "text": "Die Moodle-interne Klasse  oauth2_client  erbt von einer weiteren Klasse aus dem Moodle Core mit dem Namen  curl , welche mittels cURL  HTTP Requests erstellen und verschicken kann. Dadurch ist die Klasse f\u00e4hig eigenst\u00e4ndig einen Access Token mit einem \nAuthorization Code mittels der HTTP POST Methode \u00fcber die  token  Schnittstelle in ownCloud zu beschaffen. Allerdings\nbietet die daf\u00fcr zust\u00e4ndige Methode  post  nicht die M\u00f6glichkeit einen Basic Authorization Header zur Anfrage hinzuzuf\u00fcgen,\nwelcher Client ID und Secret zur Autorisierung in der  oauth2  ownCloud App mit verschickt. Daher musste die  post  Methode\nin der  owncloud  Klasse so \u00fcberschrieben werden, dass der ben\u00f6tigte Header vor dem Aufruf der geerbten Methode gesetzt wird:  public function post($url, $params = '', $options = array(), $auth = false) {\n\n    if ($auth == false) {\n        $this- setHeader(array(\n                'Authorization: Basic ' . base64_encode($this- get_clientid() . ':' . $this- get_clientsecret())\n        ));\n\n        $this- log_out();\n    }\n\n    return parent::post($url, $params, $options);\n}  Der entsprechende Header wird nur dann gesetzt, wenn ein Access Token angefordert werden soll. Um nicht zus\u00e4tzlich einen\nAuthentication Header mit einem abgelaufenen Access Token zu versenden, muss dieses Access Token mittels  log_out()  \nentfernt werden.", 
            "title": "Anpassung der post Methode"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#erweiterung-des-access-tokens", 
            "text": "Ein in der Eltern-Klasse  oauth2_client  erhaltenes Access Token verf\u00fcgt \u00fcber die Attribute  token , was die Zeichenkette des Tokens\nbeinhaltet, und  expires , welches das Ablaufdatum des Tokens angibt. Da jedoch von der oauth2 ownCloud App dar\u00fcber hinaus noch die\nAttribute  refresh_token  und  user_id  versandt werden und f\u00fcr einige Integrationsszenarien gebraucht werden, musste das Access Token\nim OAuth 2.0 ownCloud Client, nach dem Upgrade aus einem Authorization Code, um eben diese Eigenschaften erweitert werden:  $r = upgrade($code);\n\n$accesstoken = new stdClass;\n$accesstoken- token = $r- access_token;\n$accesstoken- expires = (time() + ($r- expires_in - 10));\n$accesstoken- user_id = $r- user_id;\n$accesstoken- refresh_token = $r- refresh_token;\n\n$this- store_token($accesstoken);", 
            "title": "Erweiterung des Access Tokens"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#einfuhrung-des-refresh-tokens", 
            "text": "Da nun das Access Token um die fehlende Eigenschaft  refresh_token  erg\u00e4nzt worden ist, musste der Client ebenfalls um die\nF\u00e4higkeit, ein Refresh Token zu einem Access Token aufzuwerten, erweitert werden. Hierzu musste einerseits an der Stelle\neingegriffen werden, an der das aktuelle Access Token gepr\u00fcft wird. Ist das aktuelle Access Token abgelaufen und ein Refresh\nToken vorhanden, so muss versucht werden ein neues Access Token mit Hilfe des Refresh Tokens anzufordern. Dabei wird dieselbe\nSchnittstelle verwendet, die auch zum Aufwerten eines Authorization Codes zum Einsatz kommt. Daher muss bei der Ausf\u00fchrung der\nMethode  upgrade_token  zwischen Refresh Token und Authorization Code unterschieden werden:  if ($refresh == false) {\n    $grant = 'authorization_code';\n    $type = 'code';\n} else {\n    $grant = 'refresh_token';\n    $type = 'refresh_token';\n}\n\n$params = array(\n        'grant_type' =  $grant,\n        $type =  $code,\n        'redirect_uri' =  $callbackurl- out(false),\n);\n\n$response = $this- post($this- token_url(), $params);  Die \u00fcbergebenen Parameter der HTTP POST Methode m\u00fcssen, wie in dem Protokollablauf spezifiziert, jeweils auf den Typ der\naufzuwertenden Zeichenkette ( code  vs.  refresh_token ) angepasst werden. Im Fall eines Erfolges sollten beide Anfrage-Typen\nein Access Token zur\u00fcckliefern.", 
            "title": "Einf\u00fchrung des Refresh Tokens"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#speicherung-nutzer-spezifischer-access-tokens", 
            "text": "Um einen hohen Grad an Komfort und Sicherheit gew\u00e4hrleisten zu k\u00f6nnen, musste dem Nutzer die M\u00f6glichkeit eines einmaligen\nLogins gegeben werden. Durch die Einf\u00fchrung eines Refresh Tokens wurde der erste Schritt in diese Richtung get\u00e4tigt, da nun\ndas Access Token, im Normalfall, immer wieder aufgewertet werden kann, ohne dass man sich erneut in ownCloud authentifizieren muss.\nWeiterhin wurde der OAuth 2.0 ownCloud Client um eine Methode  check_login  erg\u00e4nzt, welche nach Erhalt eines Access Tokens\ndieses innerhalb der pers\u00f6nlichen Einstellungen des aktuellen Nutzers hinterlegt und, falls vorhanden, bei der Pr\u00fcfung des\nLogin-Status auch daraus bezieht.  Dar\u00fcber hinaus bietet die Methode  check_login  auch die M\u00f6glichkeit ein Access Token f\u00fcr ein spezielles, angegebenes Plugin\nzu speichern, um zum Beispiel einen technischen Nutzer in ownCloud zu verwenden.", 
            "title": "Speicherung Nutzer-spezifischer Access Tokens"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#webdav-client", 
            "text": "Da ownCloud Datentransfer lediglich \u00fcber eine WebDAV Schnittstelle anbietet, musste auf diese in Moodle mittels eines daf\u00fcr\nvorgesehenen Clients zugegriffen werden k\u00f6nnen. Moodle bietet bereits einen WebDAV Client an, welcher als Basis f\u00fcr ownClouds\nWebDAV Schnittstelle verwendet werde konnte.", 
            "title": "WebDAV Client"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#absicherung-mittels-oauth-20", 
            "text": "Der Moodle-interne Client bietet eine gro\u00dfe Auswahl an WebDAV Methoden, welche zum Gro\u00dfteil erfolgreichen Datentransfer mit\nownCloud erm\u00f6glichen. Der Nachteil des Client besteht darin, dass er ausschlie\u00dflich mit  Basic Auth  ausgestattet ist und somit\nbei jedem Zugriff Nutzername und Passwort des ownCloud Accounts versandt werden muss. Um eine passwortlose Authentifizierung\nzu erm\u00f6glichen, musste der WebDAV Client mittles OAuth 2.0 abgesichert werden.  In der Umsetzung wurde der Client mit einem Access Token ausgestattet, welches bei jedem Zugriff, innerhalb eines Bearer\nAuthentication Headers, an ownCloud mitversandt wird:  private function create_basic_request($method) {\n    // ...F\u00fcge die ben\u00f6tigten Header hinzu.\n    if ($this- _auth == 'basic') {\n        $this- header_add(sprintf('Authorization: Basic %s', \n                    base64_encode( $this- _user:$this- _pass )));\n    } else if ($this- _auth == 'bearer') {\n        $this- header_add(sprintf('Authorization: Bearer %s', \n                    $this- _token));\n    }\n}  ownCloud-seitig wird der Header erkannt und statt einer Kombintion aus Nutzernamen und Passwort, das \u00fcbergebene Access Token\nausgewertet. Wenn das Access Token noch g\u00fcltig ist, wird die Anfrage ganz normal behandelt.", 
            "title": "Absicherung mittels OAuth 2.0"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#weiterleitungen", 
            "text": "Um den OAuth 2.0 und den WebDAV Client miteinander zu kombinieren, wurden Weiterleitungs-Methoden implementiert, welche die\nvon weiteren Integrationsszenarien ben\u00f6tigten Zugriffe auf die WebDAV Schnittstelle \u00fcber den OAuth 2.0 ownCloud Client\nweiterleiten. Dieser setzt zun\u00e4chst ein g\u00fcltiges Access Token und ruft dann die entsprechende WebDAV Methode \u00fcber den WebDAV\nClient auf. Im folgenden Beispiel wird der Aufruf der Methode MKCOL gezeigt:  public function make_folder($path) {\n    $this- dav- set_token($this- get_accesstoken()- token);\n    return $this- dav- mkcol($this- prefixwebdav . $path);\n}  Der Pfad zur WebDAV Schnittstelle des ownCloud Servers wird bereits im Konstruktor der Klasse  owncloud  aus Angaben in der\nEingabemaske zusammengestellt.", 
            "title": "Weiterleitungen"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#ocs-share-api", 
            "text": "Auch ownClouds OCS Share API wird zur Abdeckung einiger Intergrationsszenarien ben\u00f6tigt, da sie sowohl zum Teilen von privaten\nInhalten, als auch zum Generieren \u00f6ffentlicher Links gebraucht werden kann. Mussten zuvor noch Nutzername und Passwort bei jedem\nZugriff auf diese Schnittstelle zwingend zur Authentifizierung angegeben werden, reicht durch das Setzen eines Bearer Authentication\nHeaders nun auch ein von ownCloud erhaltenes Access Token. Somit ist auch diese Schnittstelle nun mittels OAuth 2.0 abgesichert.", 
            "title": "OCS Share API"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#integration-mit-owncloud", 
            "text": "Nachdem die n\u00f6tigen Schnittstellen individuell implementiert worden sind, k\u00f6nnen sie genutzt werden um den von OAuth 2.0 spezifizierten\nProtokollablauf Moodle-seitig durchzuf\u00fchren. Um beispielsweise \u00fcber eine WebDAV Anfrage Daten aus einer ownCloud Instanz \nbeschaffen zu k\u00f6nnen, m\u00fcssen im Wesentlich folgende Schritte in Moodle unternommen werden, nachdem die Eingabemaske korrekt \nausgef\u00fcllt worden ist:   Anfrage auf  Authentifizierung und Autorisierung  Anfrage eines  Access Tokens  Zugriff auf die  WebDAV  Schnittstelle   Der damit vollzogene Ablauf l\u00e4sst sich in folgender Grafik erfassen:   Diese Schritte werden im Folgenden erl\u00e4utert.", 
            "title": "Integration mit ownCloud"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#authentifizierung-und-autorisierung", 
            "text": "Sobald ein Nutzer in Moodle zum ersten Mal mittels OAuth 2.0 auf ownCloud zugreifen m\u00f6chte, m\u00fcssen in ownCloud dessen\nAuthentifizierung und Autorisierung erfragt werden. Zu diesem Zweck wird der Nutzer mittels eines Links an die  authorize \nSchnittstelle der oauth2 App in ownCloud weitergeleitet. Dabei werden die im Authorization Code Flow aufgef\u00fchrten Parameter,\nwelche zur Bearbeitung der Autorisierungsanfrage n\u00f6tig sind, angef\u00fcgt. W\u00e4hrend  respone_type ,  client_id  und  redirect_uri \nstets gleich bleiben, beziehungsweise von der vorgenommenen Konfiguration abh\u00e4ngig sind, wird der  state  Moodle-intern\nvon der Anwendung gestellt, welche den Client benutzt. Der  state  Parameter gibt an, wohin in Moodle weitergeleitet werden\nsoll, nachdem eine erfolgreiche Anfrage gestellt worden ist. Somit dient  state  in Moodle der Wiederherstellung des Standes,\nan dem der Nutzer sich vor der Anfrage befand. Im Fall des ownCloud Repository Plugins wird, wie im folgenden gezeigt,\nauf eine Moodle-interne Adresse verwiesen, die den Status eines Repositories in dem File Picker wiederherstellt.  $returnurl = new moodle_url('/repository/repository_callback.php', [\n        'callback'  =  'yes',\n        'repo_id'   =  $repositoryid,\n        'sesskey'   =  sesskey(),\n]);  Falls die Anfrage erfolgreich verl\u00e4uft, erh\u00e4lt der Client einen Authorization Code, welcher ihn zur Anfrage eines Access Tokens\nbem\u00e4chtigt.  Die Autorisierung durch den Nutzer stellt die einzige f\u00fcr diesen sichtbare Schnittstelle dar.", 
            "title": "Authentifizierung und Autorisierung"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#anfrage-eines-access-tokens", 
            "text": "Um einen Authorization Code zu einem Access Token aufzuwerten muss mittels einer POST-Anfrage die  token  Schnittstelle\nder oauth2 App in ownCloud angesprochen werden. Erneut m\u00fcssen alle  spezifizierten Angaben  in dem Request \u00fcbergeben werden,\nunter Anderem der Authorization Code. Da ownCloud-seitig zus\u00e4tzlich ein Basic Authentication Header mit Client ID und\nClient Secret zur Authentifizierung erwartet wird, muss dieser zus\u00e4tzlich bei der Anfrage nach einem Access Token hinzugef\u00fcgt werden.  Die Anfrage auf einen Access Token erfolgt Moodle-intern sobald ein Authorization Code erhalten worden ist, um ein\nAblaufen des Codes zu verhindern und dem Nutzer sofort Zugang zu ownCloud zu erm\u00f6glichen.", 
            "title": "Anfrage eines Access Tokens"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#zugriff-auf-webdav", 
            "text": "Nachdem erfolreich ein Access Token angefordert worden ist, kann dieses verwendet werden um die WebDAV Schnittstelle abzusichern.\nWenn der Nutzer eine WebDAV Anfrage anfordert, setzt der OAuth 2.0 Client zun\u00e4chst das erhaltene Access Token im WebDAV Client.\nAnschlie\u00dfend leitet dieser die Anfrage an den WebDAV Client weiter, der den WebDAV Request, mitsamt eines Bearer Authentication\nHeaders, an ownClouds WebDAV Schnittstelle \u00e4u\u00dfert. Der Header ersetzt dabei den ansonsten versendeten Basic Authentication Header\nund beinhaltet das Access Token.  Zu beachten ist, dass sowohl bei Zugriffen \u00fcber WebDAV, als auch \u00fcber die OCS Share API nur die Authentifizierungsmethode ver\u00e4ndert\nwird. Ansonsten bleiben die Anfragen unver\u00e4ndert im Vergleich mit Basic Auth.", 
            "title": "Zugriff auf WebDAV"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#tests-und-continuous-integration", 
            "text": "", 
            "title": "Tests und Continuous Integration"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/", 
            "text": "Repository: \nowncloud\n\n\nZweck\n\n\nDer Plugin Typ \nRepository\n wird in Moodle unter anderem verwendet um Nutzer die M\u00f6glichkeit zu schaffen Zugang zu Dateien aus externen Quellen zu bekommen. Das Repository Plugin ownCloud kann somit folgende Integrationsszenarien realisieren:\n\n\n\n\nAls \nNutzer\n m\u00f6chte ich in der Dateiauswahl in Moodle eine Datei aus meiner ownCloud Instanz \nhochladen\n.\n\n\nAls \nNutzer\n m\u00f6chte ich in der Dateiauswahl in Moodle eine Datei aus meiner ownCloud Instanz \nverlinken\n.\n\n\n\n\nUnser Plugin soll dem Administrator der Seite erm\u00f6glichen das Repository zu aktivieren und zu deaktivieren.\nAlle Nutzer der Moodle Instanz sollen mit Hilfe des Plugins sind in ownCloud authentifizieren k\u00f6nnen. Danach sollen sie in Moodle bequem zwischen Ihren Dateien w\u00e4hlen k\u00f6nnen und sich mit verschiedenen Accounts authentifizieren k\u00f6nnen. Besonders im Vordergrund steht das unser Plugin m\u00f6glichst einfach zu bedienen ist, um die Benutzerfreundlichkeit zu erh\u00f6hen.\n\n\nVorgegebene Schnittstelle\n\n\nWie auch im \nAdmin Tool\n m\u00fcssen zun\u00e4chst einige Standartschnittstellen implementiert werden:\n\n\n\n\nversion.php\n:\n Beschreibt die Versionsnummer des Plugins, die ben\u00f6tigte moodle Version und Abh\u00e4ngigkeiten des Plugins.\n\n\ndb/access.php\n:\n Legt die Berechtigungen f\u00fcr definierte Aktionen innerhalb des Plugins anhand von Nutzerrollen fest.\n\n\nlang/en/repository__sciebo.php\n:\n Beinhaltet Sprachstrings f\u00fcr unterschiedliche Regionen und Sprachen, sodass definierte Strings,\nabh\u00e4ngig von der jeweiligen Sprache, dynamisch angezeigt werden k\u00f6nnen. Als Standard wird eine englische Sprachdatei erwartet.\n\n\n\n\nF\u00fcr Repository-Plugins m\u00fcssen au\u00dferdem folgende Dateien implementiert werden:\n\n\n\n\npix/icon.png\n:\n Hier wird ein 16x16 icon platziert, welches f\u00fcr das Plugin genutzt wird. Dies kann auch beliebig angepasst werden.\n\n\nlib.php\n:\n Hier wird eine Klasse \nrepository_sciebo extends repository\n deklariert, die als Hauptaufgabe die Integration in den File Picker verwaltet.\n\n\n\n\nImplementierung\n\n\nDie WebDAV Zugriffe und der Ablauf des OAuth2.0 Verfahrens wird vom \noauth2owncloud_admin_tool\n geregelt. Somit hat das \nRepository\n niemals Zugriff auf den Login-Status oder den \nAccess Token\n. Falls Konfigurationen des \nAdmin Tool\n fehlen, ist das \nRepository\n nicht mehr verf\u00fcgbar. \n\n\nImplementierung der \nlib.php\n\n\nIn der lib.php wird eine Klasse definiert die von der abstrakten Klasse \nrepository\n erbt. Im Folgenden wird darauf eingegangen wie die vorgegebenen Funktionen implementiert wurden.\n\n\n__construct()\n\n\nDiese Funktion wird jedes mal aufgerufen, wenn eine Instanz des Plugins erstellt wird. Hier wird ein Objekt der sciebo Klasse des Admin tools erzeugt, das als Parameter eine returnurl \u00fcbergeben bekommt.\n\n\n$returnurl = new moodle_url('/repository/repository_callback.php', [\n    'callback'  =\n 'yes',\n    'repo_id'   =\n $repositoryid,\n    'sesskey'   =\n sesskey(),\n]);\n$this-\nsciebo = new sciebo($returnurl);\n\n\n\n\nDer \ncallback url\n werden als Parameter noch zus\u00e4tzlich die id und der sesskey \u00fcbergeben, damit die Sitzung nach der Authentifizierung in ownCloud wieder hergestellt werden kann.\n\n\nDes weiteren wird die Parent Methode aufgerufen, die die n\u00f6tigen Datenbankeintr\u00e4ge t\u00e4tigt.\n\n\nget_file()\n\n\nDiese Funktion stellt eine Schnittstelle zum oauht2 Objekt des Admin tools bereit. Die Funktion \u00fcberpr\u00fcft ob schon eine offene Verbindung besteht mit Hilfe der Methode \nsciebo-\ndav-\nopen()\n. Falls keine Verbindung besteht wird die Funktion \n$this-\nsciebo-\nget_file();\n aufgerufen. Die Funktion \u00e4hnelt sehr der Funktion des \nWebDAV Repository\n, statt Basic Authentication wird jedoch das OAuth2 Protokoll benutzt. Danach wird der Nutzer  mit Hilfe der \nlogout()\n Funktion ausgeloggt. Dies erfolgt auch \u00fcber das Admin tool.\n\n\nget_listing()\n\n\nDiese Funktion wird aufgerufen um im File Picker die verf\u00fcgbaren Dateien anzuzeigen. Als R\u00fcckgabe wird ein Array aller verf\u00fcgbaren Dateien mit spezifischen Informationen \u00fcber diese Dateien erwartet. Bis auf die Authentifizierung funktioniert diese Methode genauso wie die Methode des WebDAV Repository. Am Anfang werden noch grundlegende Einstellungen f\u00fcr die Ansicht definiert:\n\n\n$ret['dynload'] = true;\n\n\n\n\nDies best\u00e4tigt dem File Picker, dass Inhalte dynamisch geladen werden. Das hei\u00dft das wenn z.B. ein Ordner angeklickt wird der File Picker einen Ajax-Request versendet um den Inhalt des Ordners anzeigen zu k\u00f6nnen.\n\n\n$ret['nosearch'] = true;\n\n\n\n\nDieser Parameter verbietet die Suche in den Dateien.\n\n\n$ret['nologin'] = false;\n\n\n\n\nDieser Parameter sorgt daf\u00fcr, dass der Login f\u00fcr jede Instanz notwendig ist. Zus\u00e4tzlich wird dadurch automatisch ein Logout-Button im File Picker generiert.\n\n\nMit Hilfe der sciebo Klasse wird \u00fcberpr\u00fcft ob es sich um eine Datei oder einen Ordner handelt.\n\n\nif (!empty($v['resourcetype']) \n $v['resourcetype'] == 'collection') {\n    // A folder.\n    if ($path != $v['href']) {\n        $folders[strtoupper($title)] = array(\n            'title' =\n rtrim($title, '/'),\n            'thumbnail' =\n $OUTPUT-\npix_url(file_folder_icon(90))-\nout(false),\n            'children' =\n array(),\n            'datemodified' =\n $v['lastmodified'],\n            'path' =\n $v['href']\n        );\n    }\n\n\n\n\nFalls es sich um einen Ordner handelt wird der Titel, ein Ordner als Bild, der Pfad zum Ordner und der Zeitpunkt des letzten Zugriffs gespeichert.\n\n\n} else {\n    // A file.\n    $size = !empty($v['getcontentlength']) ? $v['getcontentlength'] : '';\n    $files[strtoupper($title)] = array(\n        'title' =\n $title,\n        'thumbnail' =\n $OUTPUT-\npix_url(file_extension_icon($title, 90))-\nout(false),\n        'size' =\n $size,\n        'datemodified' =\n $v['lastmodified'],\n        'source' =\n $v['href']\n    );\n}\n\n\n\n\nFalls es sich um eine Datei handelt wird zus\u00e4tzlich zu den oben genannten Informationen noch die Datei Gr\u00f6\u00dfe gespeichert.\n\n\nMit Hilfe einer \nforeach()\n Schleife wird dies f\u00fcr jede Datei durchgef\u00fchrt. Anschlie\u00dfend werden zuerst Ordner und danach alphabetisch sortiert die Dateien in einem Array gespeichert. Diese Array wird von der Funktion wiedergegeben, Moodle platziert nun die entsprechenden Eintr\u00e4ge im File Picker.\n\n\nget_link()\n\n\nAnstelle einer Datei soll es auch m\u00f6glich sein, einen Downloadlink zu einer existierenden Datei bereitzustellen. Diese wird von dem Modul URL genutzt. Zus\u00e4tzlich besteht die M\u00f6glichkeit im File Picker Dateien zu verlinken. Die zweite Option erlauben wir in unserem Plugin nicht, da uns die Zeit fehlte die zus\u00e4tzliche Funktionalit\u00e4t zu implementieren. Dies haben wir in der Methode \nsupported_returntypes()\n ausgeschlossen.\nDie Implementierung der \nget_link()\n Methode ist nicht trivial da sich der Link abh\u00e4ngig von den Einstellungen im Admin Tool \u00e4ndert.\nMit Hilfe der Funktion \nget_config()\nk\u00f6nnen in Moodle Einstellungen spezifischer Plugins ausgelesen werden. In der Methode wird wiederum die Methode \nget_link()\n des Objektes \nsciebo\n aufgerufen. Um den funktionierenden Downloadlink zur\u00fcck zu geben muss nun noch der Pr\u00e4fix und die Serveraddresse vor den zur\u00fcckgegebenen Pfad gesetzt werden. Desweiteren wird hinter den Pfad noch \n'public.php?service=files\nt=' . $fileid . '\ndownload'\n angef\u00fcgt. Dies ist eine ownCloud spezifische Implementation einen Downloadlink zu generieren. Hier finden sie genauere Informationen zur \nownCloud external API\n.\n\n\npublic function get_link($url) {\n\n    $pref = get_config('tool_oauth2sciebo', 'type') . '://';\n\n    $output = $this-\nsciebo-\nget_link($url);\n    $xml = simplexml_load_string($output);\n    $fields = explode(\n/s/\n, $xml-\ndata[0]-\nurl[0]);\n    $fileid = $fields[1];\n\n    $path = str_replace('remote.php/dav/', '', get_config('tool_oauth2sciebo', 'path'));\n\n    return $pref . get_config('tool_oauth2sciebo', 'server'). '/' . $path .\n            'public.php?service=files\nt=' . $fileid . '\ndownload';\n}\n\n\n\n\nprint_login()\n\n\nUm einen Benutzer zum ersten mal mit dem OAuth 2.0 Protokoll anmelden zu k\u00f6nnen, muss er einmalig seinen Benutzer Namen und sein Passwort angeben. Sobald der Nutzer auf den Login Button klickt erscheint ein Pop-up Window oder es \u00f6ffnet sich ein neuer Tab im Browser, indem der Nutzer aufgefordert wird seinen Namen und sein Passwort anzugeben.\n\n\n    $url = $this-\nsciebo-\nget_login_url();\n    if ($this-\noptions['ajax']) {\n        $ret = array();\n        $btn = new \\stdClass();\n        $btn-\ntype = 'popup';\n        $btn-\nurl = $url-\nout(false);\n        $ret['login'] = array($btn);\n        return $ret;\n    } else {\n        echo html_writer::link($url, get_string('login', 'repository'), array('target' =\n '_blank'));\n    }\n\n\n\n\nAls N\u00e4chstes muss der Benutzer die App autorisieren. Nun wird er zu Moodle zur\u00fcckgeleitet. Die Funktion wird nur aufgerufen, falls der Nutzer weder mit seinem token noch mit einem refreshtoken authentifiziert werden kann.\n\n\nRepository spezifische Einstellungen\n\n\nF\u00fcr Repository Plugins gibt es einige Einstellungen die hart kodiert sind und sich nicht auf der Website anpassen lassen. Hierzu geh\u00f6ren folgende Funktionen:\n\n\n\n\nsupported_returntypes()\n  m\u00f6gliche R\u00fcckgabetypen sind:\n\n\nFILE_INTERNAL\n: Dateien d\u00fcrfen im Moodle Dateien System hoch und runtergeladen werden.\n\n\nFILE_EXTERNAL\n: Dateien bleiben im externen Repository und werden von dort bezogen.\n\n\nFILE_REFERENCE\n: Dateien werden lokal erstellt, aber werden extern synchronisiert wenn notwendig.\n\n\n\n\n\n\n\n\nWir haben \nFILE_INTERNAL\n und \nFILE_EXTERNAL\n erlaubt, da die Synchronisation von Dateien einen zu gro\u00dfen Implementationsaufwand f\u00fcr unser Projektseminar darstellte.\n\n\n\n\nsupported_filetypes()\n  hier wird spezifiziert welche Arten von Dateitypen unterst\u00fctzt werden. Wir haben alle Dateitypen erlaubt.\n\n\n\n\nImplementierung der \ndb/access.php\n\n\nStandardm\u00e4\u00dfig muss nur eine \ncapability\n in einem Repository-Plugin definiert werden. Diese hei\u00dft \nview capability\n und beschreibt wer das Repository sehen darf, sobald es vom Site Admin freigegeben und aktiviert wurde.\n\n\n$capabilities = array(\n    'repository/sciebo:view' =\n array(\n        'captype' =\n 'read',\n        'contextlevel' =\n CONTEXT_MODULE,\n        'archetypes' =\n array(\n            'user' =\n CAP_ALLOW\n        )\n    )\n);\n\n\n\n\nIn unserem Fall darf jeder Nutzer das Repository sehen.\n\n\nBesonderheiten der \nversion.php\n\n\nUm sicherzustellen, dass die Authentifizierung korrekt abl\u00e4uft muss das admin-tool oauth2sciebo installiert sein. Dies wird sichergestellt indem in der \nversion.php\n eine Abh\u00e4ngigkeit gesetzt wird:\n\n\n$plugin-\ndependencies = array(\n    'tool_oauth2sciebo' =\n ANY_VERSION);\n\n\n\n\nF\u00fcr genauere Informationen zu der version.php in Moodle sehen sie sich hier die offizielle Dokumentation der \nversion.php\n an.\n\n\nTests und Continuous Integration", 
            "title": "Repository"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#repository-owncloud", 
            "text": "", 
            "title": "Repository: owncloud"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#zweck", 
            "text": "Der Plugin Typ  Repository  wird in Moodle unter anderem verwendet um Nutzer die M\u00f6glichkeit zu schaffen Zugang zu Dateien aus externen Quellen zu bekommen. Das Repository Plugin ownCloud kann somit folgende Integrationsszenarien realisieren:   Als  Nutzer  m\u00f6chte ich in der Dateiauswahl in Moodle eine Datei aus meiner ownCloud Instanz  hochladen .  Als  Nutzer  m\u00f6chte ich in der Dateiauswahl in Moodle eine Datei aus meiner ownCloud Instanz  verlinken .   Unser Plugin soll dem Administrator der Seite erm\u00f6glichen das Repository zu aktivieren und zu deaktivieren.\nAlle Nutzer der Moodle Instanz sollen mit Hilfe des Plugins sind in ownCloud authentifizieren k\u00f6nnen. Danach sollen sie in Moodle bequem zwischen Ihren Dateien w\u00e4hlen k\u00f6nnen und sich mit verschiedenen Accounts authentifizieren k\u00f6nnen. Besonders im Vordergrund steht das unser Plugin m\u00f6glichst einfach zu bedienen ist, um die Benutzerfreundlichkeit zu erh\u00f6hen.", 
            "title": "Zweck"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#vorgegebene-schnittstelle", 
            "text": "Wie auch im  Admin Tool  m\u00fcssen zun\u00e4chst einige Standartschnittstellen implementiert werden:   version.php :  Beschreibt die Versionsnummer des Plugins, die ben\u00f6tigte moodle Version und Abh\u00e4ngigkeiten des Plugins.  db/access.php :  Legt die Berechtigungen f\u00fcr definierte Aktionen innerhalb des Plugins anhand von Nutzerrollen fest.  lang/en/repository__sciebo.php :  Beinhaltet Sprachstrings f\u00fcr unterschiedliche Regionen und Sprachen, sodass definierte Strings,\nabh\u00e4ngig von der jeweiligen Sprache, dynamisch angezeigt werden k\u00f6nnen. Als Standard wird eine englische Sprachdatei erwartet.   F\u00fcr Repository-Plugins m\u00fcssen au\u00dferdem folgende Dateien implementiert werden:   pix/icon.png :  Hier wird ein 16x16 icon platziert, welches f\u00fcr das Plugin genutzt wird. Dies kann auch beliebig angepasst werden.  lib.php :  Hier wird eine Klasse  repository_sciebo extends repository  deklariert, die als Hauptaufgabe die Integration in den File Picker verwaltet.", 
            "title": "Vorgegebene Schnittstelle"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#implementierung", 
            "text": "Die WebDAV Zugriffe und der Ablauf des OAuth2.0 Verfahrens wird vom  oauth2owncloud_admin_tool  geregelt. Somit hat das  Repository  niemals Zugriff auf den Login-Status oder den  Access Token . Falls Konfigurationen des  Admin Tool  fehlen, ist das  Repository  nicht mehr verf\u00fcgbar.", 
            "title": "Implementierung"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#implementierung-der-libphp", 
            "text": "In der lib.php wird eine Klasse definiert die von der abstrakten Klasse  repository  erbt. Im Folgenden wird darauf eingegangen wie die vorgegebenen Funktionen implementiert wurden.", 
            "title": "Implementierung der lib.php"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#__construct", 
            "text": "Diese Funktion wird jedes mal aufgerufen, wenn eine Instanz des Plugins erstellt wird. Hier wird ein Objekt der sciebo Klasse des Admin tools erzeugt, das als Parameter eine returnurl \u00fcbergeben bekommt.  $returnurl = new moodle_url('/repository/repository_callback.php', [\n    'callback'  =  'yes',\n    'repo_id'   =  $repositoryid,\n    'sesskey'   =  sesskey(),\n]);\n$this- sciebo = new sciebo($returnurl);  Der  callback url  werden als Parameter noch zus\u00e4tzlich die id und der sesskey \u00fcbergeben, damit die Sitzung nach der Authentifizierung in ownCloud wieder hergestellt werden kann.  Des weiteren wird die Parent Methode aufgerufen, die die n\u00f6tigen Datenbankeintr\u00e4ge t\u00e4tigt.", 
            "title": "__construct()"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#get_file", 
            "text": "Diese Funktion stellt eine Schnittstelle zum oauht2 Objekt des Admin tools bereit. Die Funktion \u00fcberpr\u00fcft ob schon eine offene Verbindung besteht mit Hilfe der Methode  sciebo- dav- open() . Falls keine Verbindung besteht wird die Funktion  $this- sciebo- get_file();  aufgerufen. Die Funktion \u00e4hnelt sehr der Funktion des  WebDAV Repository , statt Basic Authentication wird jedoch das OAuth2 Protokoll benutzt. Danach wird der Nutzer  mit Hilfe der  logout()  Funktion ausgeloggt. Dies erfolgt auch \u00fcber das Admin tool.", 
            "title": "get_file()"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#get_listing", 
            "text": "Diese Funktion wird aufgerufen um im File Picker die verf\u00fcgbaren Dateien anzuzeigen. Als R\u00fcckgabe wird ein Array aller verf\u00fcgbaren Dateien mit spezifischen Informationen \u00fcber diese Dateien erwartet. Bis auf die Authentifizierung funktioniert diese Methode genauso wie die Methode des WebDAV Repository. Am Anfang werden noch grundlegende Einstellungen f\u00fcr die Ansicht definiert:  $ret['dynload'] = true;  Dies best\u00e4tigt dem File Picker, dass Inhalte dynamisch geladen werden. Das hei\u00dft das wenn z.B. ein Ordner angeklickt wird der File Picker einen Ajax-Request versendet um den Inhalt des Ordners anzeigen zu k\u00f6nnen.  $ret['nosearch'] = true;  Dieser Parameter verbietet die Suche in den Dateien.  $ret['nologin'] = false;  Dieser Parameter sorgt daf\u00fcr, dass der Login f\u00fcr jede Instanz notwendig ist. Zus\u00e4tzlich wird dadurch automatisch ein Logout-Button im File Picker generiert.  Mit Hilfe der sciebo Klasse wird \u00fcberpr\u00fcft ob es sich um eine Datei oder einen Ordner handelt.  if (!empty($v['resourcetype'])   $v['resourcetype'] == 'collection') {\n    // A folder.\n    if ($path != $v['href']) {\n        $folders[strtoupper($title)] = array(\n            'title' =  rtrim($title, '/'),\n            'thumbnail' =  $OUTPUT- pix_url(file_folder_icon(90))- out(false),\n            'children' =  array(),\n            'datemodified' =  $v['lastmodified'],\n            'path' =  $v['href']\n        );\n    }  Falls es sich um einen Ordner handelt wird der Titel, ein Ordner als Bild, der Pfad zum Ordner und der Zeitpunkt des letzten Zugriffs gespeichert.  } else {\n    // A file.\n    $size = !empty($v['getcontentlength']) ? $v['getcontentlength'] : '';\n    $files[strtoupper($title)] = array(\n        'title' =  $title,\n        'thumbnail' =  $OUTPUT- pix_url(file_extension_icon($title, 90))- out(false),\n        'size' =  $size,\n        'datemodified' =  $v['lastmodified'],\n        'source' =  $v['href']\n    );\n}  Falls es sich um eine Datei handelt wird zus\u00e4tzlich zu den oben genannten Informationen noch die Datei Gr\u00f6\u00dfe gespeichert.  Mit Hilfe einer  foreach()  Schleife wird dies f\u00fcr jede Datei durchgef\u00fchrt. Anschlie\u00dfend werden zuerst Ordner und danach alphabetisch sortiert die Dateien in einem Array gespeichert. Diese Array wird von der Funktion wiedergegeben, Moodle platziert nun die entsprechenden Eintr\u00e4ge im File Picker.", 
            "title": "get_listing()"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#get_link", 
            "text": "Anstelle einer Datei soll es auch m\u00f6glich sein, einen Downloadlink zu einer existierenden Datei bereitzustellen. Diese wird von dem Modul URL genutzt. Zus\u00e4tzlich besteht die M\u00f6glichkeit im File Picker Dateien zu verlinken. Die zweite Option erlauben wir in unserem Plugin nicht, da uns die Zeit fehlte die zus\u00e4tzliche Funktionalit\u00e4t zu implementieren. Dies haben wir in der Methode  supported_returntypes()  ausgeschlossen.\nDie Implementierung der  get_link()  Methode ist nicht trivial da sich der Link abh\u00e4ngig von den Einstellungen im Admin Tool \u00e4ndert.\nMit Hilfe der Funktion  get_config() k\u00f6nnen in Moodle Einstellungen spezifischer Plugins ausgelesen werden. In der Methode wird wiederum die Methode  get_link()  des Objektes  sciebo  aufgerufen. Um den funktionierenden Downloadlink zur\u00fcck zu geben muss nun noch der Pr\u00e4fix und die Serveraddresse vor den zur\u00fcckgegebenen Pfad gesetzt werden. Desweiteren wird hinter den Pfad noch  'public.php?service=files t=' . $fileid . ' download'  angef\u00fcgt. Dies ist eine ownCloud spezifische Implementation einen Downloadlink zu generieren. Hier finden sie genauere Informationen zur  ownCloud external API .  public function get_link($url) {\n\n    $pref = get_config('tool_oauth2sciebo', 'type') . '://';\n\n    $output = $this- sciebo- get_link($url);\n    $xml = simplexml_load_string($output);\n    $fields = explode( /s/ , $xml- data[0]- url[0]);\n    $fileid = $fields[1];\n\n    $path = str_replace('remote.php/dav/', '', get_config('tool_oauth2sciebo', 'path'));\n\n    return $pref . get_config('tool_oauth2sciebo', 'server'). '/' . $path .\n            'public.php?service=files t=' . $fileid . ' download';\n}", 
            "title": "get_link()"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#print_login", 
            "text": "Um einen Benutzer zum ersten mal mit dem OAuth 2.0 Protokoll anmelden zu k\u00f6nnen, muss er einmalig seinen Benutzer Namen und sein Passwort angeben. Sobald der Nutzer auf den Login Button klickt erscheint ein Pop-up Window oder es \u00f6ffnet sich ein neuer Tab im Browser, indem der Nutzer aufgefordert wird seinen Namen und sein Passwort anzugeben.      $url = $this- sciebo- get_login_url();\n    if ($this- options['ajax']) {\n        $ret = array();\n        $btn = new \\stdClass();\n        $btn- type = 'popup';\n        $btn- url = $url- out(false);\n        $ret['login'] = array($btn);\n        return $ret;\n    } else {\n        echo html_writer::link($url, get_string('login', 'repository'), array('target' =  '_blank'));\n    }  Als N\u00e4chstes muss der Benutzer die App autorisieren. Nun wird er zu Moodle zur\u00fcckgeleitet. Die Funktion wird nur aufgerufen, falls der Nutzer weder mit seinem token noch mit einem refreshtoken authentifiziert werden kann.", 
            "title": "print_login()"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#repository-spezifische-einstellungen", 
            "text": "F\u00fcr Repository Plugins gibt es einige Einstellungen die hart kodiert sind und sich nicht auf der Website anpassen lassen. Hierzu geh\u00f6ren folgende Funktionen:   supported_returntypes()   m\u00f6gliche R\u00fcckgabetypen sind:  FILE_INTERNAL : Dateien d\u00fcrfen im Moodle Dateien System hoch und runtergeladen werden.  FILE_EXTERNAL : Dateien bleiben im externen Repository und werden von dort bezogen.  FILE_REFERENCE : Dateien werden lokal erstellt, aber werden extern synchronisiert wenn notwendig.     Wir haben  FILE_INTERNAL  und  FILE_EXTERNAL  erlaubt, da die Synchronisation von Dateien einen zu gro\u00dfen Implementationsaufwand f\u00fcr unser Projektseminar darstellte.   supported_filetypes()   hier wird spezifiziert welche Arten von Dateitypen unterst\u00fctzt werden. Wir haben alle Dateitypen erlaubt.", 
            "title": "Repository spezifische Einstellungen"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#implementierung-der-dbaccessphp", 
            "text": "Standardm\u00e4\u00dfig muss nur eine  capability  in einem Repository-Plugin definiert werden. Diese hei\u00dft  view capability  und beschreibt wer das Repository sehen darf, sobald es vom Site Admin freigegeben und aktiviert wurde.  $capabilities = array(\n    'repository/sciebo:view' =  array(\n        'captype' =  'read',\n        'contextlevel' =  CONTEXT_MODULE,\n        'archetypes' =  array(\n            'user' =  CAP_ALLOW\n        )\n    )\n);  In unserem Fall darf jeder Nutzer das Repository sehen.", 
            "title": "Implementierung der db/access.php"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#besonderheiten-der-versionphp", 
            "text": "Um sicherzustellen, dass die Authentifizierung korrekt abl\u00e4uft muss das admin-tool oauth2sciebo installiert sein. Dies wird sichergestellt indem in der  version.php  eine Abh\u00e4ngigkeit gesetzt wird:  $plugin- dependencies = array(\n    'tool_oauth2sciebo' =  ANY_VERSION);  F\u00fcr genauere Informationen zu der version.php in Moodle sehen sie sich hier die offizielle Dokumentation der  version.php  an.", 
            "title": "Besonderheiten der version.php"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#tests-und-continuous-integration", 
            "text": "", 
            "title": "Tests und Continuous Integration"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/", 
            "text": "Aktivit\u00e4t: \ncollaborative folders\n\n\nZweck\n\n\nDas Aktivit\u00e4ts Modul \nCollaborative Folders\n soll Lehrenden die M\u00f6glichkeit geben, f\u00fcr Studierende oder Gruppen von Studierenden Ordner f\u00fcr kollaboratives Arbeiten zu erstellen.\nDie Autorisierung und Authentifizierung erfolgt \u00fcber das \noauth2sciebo admin_tool\n. Diese Aktivit\u00e4t \ncollaborativefolders\n implementiert das vierte Integrationsszenario:\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich Studierenden oder Gruppen von Studierenden Ordner f\u00fcr kollaboratives Arbeiten bereitstellen.\n\n\n\n\nIm Folgenden wird erkl\u00e4rt wozu einzelne Beteiligte des Integrationsszenario in der Lage sein m\u00fcssen.\nZun\u00e4chst ist es erforderlich einen neutralen Speicherort f\u00fcr die geteilten Ordner anzugeben. Falls der Lehrende keinen Zugriff auf die Ordner haben soll, d\u00fcrfen sie nicht in seiner Instanz gespeichert sein. Um die Privatsph\u00e4re der Kursteilnehmer zu sichern darf ein Lehrender nicht unter ihrem Namen Ordner erstellen. Aus diesem Grund haben wir unsere L\u00f6sung so implementiert, dass der Moodle Administrator einen technischen Nutzer festlegen kann. In dessen Namen werden alle Ordner erstellt.\n\n\nDer Lehrende soll in der Lage sein einem Kurs beliebig viele Instanzen der Aktivit\u00e4t \nCollaborative Folders\n hinzuzuf\u00fcgen. In den Einstellungen kann der Lehrende nun festlegen wie der Ordner im Moodle Kurs benannt werden soll. Au\u00dferdem kann der Lehrende entscheiden ob er Zugriff auf die Ordner bekommt.\n\n\nKursteilnehmer sollen den Ordner in ihre eigene ownCloud Instanz kopieren k\u00f6nnen. Dabei sollen sie dem Ordner einen eigenen Namen geben k\u00f6nnen.\n\n\nMit dieser Aktivit\u00e4t kann der Lehrende Kursteilnehmer ermutigen kollaborativ zu arbeiten. Zus\u00e4tzlich hat er die Option die laufende Arbeit zu betreuen, indem er sich selbst Zugriff auf die Ordner gew\u00e4hrt. In diesem Fall werden die Kursteilnehmer dar\u00fcber in Kenntnis gesetzt, dass der Ordner den Lehrenden zug\u00e4nglich ist.\n\n\nKursteilnehmer haben weniger Organisationsaufwand und werden bei ihrer Gruppenarbeit unterst\u00fctzt. Zus\u00e4tzlich muss kein Kursteilnehmer eigenen Speicherplatz zur Verf\u00fcgung stellen.\n\n\nVorgegebene Schnittstelle\n\n\nUm das Integrationsszenario zu realisieren haben wir ein Activity Plugin f\u00fcr Moodle entwickelt. Instanzen von Activity Plugins k\u00f6nnen Kursen beliebig oft hinzugef\u00fcgt werden.\nF\u00fcr genauere Informationen besuchen sie die Moodle Dokumentation von \nActivity modules\n\nIn der \ncollaborativefolders/mod_form.php\n werden alle Einstellungen abgefragt, die vor dem Erstellen der Ordner bekannt sein m\u00fcssen. Dies beinhaltet den Namen des Ordners in Moodle, Zugriff des Lehrenden auf die erstellten Ordner und ob f\u00fcr Gruppen separate Ordner erzeugt werden sollen.\nIn der \ncollaborativefolders/settings.php\n kann der Administrator den technischen Nutzer des Plugins festlegen. Dieser gilt f\u00fcr alle Instanzen, also global f\u00fcr das gesammte Plugin.\nDie \ncollaborativefolders/lib.php\n bietet eine Schnittstelle um auf das Hinzuf\u00fcgen, \u00c4ndern und L\u00f6schen von Instanzen zu reagieren.\n\n\nImplementierung\n\n\nAnmelden des technischen Nutzers\n\n\nDer Admin der Moodle Seite kann in der Seiten-Administration einen technischen Nutzer hinzuf\u00fcgen. \u00dcber \nWebsite-Administration \u25ba Plugins \u25ba Aktivit\u00e4ten \u25ba collaborativefolders\n kommt er zu den passenden Einstellungen. Dort wird er durch einen Login-Button auf die ownCloud Seite zum Autorisieren der App weitergeleitet. Sp\u00e4tere \u00c4nderungen des technischen Nutzers sind durch einen Logout Button m\u00f6glich. Dies ist nicht empfohlen und mit einer Warnmeldung versehen, da Kompilierungs-Probleme mit bestehenden Instanzen entstehen w\u00fcrden. Wir haben uns daf\u00fcr entschieden den Logout trotzdem bereitzustellen, f\u00fcr den Fall, dass ein falscher Account authentifiziert wurde. Hierbei sind wir insbesondere auf folgendes Szenario gesto\u00dfen:\n\n\nDer Seiten Administrator will den technischen Nutzer einloggen, ist aber noch mit seinem eigenen ownCloud Account oder dem Administrator Account der ownCloud authentifiziert. Er bemerkt nicht, dass er mit dem falschen Account eingeloggt ist und autorisiert das Plugin. Als er seinen Fehler bemerkt, m\u00f6chte er den technischen Nutzer so schnell wie m\u00f6glich \u00e4ndern, obwohl bestehende Instanzen neu erstellt werden m\u00fcssen.\n\n\nImplementiert haben wir dies in der \ncollaborativefolders/settings.php\n. Diese erstellt eine Seite in den Admin Settings der Moodle Instanz. Hier m\u00fcssen drei verschiedene F\u00e4lle beachtet werden:\n\n\n\n\n\n\nDer technische Nutzer ist bereits angemeldet, soll aber die M\u00f6glichkeit haben ausgeloggt zu werden.\n\n    Die \ncheck_login()\n Methode des \noauth2_owncloud\n Plugins \u00fcberpr\u00fcft ob ein technischer Nutzer registriert ist. Falls der Nutzer angemeldet ist, kann der Administrator den Nutzer mit einem Logout-Button ausloggen. Dieser leitet den Nutzer auf eine neue Seite. Diese enth\u00e4lt eine Warnung da alte Instanzen des Plugins nicht l\u00e4nger genutzt werden k\u00f6nnen wenn der technische Nutzer ge\u00e4ndert wird.\n\n\n\n\n\n\nDer technische Nutzer wird erstmals registriert.\n\n\nDas Token des technischen Nutzers wird f\u00fcr das Plugin in den \nconfig\n Einstellungen gespeichert, da es zu keinem Nutzer, aber zu dem Plugin, geh\u00f6rt. Zur Sicherheit wird ist dieses auf null gesetzt. Dem Admin wird ein Login-Button angezeigt. Die Speicherung des Tokens erfolgt durch den \ncallback\n des OAuth 2.0 Protokolls.\n\n\n\n\n\n\nDer technische Nutzer soll ausgeloggt werden.\n\n\nDem Administrator wird dasselbe Login Fenster angezeigt wie bei der erstmaligen Registrierung. Genauso wird der bisherige \naccess token\n gel\u00f6scht. Zus\u00e4tzlich wird jedoch ein \nlogoutevent\n ausgel\u00f6st. Dieses Event wird geloggt, damit der Vorgang sp\u00e4ter nachverfolgt werden kann.\n\n\n\n\n\n\n    $logoutevent = \\mod_collaborativefolders\\event\\technical_user_loggedout::create($params);\n    $logoutevent-\ntrigger();\n\n\n\n\nHinzuf\u00fcgen einer Instanz\n\n\nDie Schnittstelle in Moodle f\u00fcr das Einstellungsformular ist sehr ausf\u00fchrlich. Den Standardeinstellungen haben wurde nur eine Checkbox hinzugef\u00fcgt die bestimmt, ob der Lehrende Zugriff auf die Ordner hat.\nAu\u00dferdem benutzen wird den Moodle internen \ngroup_mode\n. Dieser erm\u00f6glicht es Gruppen separat zu bearbeiten. Wie f\u00fcr separate Gruppen Ordner erstellt werden  wird unter anderem im n\u00e4chsten Abschnitt erkl\u00e4rt, der sich mit dem Erstellen von Ordnern auseinander setzt. Falls sie mehr Informationen zu der \nmod_form.php\n in Moodle ben\u00f6tigen besuchen sie \ndiese Seite\n.\n\n\nErstellen von Ordnern\n\n\nZum Erstellen von Ordnern wurde ein Observer implementiert, der aufgerufen wird wenn eine Instanz der Aktivit\u00e4t \ncollaborativefolders\n erstellt wird.\nIn \ncollaborativefolders/db/events.php\n k\u00f6nnen in einem Array alle Observer registriert werden und werden dann von Moodle verwaltet.\n\n\n$observers = array(\n        array(\n                // Zuerst wird das Event, dass beobachtet werden soll festgelegt.\n                'eventname'   =\n '\\core\\event\\course_module_created',\n                // Als n\u00e4chstes wird der Observer festgelegt.\n                'callback'    =\n 'mod_collaborativefolders\\observer::collaborativefolders_created',\n                'internal'  =\n false,\n                'priority'  =\n 1000\n        )\n\n);\n\n\n\n\nSomit wird, sobald das Event \ncourse_module_created\n erzeugt wird, der Observer aufgerufen. Es gibt zwei Hauptgr\u00fcnde warum dies erforderlich ist. Zun\u00e4chst ben\u00f6tigt man f\u00fcr das Erstellen der Ordner die \ncourse_module_id\n. Diese ist nur verf\u00fcgbar wenn die Instanz schon erstellt wurde, somit kann nicht die Schnittstelle der \ncollaborativefolders/lib.php\n \nadd_instance()\n genutzt werden. Desweiteren ruft unser Observer einen CronJob auf. Dieser sorgt daf\u00fcr, dass Ordner zeitlich verz\u00f6gert erstellt werden, wodurch der Server nicht kurzzeitig \u00fcberlastet wird. Falls Ordner f\u00fcr gro\u00dfe Kurse mit \u00fcber 50 Gruppen erstellt werden sollen k\u00f6nnte es hier sonst zu Schwierigkeiten kommen.\nBeim Erstellen m\u00fcssen zwei unterschiedliche Szenarien betrachtet werden:\n\n\nIm ersten Szenario wird ein Ordner f\u00fcr alle Studierenden eines Kurses erstellt.\nDie Anforderung an das Modul ist es also einen Ordner in dem gespeicherten Account zu erstellen, der eindeutig identifizierbar ist. Dies ist gesichert indem die Ordner nach der \ncourse_module_id\n benannt werden. Diese ist einzigartig f\u00fcr jede Aktivit\u00e4t, die in Moodle erzeugt wird. So kann es, soweit manuell\nkeine Ordner erstellt werden, zu keinen Synchronisationskonflikten kommen.\n\n\n$paths = array();\n            $paths['cmid'] = $cmid;\n\n            list ($course, $cm) = get_course_and_cm_from_cmid($cmid, 'collaborativefolders');\n\n\n\n\nIm zweiten Szenario sollen Ordner f\u00fcr Gruppen innerhalb eines Kurses erstellt werden.\nAuch hier m\u00fcssen eindeutig identifizierbare Ordner erstellt werden. Deswegen wird ein \u00dcberordner erstellt mit der \ncourse_module_id\n. In diesem Ordner wird nun zu jeder Gruppe ein Unterordner erstellt.\n\n\nif (groups_get_activity_groupmode($cm) != 0) {\n    $grid = $cm-\ngroupingid;\n    $groups = groups_get_all_groups($course-\nid, 0, $grid);\n\n    foreach ($groups as $group) {\n        $path = $cmid . '/' . $group-\nid;\n        $paths[$group-\nid] = $path;\n    }\n}\n\n\n\n\nZu diesem Zweck wird in der Variable \n$path\n die einem Cronjob \u00fcbergeben wird nicht nur die \ncourse_module_id\n gespeichert, sondern auch f\u00fcr jede \n$groupid\n ein Feld.\nDer Cronjob, der nun die Ordner erstellt, kann anhand der Eintr\u00e4ge im Array erkennen wie viele und welche Ordner er erstellen muss.\n\n\nDer Cronjob findet sich in \ncollaborativefolders/classes/task/collaborativefolders_create.php\n. Er erbt von der abstrakten Klasse \n\\core\\task\\adhoc_task\n.\nDieser liest aus den Daten, die er \u00fcbergeben bekommt, alle Ordner aus, die erstellt werden m\u00fcssen.\n\n\nforeach ($data as $key =\n $value) {\n            $code = $oc-\nhandle_folder('make', $value);\n            if ($code == false) {\n                throw new \\coding_exception('Folder ' . $value . ' not created.');\n            } else {\n                mtrace('Folder: ' . $value . ', Code: ' . $code);\n                if (($code != 201) \n ($code != 405)) {\n                    throw new \\coding_exception('Folder ' . $value . ' not created.');\n                }\n            }\n        }\n\n\n\n\nAnsicht der bestehenden Instanzen\n\n\nNun, da der Lehrende alle notwendigen Einstellungen t\u00e4tigen konnte, musste die Ansicht der Kursteilnehmer auf die Aktivit\u00e4t mit allen notwendigen Funktionalit\u00e4ten implementiert werden. Dies beinhaltet die individuelle Namensvergabe f\u00fcr Ordner in ownCloud und das Hinzuf\u00fcgen dieser Ordner zur eigenen Instanz.\nLehrende sollen entweder eine \u00dcbersicht aller Ordner haben, oder keinen Zugriff auf die Ordner haben. Alle Funktionalit\u00e4ten sind in der \nview.php\n implementiert.\n\n\nSicht der Studierenden\n\n\nF\u00fcr Studierende wird zun\u00e4chst \u00fcberpr\u00fcft, ob der \ngroup_mode\n aktiviert ist. Wenn dies der Fall ist, wird an den Pfad, \u00fcber den sp\u00e4ter der Ordner gefunden werden soll, die GruppenID angef\u00fcgt. Moodle hat hierf\u00fcr intern eine Methode \ngroups_get_activity_group()\n die zu einer Instanz der Aktivit\u00e4t angibt in welcher Gruppe der Studierende ist.\nDie \nview.php\n wird zu verschiedenen Zwecken aufgerufen die behandelt werden m\u00fcssen.\n\n\n\n\n\n\nDer Ordnername wird erstmals gespeichert\n\n\nDer Ordnername wird in den moodle \nuser_preferences\n gespeichert. Diese werden f\u00fcr jeden Nutzer einzeln gespeichert und k\u00f6nnen beliebig ge\u00e4ndert oder gel\u00f6scht werden. Die Eingabemaske f\u00fcr einen Ordnernamen wird nur angezeigt wenn bis jetzt kein Name gesetzt wurde oder der Nutzer explizit ausgew\u00e4hlt hat, das der Name zur\u00fcckgesetzt werden soll.\n\n\n\n\n\n\nDer Name des Ordners wird ge\u00e4ndert\n\n\nWenn der Name des Ordners zur\u00fcckgesetzt wird, wird ein URL Parameter \nreset=1\n an die URL \u00fcbergeben. In diesem Fall wird dem Kursteilnehmer eine Eingabemaske angezeigt. Diese ist als eigene Klasse in dem Ordner \ncollaborativefolders/classes\n implementiert. Sie erbt von der abstrakten Klasse \nmoodleform\n. Es muss nun sichergestellt werden das vergebene Namen kompatibel mit ownCloud sind. Moodle unterst\u00fctzt die zugelassenen Eingaben durch Begrenzung nach \nForm Element\n Regeln.\n\n\n$mform-\naddRule('namefield', get_string('err_alphanumeric', 'form'), 'alphanumeric', null, 'client');\n\n\nDiese Regel verbietet andere Eingaben zu speichern, als Buchstaben und Zahlen.\n\n\n\n\n\n\nDer Nutzer loggt sich aus seinem aktuell gespeichertem Account aus\n\n    Der Nutzer muss mit Hilfe des \noauth2owncloud\n admin_tools ausgeloggt werden, und der \naccess token\n wird auf null gesetzt.\n\n\n$ocs-\nowncloud-\nlog_out();\nset_user_preference('oC_token', null);\n\n\n\n\n\n\nKursteilnehmer rufen die Seite auf, obwohl die Ordner noch nicht vom CronJob erstellt wurden.\n\n\nF\u00fcr jeden Ordner wird \u00fcberpr\u00fcft, ob der Ordner schon erstellt wurde: Zur Information wird dem Nutzer angezeigt, dass die Ordner noch nicht erstellt wurden.\n\n\n$content = json_decode($element-\ncustomdata);\n$cmidoftask = $content-\ncmid;\nif ($id == $cmidoftask) {\n    $created = false;\n}\n\n\n\n\n\n\nSicht der Lehrenden\n\n\nFalls der Lehrende sich selbst keinen Zugriff gew\u00e4hrt hat, sieht er den Ordner auch nicht wenn er in einer Gruppe eingeschrieben ist. Hat der Lehrende Zugriff auf die Ordner, so sieht er eine tabellarische Auflistung aller bestehenden Ordner. Zus\u00e4tzlich kann er genau wie Studierende seinen ownCloud Account \u00e4ndern, den Namen des Ordners \u00e4ndern und Ordner per Klick der eigenen Instanz hinzuf\u00fcgen. In dem Fall, dass Gruppenordner erstellt wurden, wird dem Lehrenden der \u00dcberordner aller Gruppenordner hinzugef\u00fcgt.\n\n\nTests und Continuous Integration", 
            "title": "Collaborative Folders"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/#aktivitat-collaborative-folders", 
            "text": "", 
            "title": "Aktivit\u00e4t: collaborative folders"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/#zweck", 
            "text": "Das Aktivit\u00e4ts Modul  Collaborative Folders  soll Lehrenden die M\u00f6glichkeit geben, f\u00fcr Studierende oder Gruppen von Studierenden Ordner f\u00fcr kollaboratives Arbeiten zu erstellen.\nDie Autorisierung und Authentifizierung erfolgt \u00fcber das  oauth2sciebo admin_tool . Diese Aktivit\u00e4t  collaborativefolders  implementiert das vierte Integrationsszenario:   Als  Lehrender  m\u00f6chte ich Studierenden oder Gruppen von Studierenden Ordner f\u00fcr kollaboratives Arbeiten bereitstellen.   Im Folgenden wird erkl\u00e4rt wozu einzelne Beteiligte des Integrationsszenario in der Lage sein m\u00fcssen.\nZun\u00e4chst ist es erforderlich einen neutralen Speicherort f\u00fcr die geteilten Ordner anzugeben. Falls der Lehrende keinen Zugriff auf die Ordner haben soll, d\u00fcrfen sie nicht in seiner Instanz gespeichert sein. Um die Privatsph\u00e4re der Kursteilnehmer zu sichern darf ein Lehrender nicht unter ihrem Namen Ordner erstellen. Aus diesem Grund haben wir unsere L\u00f6sung so implementiert, dass der Moodle Administrator einen technischen Nutzer festlegen kann. In dessen Namen werden alle Ordner erstellt.  Der Lehrende soll in der Lage sein einem Kurs beliebig viele Instanzen der Aktivit\u00e4t  Collaborative Folders  hinzuzuf\u00fcgen. In den Einstellungen kann der Lehrende nun festlegen wie der Ordner im Moodle Kurs benannt werden soll. Au\u00dferdem kann der Lehrende entscheiden ob er Zugriff auf die Ordner bekommt.  Kursteilnehmer sollen den Ordner in ihre eigene ownCloud Instanz kopieren k\u00f6nnen. Dabei sollen sie dem Ordner einen eigenen Namen geben k\u00f6nnen.  Mit dieser Aktivit\u00e4t kann der Lehrende Kursteilnehmer ermutigen kollaborativ zu arbeiten. Zus\u00e4tzlich hat er die Option die laufende Arbeit zu betreuen, indem er sich selbst Zugriff auf die Ordner gew\u00e4hrt. In diesem Fall werden die Kursteilnehmer dar\u00fcber in Kenntnis gesetzt, dass der Ordner den Lehrenden zug\u00e4nglich ist.  Kursteilnehmer haben weniger Organisationsaufwand und werden bei ihrer Gruppenarbeit unterst\u00fctzt. Zus\u00e4tzlich muss kein Kursteilnehmer eigenen Speicherplatz zur Verf\u00fcgung stellen.", 
            "title": "Zweck"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/#vorgegebene-schnittstelle", 
            "text": "Um das Integrationsszenario zu realisieren haben wir ein Activity Plugin f\u00fcr Moodle entwickelt. Instanzen von Activity Plugins k\u00f6nnen Kursen beliebig oft hinzugef\u00fcgt werden.\nF\u00fcr genauere Informationen besuchen sie die Moodle Dokumentation von  Activity modules \nIn der  collaborativefolders/mod_form.php  werden alle Einstellungen abgefragt, die vor dem Erstellen der Ordner bekannt sein m\u00fcssen. Dies beinhaltet den Namen des Ordners in Moodle, Zugriff des Lehrenden auf die erstellten Ordner und ob f\u00fcr Gruppen separate Ordner erzeugt werden sollen.\nIn der  collaborativefolders/settings.php  kann der Administrator den technischen Nutzer des Plugins festlegen. Dieser gilt f\u00fcr alle Instanzen, also global f\u00fcr das gesammte Plugin.\nDie  collaborativefolders/lib.php  bietet eine Schnittstelle um auf das Hinzuf\u00fcgen, \u00c4ndern und L\u00f6schen von Instanzen zu reagieren.", 
            "title": "Vorgegebene Schnittstelle"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/#implementierung", 
            "text": "", 
            "title": "Implementierung"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/#anmelden-des-technischen-nutzers", 
            "text": "Der Admin der Moodle Seite kann in der Seiten-Administration einen technischen Nutzer hinzuf\u00fcgen. \u00dcber  Website-Administration \u25ba Plugins \u25ba Aktivit\u00e4ten \u25ba collaborativefolders  kommt er zu den passenden Einstellungen. Dort wird er durch einen Login-Button auf die ownCloud Seite zum Autorisieren der App weitergeleitet. Sp\u00e4tere \u00c4nderungen des technischen Nutzers sind durch einen Logout Button m\u00f6glich. Dies ist nicht empfohlen und mit einer Warnmeldung versehen, da Kompilierungs-Probleme mit bestehenden Instanzen entstehen w\u00fcrden. Wir haben uns daf\u00fcr entschieden den Logout trotzdem bereitzustellen, f\u00fcr den Fall, dass ein falscher Account authentifiziert wurde. Hierbei sind wir insbesondere auf folgendes Szenario gesto\u00dfen:  Der Seiten Administrator will den technischen Nutzer einloggen, ist aber noch mit seinem eigenen ownCloud Account oder dem Administrator Account der ownCloud authentifiziert. Er bemerkt nicht, dass er mit dem falschen Account eingeloggt ist und autorisiert das Plugin. Als er seinen Fehler bemerkt, m\u00f6chte er den technischen Nutzer so schnell wie m\u00f6glich \u00e4ndern, obwohl bestehende Instanzen neu erstellt werden m\u00fcssen.  Implementiert haben wir dies in der  collaborativefolders/settings.php . Diese erstellt eine Seite in den Admin Settings der Moodle Instanz. Hier m\u00fcssen drei verschiedene F\u00e4lle beachtet werden:    Der technische Nutzer ist bereits angemeldet, soll aber die M\u00f6glichkeit haben ausgeloggt zu werden. \n    Die  check_login()  Methode des  oauth2_owncloud  Plugins \u00fcberpr\u00fcft ob ein technischer Nutzer registriert ist. Falls der Nutzer angemeldet ist, kann der Administrator den Nutzer mit einem Logout-Button ausloggen. Dieser leitet den Nutzer auf eine neue Seite. Diese enth\u00e4lt eine Warnung da alte Instanzen des Plugins nicht l\u00e4nger genutzt werden k\u00f6nnen wenn der technische Nutzer ge\u00e4ndert wird.    Der technische Nutzer wird erstmals registriert.  Das Token des technischen Nutzers wird f\u00fcr das Plugin in den  config  Einstellungen gespeichert, da es zu keinem Nutzer, aber zu dem Plugin, geh\u00f6rt. Zur Sicherheit wird ist dieses auf null gesetzt. Dem Admin wird ein Login-Button angezeigt. Die Speicherung des Tokens erfolgt durch den  callback  des OAuth 2.0 Protokolls.    Der technische Nutzer soll ausgeloggt werden.  Dem Administrator wird dasselbe Login Fenster angezeigt wie bei der erstmaligen Registrierung. Genauso wird der bisherige  access token  gel\u00f6scht. Zus\u00e4tzlich wird jedoch ein  logoutevent  ausgel\u00f6st. Dieses Event wird geloggt, damit der Vorgang sp\u00e4ter nachverfolgt werden kann.        $logoutevent = \\mod_collaborativefolders\\event\\technical_user_loggedout::create($params);\n    $logoutevent- trigger();", 
            "title": "Anmelden des technischen Nutzers"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/#hinzufugen-einer-instanz", 
            "text": "Die Schnittstelle in Moodle f\u00fcr das Einstellungsformular ist sehr ausf\u00fchrlich. Den Standardeinstellungen haben wurde nur eine Checkbox hinzugef\u00fcgt die bestimmt, ob der Lehrende Zugriff auf die Ordner hat.\nAu\u00dferdem benutzen wird den Moodle internen  group_mode . Dieser erm\u00f6glicht es Gruppen separat zu bearbeiten. Wie f\u00fcr separate Gruppen Ordner erstellt werden  wird unter anderem im n\u00e4chsten Abschnitt erkl\u00e4rt, der sich mit dem Erstellen von Ordnern auseinander setzt. Falls sie mehr Informationen zu der  mod_form.php  in Moodle ben\u00f6tigen besuchen sie  diese Seite .", 
            "title": "Hinzuf\u00fcgen einer Instanz"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/#erstellen-von-ordnern", 
            "text": "Zum Erstellen von Ordnern wurde ein Observer implementiert, der aufgerufen wird wenn eine Instanz der Aktivit\u00e4t  collaborativefolders  erstellt wird.\nIn  collaborativefolders/db/events.php  k\u00f6nnen in einem Array alle Observer registriert werden und werden dann von Moodle verwaltet.  $observers = array(\n        array(\n                // Zuerst wird das Event, dass beobachtet werden soll festgelegt.\n                'eventname'   =  '\\core\\event\\course_module_created',\n                // Als n\u00e4chstes wird der Observer festgelegt.\n                'callback'    =  'mod_collaborativefolders\\observer::collaborativefolders_created',\n                'internal'  =  false,\n                'priority'  =  1000\n        )\n\n);  Somit wird, sobald das Event  course_module_created  erzeugt wird, der Observer aufgerufen. Es gibt zwei Hauptgr\u00fcnde warum dies erforderlich ist. Zun\u00e4chst ben\u00f6tigt man f\u00fcr das Erstellen der Ordner die  course_module_id . Diese ist nur verf\u00fcgbar wenn die Instanz schon erstellt wurde, somit kann nicht die Schnittstelle der  collaborativefolders/lib.php   add_instance()  genutzt werden. Desweiteren ruft unser Observer einen CronJob auf. Dieser sorgt daf\u00fcr, dass Ordner zeitlich verz\u00f6gert erstellt werden, wodurch der Server nicht kurzzeitig \u00fcberlastet wird. Falls Ordner f\u00fcr gro\u00dfe Kurse mit \u00fcber 50 Gruppen erstellt werden sollen k\u00f6nnte es hier sonst zu Schwierigkeiten kommen.\nBeim Erstellen m\u00fcssen zwei unterschiedliche Szenarien betrachtet werden:  Im ersten Szenario wird ein Ordner f\u00fcr alle Studierenden eines Kurses erstellt.\nDie Anforderung an das Modul ist es also einen Ordner in dem gespeicherten Account zu erstellen, der eindeutig identifizierbar ist. Dies ist gesichert indem die Ordner nach der  course_module_id  benannt werden. Diese ist einzigartig f\u00fcr jede Aktivit\u00e4t, die in Moodle erzeugt wird. So kann es, soweit manuell\nkeine Ordner erstellt werden, zu keinen Synchronisationskonflikten kommen.  $paths = array();\n            $paths['cmid'] = $cmid;\n\n            list ($course, $cm) = get_course_and_cm_from_cmid($cmid, 'collaborativefolders');  Im zweiten Szenario sollen Ordner f\u00fcr Gruppen innerhalb eines Kurses erstellt werden.\nAuch hier m\u00fcssen eindeutig identifizierbare Ordner erstellt werden. Deswegen wird ein \u00dcberordner erstellt mit der  course_module_id . In diesem Ordner wird nun zu jeder Gruppe ein Unterordner erstellt.  if (groups_get_activity_groupmode($cm) != 0) {\n    $grid = $cm- groupingid;\n    $groups = groups_get_all_groups($course- id, 0, $grid);\n\n    foreach ($groups as $group) {\n        $path = $cmid . '/' . $group- id;\n        $paths[$group- id] = $path;\n    }\n}  Zu diesem Zweck wird in der Variable  $path  die einem Cronjob \u00fcbergeben wird nicht nur die  course_module_id  gespeichert, sondern auch f\u00fcr jede  $groupid  ein Feld.\nDer Cronjob, der nun die Ordner erstellt, kann anhand der Eintr\u00e4ge im Array erkennen wie viele und welche Ordner er erstellen muss.  Der Cronjob findet sich in  collaborativefolders/classes/task/collaborativefolders_create.php . Er erbt von der abstrakten Klasse  \\core\\task\\adhoc_task .\nDieser liest aus den Daten, die er \u00fcbergeben bekommt, alle Ordner aus, die erstellt werden m\u00fcssen.  foreach ($data as $key =  $value) {\n            $code = $oc- handle_folder('make', $value);\n            if ($code == false) {\n                throw new \\coding_exception('Folder ' . $value . ' not created.');\n            } else {\n                mtrace('Folder: ' . $value . ', Code: ' . $code);\n                if (($code != 201)   ($code != 405)) {\n                    throw new \\coding_exception('Folder ' . $value . ' not created.');\n                }\n            }\n        }", 
            "title": "Erstellen von Ordnern"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/#ansicht-der-bestehenden-instanzen", 
            "text": "Nun, da der Lehrende alle notwendigen Einstellungen t\u00e4tigen konnte, musste die Ansicht der Kursteilnehmer auf die Aktivit\u00e4t mit allen notwendigen Funktionalit\u00e4ten implementiert werden. Dies beinhaltet die individuelle Namensvergabe f\u00fcr Ordner in ownCloud und das Hinzuf\u00fcgen dieser Ordner zur eigenen Instanz.\nLehrende sollen entweder eine \u00dcbersicht aller Ordner haben, oder keinen Zugriff auf die Ordner haben. Alle Funktionalit\u00e4ten sind in der  view.php  implementiert.", 
            "title": "Ansicht der bestehenden Instanzen"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/#sicht-der-studierenden", 
            "text": "F\u00fcr Studierende wird zun\u00e4chst \u00fcberpr\u00fcft, ob der  group_mode  aktiviert ist. Wenn dies der Fall ist, wird an den Pfad, \u00fcber den sp\u00e4ter der Ordner gefunden werden soll, die GruppenID angef\u00fcgt. Moodle hat hierf\u00fcr intern eine Methode  groups_get_activity_group()  die zu einer Instanz der Aktivit\u00e4t angibt in welcher Gruppe der Studierende ist.\nDie  view.php  wird zu verschiedenen Zwecken aufgerufen die behandelt werden m\u00fcssen.    Der Ordnername wird erstmals gespeichert  Der Ordnername wird in den moodle  user_preferences  gespeichert. Diese werden f\u00fcr jeden Nutzer einzeln gespeichert und k\u00f6nnen beliebig ge\u00e4ndert oder gel\u00f6scht werden. Die Eingabemaske f\u00fcr einen Ordnernamen wird nur angezeigt wenn bis jetzt kein Name gesetzt wurde oder der Nutzer explizit ausgew\u00e4hlt hat, das der Name zur\u00fcckgesetzt werden soll.    Der Name des Ordners wird ge\u00e4ndert  Wenn der Name des Ordners zur\u00fcckgesetzt wird, wird ein URL Parameter  reset=1  an die URL \u00fcbergeben. In diesem Fall wird dem Kursteilnehmer eine Eingabemaske angezeigt. Diese ist als eigene Klasse in dem Ordner  collaborativefolders/classes  implementiert. Sie erbt von der abstrakten Klasse  moodleform . Es muss nun sichergestellt werden das vergebene Namen kompatibel mit ownCloud sind. Moodle unterst\u00fctzt die zugelassenen Eingaben durch Begrenzung nach  Form Element  Regeln.  $mform- addRule('namefield', get_string('err_alphanumeric', 'form'), 'alphanumeric', null, 'client');  Diese Regel verbietet andere Eingaben zu speichern, als Buchstaben und Zahlen.    Der Nutzer loggt sich aus seinem aktuell gespeichertem Account aus \n    Der Nutzer muss mit Hilfe des  oauth2owncloud  admin_tools ausgeloggt werden, und der  access token  wird auf null gesetzt.  $ocs- owncloud- log_out();\nset_user_preference('oC_token', null);    Kursteilnehmer rufen die Seite auf, obwohl die Ordner noch nicht vom CronJob erstellt wurden.  F\u00fcr jeden Ordner wird \u00fcberpr\u00fcft, ob der Ordner schon erstellt wurde: Zur Information wird dem Nutzer angezeigt, dass die Ordner noch nicht erstellt wurden.  $content = json_decode($element- customdata);\n$cmidoftask = $content- cmid;\nif ($id == $cmidoftask) {\n    $created = false;\n}", 
            "title": "Sicht der Studierenden"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/#sicht-der-lehrenden", 
            "text": "Falls der Lehrende sich selbst keinen Zugriff gew\u00e4hrt hat, sieht er den Ordner auch nicht wenn er in einer Gruppe eingeschrieben ist. Hat der Lehrende Zugriff auf die Ordner, so sieht er eine tabellarische Auflistung aller bestehenden Ordner. Zus\u00e4tzlich kann er genau wie Studierende seinen ownCloud Account \u00e4ndern, den Namen des Ordners \u00e4ndern und Ordner per Klick der eigenen Instanz hinzuf\u00fcgen. In dem Fall, dass Gruppenordner erstellt wurden, wird dem Lehrenden der \u00dcberordner aller Gruppenordner hinzugef\u00fcgt.", 
            "title": "Sicht der Lehrenden"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/#tests-und-continuous-integration", 
            "text": "", 
            "title": "Tests und Continuous Integration"
        }, 
        {
            "location": "/moodle/benutzung/", 
            "text": "Benutzung\n\n\nPlugins k\u00f6nnen in Moodle zus\u00e4tzlich zum \nmoodle core\n installiert werden. Im Folgenden wird beschrieben, wie die Plugins heruntergeladen werden k\u00f6nnen und anschlie\u00dfend in den einzelnen Plugins die richtigen Einstellungen get\u00e4tigt k\u00f6nnen. \nZus\u00e4tzlich werden verschiedene Ansichten der Plugins dargestellt um die Funktionalit\u00e4ten der jeweiligen Plugins zu verdeutlichen.\n\n\nDownload\n\n\nDie Plugins sind zurzeit in einem \u00f6ffentlichen \nGitHub repository\n verf\u00fcgbar.\nVon dort aus k\u00f6nnen die Plugins auf zwei Wegen heruntergeladen werden.\n\n\n\n\n\n\nAls Zip-Datei\n    Am rechten Rand in dem Men\u00fc \nclone or download\n auf \nDownload ZIP\n klicken. In Moodle k\u00f6nnen ZIP-Ordner einfach installiert werden, indem sie vom Seiten-Administrator unter dem Men\u00fcpunkt \nWebsite-Administration Plugins Plugin installieren\n hochgeladen werden. Das Plugin wird automatisch richtig platziert.\n\n\n\n\n\n\nMit dem Befehl \ngit clone\n\n    In der Moodle Instanz in den zugeh\u00f6rigen Ordner navigieren. Bei Unsicherheiten k\u00f6nnen die richtigen Ordner in den Beschreibungen der einzelnen Plugins nachgelesen werden. Nun den folgenden Befehl ausf\u00fchren:\n    \ngit clone git@github.com:pssl16/name_of_the_repository.github.git\n\n    Nun befindet sich der Inhalt an der richtigen Stelle, der Ordner muss nur noch umbenannt werden. Das letzte Wort des Ordners ist der Name des Plugins und muss auch der Name des Ordners sein.\n\n\n\n\n\n\nDer Vorteil des zweiten Weges ist, dass mittels \ngit pull\n \u00c4nderung schnell nachgepflegt k\u00f6nnen. Bei Unerfahrenheit mit \ngit\n sollte jedoch lieber der erste Weg gew\u00e4hlt werden.\n\n\nNach Herunterladen und richtiger Platzierung der Plugins werden dem Administrator der Moodle-Website im Plugin Manager die neuen verf\u00fcgbaren Updates angezeigt.\nUm die Plugins zu benutzen wird in jedem Fall das \noauth2owncloud_admin_tool\nben\u00f6tigt , alle anderen Plugins lassen sich nicht ohne dieses installieren. Dies ist bei der Reihenfolge der Installation bei Installation der Plugins als ZIP-Ordner zu beachten.\n\n\nIcons\n\n\nDie vorgegebenen Icons k\u00f6nnen einfach ersetzt werden, indem die in \nplugin/pix/icon.svg\n vorhandene Datei durch eine gleichnamige Datei ausgetauscht wird. Es k\u00f6nnen auch andere Formate als \n.svg\n verwendet werden. Das Bild darf jedoch nicht die Gr\u00f6\u00dfe von 16x16 px \u00fcberschreiten.\n\n\nAdmin Tool oauth2owncloud\n\n\nDownloadlink\n\n\nAdmin Einstellungen\n\n\nDamit das OAuth 2.0 Protokoll reibungslos ablaufen kann, muss zuerst der Client in den Einstellungen registriert werden.\n\n\nHierf\u00fcr muss der Administrator das Formular des Plugins, das unter \nWebsite-Administration \u25ba Plugins \u25ba Authentifizierung \u25ba Sciebo OAuth 2.0 Configuration\n zu finden ist, ausf\u00fcllen.\n\n\n\n\nAls erstes Feld muss die Client ID eingegeben werden. Diese findet man in ownCloud, sobald ein neuer Client registriert wurde. Dasselbe gilt f\u00fcr das n\u00e4chste Feld, hier wird das Secret angegeben, dass sich auch aus der ownCloud App kopieren l\u00e4sst.\n\n\n\n\nNun werden die Einstellungen f\u00fcr den WebDAV Zugriff festgelegt.\nAls erstes wird die Adresse des ownCloud Servers angegeben.\nIm n\u00e4chsten Feld wird der Pfad zur WebDAV Schnittstelle angegeben in ownCloud endet diese typischerweise mit \nremote.php/webdav/\n.\nAls Protokolltyp kann \nhttp\n oder \nhttps\n angegeben werden. Wird keine Angabe gemacht, so wird von \nhttps\n ausgegangen.\nAls letztes kann der Port angegeben werden.\n\n\nRepository sciebo\n\n\nDownloadlink\n\n\nAdmin Einstellungen\n\n\nSobald das Admin tool installiert wurde, kann das Repository installiert werden. Es ist zu beachten, dass die oben genannten Eintr\u00e4ge get\u00e4tigt wurden, da ansonsten die Authentifizierung des Repositorys nicht funktioniert. Repository Plugins m\u00fcssen in Moodle von einem Administrator unter dem Men\u00fcpunkt \nWebsite-Administration \u25ba Plugins \u25ba Repositories \u25ba \u00dcbersicht\n aktiviert werden. Der Administrator kann dem Repository zus\u00e4tzlich unter \nEinstellungen\n einen globalen Namen geben.\n\n\nNutzer Sicht\n\n\nDas Repository ist sowohl in den Kursen als auch f\u00fcr private Instanzen verf\u00fcgbar und muss nicht mehr hinzugef\u00fcgt werden. Kurs-Administratoren k\u00f6nnen das Repository jedoch unter \nSpeicherorte\n l\u00f6schen. Die Nutzung l\u00e4sst sich nicht auf bestimmte Nutzer oder Aktivit\u00e4ten im Kurs einschr\u00e4nken. Im File Picker muss man sich zun\u00e4chst anmelden.\n\n\n\n\nWird der Button bet\u00e4tigt, erscheint ein Pop-up Window oder ein neuer Tab, der den Nutzer auffordert sich in ownCloud anzumelden. Anschlie\u00dfend wird der Nutzer gefragt ob er die App autorisieren m\u00f6chte. Der Nutzer wird nun zur\u00fcckgeleitet und sieht eine tabellarische Auflistung der vorhandenen Dateien:\n\n\n\n\nIm roten Kasten sieht der Nutzer Buttons um den Inhalt neu zu laden und sich auszuloggen. Nur als Admin sieht man den letzten Button, mit dem man die Einstellungen des OAuth2 admin_tool bearbeiten kann.\n\n\ncollaborative_folders\n\n\nDownloadlink\n\n\nEinstellungen\n\n\nAdmin Einstellungen\n\n\nF\u00fcr die Aktivit\u00e4t collaborative_folders wird ein technischer Nutzer der ownCloud Instanz ben\u00f6tigt. Bei diesem Nutzer werden alle Ordner, die erstellt werden, gespeichert. Um den Nutzer festzulegen muss in \nWebsite-Administration \u25ba Plugins \u25ba Aktivit\u00e4ten \u25ba collaborativefolders\n ein technischer Nutzer mit Hilfe des OAuth 2.0 Protokolls authentifiziert werden. \u00dcber einen Login Button muss sich in ownCloud authentifiziert werden. Bei nicht erfolgter Weiterleitung sind die Einstellungen im Admin tool oauth2owncloud fehlerhaft und diese sind zu \u00fcberpr\u00fcfen. Es ist darauf zu achten, dass sich nicht mit dem regul\u00e4ren privaten Account, sondern mit dem des technischen Nutzers angemeldet wird.\n\n\nSicht des Lehrenden\n\n\nDie Aktivit\u00e4t ist in jedem Moodle Kurs verf\u00fcgbar. Wenn ein Lehrender die Aktivit\u00e4t dem Kurs hinzuf\u00fcgt muss er dem Ordner einen Namen f\u00fcr die Moodle Instanz und einen f\u00fcr die ownCloud Instanz geben. Danach kann festlegt werden, ob Lehrende des Kurses Zugriff auf alle erstellten Ordner haben. Eins der wichtigsten Integrationsszenarien ist, dass nur f\u00fcr Gruppen  von Studierenden ein Ordner erstellt wird. Dies ist m\u00f6glich, wenn der Lehrende den Zugriff auf bestimmte Gruppen beschr\u00e4nkt. In diesem Fall werden nur f\u00fcr die gew\u00e4hlten Gruppen einzelne Ordner erstellt.\n\n\nSicht der Studierenden\n\n\nWenn ein Ordner f\u00fcr einen Studierenden freigegeben wurde, sieht dieser die Aktivit\u00e4t in dem Kurs. Ordner werden von dem Plugin zeitverz\u00f6gert erstellt um den Server nicht zu \u00fcberlasten. Somit kann es passieren, dass der Nutzer, wenn er die Aktivit\u00e4t ausw\u00e4hlt, eine Nachricht bekommt, dass die Ordner noch nicht erstellt wurden. Sobald die Ordner erstellt wurden, wird der Nutzer aufgefordert dem Ordner einen individuellen Namen\nzu geben, wenn er die Aktivit\u00e4t ausw\u00e4hlt. Dieser Name wird nur f\u00fcr den derzeitigen Nutzer gespeichert.\n\n\n\n\nDanach kann der Nutzer unter dem Men\u00fcpunkt \nChange Folder Name\n den gew\u00e4hlten Namen \u00e4ndern. Wenn der Nutzer noch nicht eingeloggt ist, kann er sich \u00fcber einen Login Button authentifizieren. Ansonsten kann er sich aus dem aktuellen Account ausloggen und sich mit einem anderen Account authentifizieren.\nWenn er authentifiziert ist, kann der Ordner unter dem Men\u00fcpunkt \nGenerate Link to Folder\n dem privaten Account hinzugef\u00fcgt werden.\n\n\n\n\nNun kann der Nutzer \u00fcber einen Link in Moodle oder \u00fcber den normalen ownCloud Login auf\nden Ordner zugreifen.", 
            "title": "Benutzung"
        }, 
        {
            "location": "/moodle/benutzung/#benutzung", 
            "text": "Plugins k\u00f6nnen in Moodle zus\u00e4tzlich zum  moodle core  installiert werden. Im Folgenden wird beschrieben, wie die Plugins heruntergeladen werden k\u00f6nnen und anschlie\u00dfend in den einzelnen Plugins die richtigen Einstellungen get\u00e4tigt k\u00f6nnen. \nZus\u00e4tzlich werden verschiedene Ansichten der Plugins dargestellt um die Funktionalit\u00e4ten der jeweiligen Plugins zu verdeutlichen.", 
            "title": "Benutzung"
        }, 
        {
            "location": "/moodle/benutzung/#download", 
            "text": "Die Plugins sind zurzeit in einem \u00f6ffentlichen  GitHub repository  verf\u00fcgbar.\nVon dort aus k\u00f6nnen die Plugins auf zwei Wegen heruntergeladen werden.    Als Zip-Datei\n    Am rechten Rand in dem Men\u00fc  clone or download  auf  Download ZIP  klicken. In Moodle k\u00f6nnen ZIP-Ordner einfach installiert werden, indem sie vom Seiten-Administrator unter dem Men\u00fcpunkt  Website-Administration Plugins Plugin installieren  hochgeladen werden. Das Plugin wird automatisch richtig platziert.    Mit dem Befehl  git clone \n    In der Moodle Instanz in den zugeh\u00f6rigen Ordner navigieren. Bei Unsicherheiten k\u00f6nnen die richtigen Ordner in den Beschreibungen der einzelnen Plugins nachgelesen werden. Nun den folgenden Befehl ausf\u00fchren:\n     git clone git@github.com:pssl16/name_of_the_repository.github.git \n    Nun befindet sich der Inhalt an der richtigen Stelle, der Ordner muss nur noch umbenannt werden. Das letzte Wort des Ordners ist der Name des Plugins und muss auch der Name des Ordners sein.    Der Vorteil des zweiten Weges ist, dass mittels  git pull  \u00c4nderung schnell nachgepflegt k\u00f6nnen. Bei Unerfahrenheit mit  git  sollte jedoch lieber der erste Weg gew\u00e4hlt werden.  Nach Herunterladen und richtiger Platzierung der Plugins werden dem Administrator der Moodle-Website im Plugin Manager die neuen verf\u00fcgbaren Updates angezeigt.\nUm die Plugins zu benutzen wird in jedem Fall das  oauth2owncloud_admin_tool ben\u00f6tigt , alle anderen Plugins lassen sich nicht ohne dieses installieren. Dies ist bei der Reihenfolge der Installation bei Installation der Plugins als ZIP-Ordner zu beachten.", 
            "title": "Download"
        }, 
        {
            "location": "/moodle/benutzung/#icons", 
            "text": "Die vorgegebenen Icons k\u00f6nnen einfach ersetzt werden, indem die in  plugin/pix/icon.svg  vorhandene Datei durch eine gleichnamige Datei ausgetauscht wird. Es k\u00f6nnen auch andere Formate als  .svg  verwendet werden. Das Bild darf jedoch nicht die Gr\u00f6\u00dfe von 16x16 px \u00fcberschreiten.", 
            "title": "Icons"
        }, 
        {
            "location": "/moodle/benutzung/#admin-tool-oauth2owncloud", 
            "text": "Downloadlink", 
            "title": "Admin Tool oauth2owncloud"
        }, 
        {
            "location": "/moodle/benutzung/#admin-einstellungen", 
            "text": "Damit das OAuth 2.0 Protokoll reibungslos ablaufen kann, muss zuerst der Client in den Einstellungen registriert werden.  Hierf\u00fcr muss der Administrator das Formular des Plugins, das unter  Website-Administration \u25ba Plugins \u25ba Authentifizierung \u25ba Sciebo OAuth 2.0 Configuration  zu finden ist, ausf\u00fcllen.   Als erstes Feld muss die Client ID eingegeben werden. Diese findet man in ownCloud, sobald ein neuer Client registriert wurde. Dasselbe gilt f\u00fcr das n\u00e4chste Feld, hier wird das Secret angegeben, dass sich auch aus der ownCloud App kopieren l\u00e4sst.   Nun werden die Einstellungen f\u00fcr den WebDAV Zugriff festgelegt.\nAls erstes wird die Adresse des ownCloud Servers angegeben.\nIm n\u00e4chsten Feld wird der Pfad zur WebDAV Schnittstelle angegeben in ownCloud endet diese typischerweise mit  remote.php/webdav/ .\nAls Protokolltyp kann  http  oder  https  angegeben werden. Wird keine Angabe gemacht, so wird von  https  ausgegangen.\nAls letztes kann der Port angegeben werden.", 
            "title": "Admin Einstellungen"
        }, 
        {
            "location": "/moodle/benutzung/#repository-sciebo", 
            "text": "Downloadlink", 
            "title": "Repository sciebo"
        }, 
        {
            "location": "/moodle/benutzung/#admin-einstellungen_1", 
            "text": "Sobald das Admin tool installiert wurde, kann das Repository installiert werden. Es ist zu beachten, dass die oben genannten Eintr\u00e4ge get\u00e4tigt wurden, da ansonsten die Authentifizierung des Repositorys nicht funktioniert. Repository Plugins m\u00fcssen in Moodle von einem Administrator unter dem Men\u00fcpunkt  Website-Administration \u25ba Plugins \u25ba Repositories \u25ba \u00dcbersicht  aktiviert werden. Der Administrator kann dem Repository zus\u00e4tzlich unter  Einstellungen  einen globalen Namen geben.", 
            "title": "Admin Einstellungen"
        }, 
        {
            "location": "/moodle/benutzung/#nutzer-sicht", 
            "text": "Das Repository ist sowohl in den Kursen als auch f\u00fcr private Instanzen verf\u00fcgbar und muss nicht mehr hinzugef\u00fcgt werden. Kurs-Administratoren k\u00f6nnen das Repository jedoch unter  Speicherorte  l\u00f6schen. Die Nutzung l\u00e4sst sich nicht auf bestimmte Nutzer oder Aktivit\u00e4ten im Kurs einschr\u00e4nken. Im File Picker muss man sich zun\u00e4chst anmelden.   Wird der Button bet\u00e4tigt, erscheint ein Pop-up Window oder ein neuer Tab, der den Nutzer auffordert sich in ownCloud anzumelden. Anschlie\u00dfend wird der Nutzer gefragt ob er die App autorisieren m\u00f6chte. Der Nutzer wird nun zur\u00fcckgeleitet und sieht eine tabellarische Auflistung der vorhandenen Dateien:   Im roten Kasten sieht der Nutzer Buttons um den Inhalt neu zu laden und sich auszuloggen. Nur als Admin sieht man den letzten Button, mit dem man die Einstellungen des OAuth2 admin_tool bearbeiten kann.", 
            "title": "Nutzer Sicht"
        }, 
        {
            "location": "/moodle/benutzung/#collaborative_folders", 
            "text": "Downloadlink", 
            "title": "collaborative_folders"
        }, 
        {
            "location": "/moodle/benutzung/#einstellungen", 
            "text": "", 
            "title": "Einstellungen"
        }, 
        {
            "location": "/moodle/benutzung/#admin-einstellungen_2", 
            "text": "F\u00fcr die Aktivit\u00e4t collaborative_folders wird ein technischer Nutzer der ownCloud Instanz ben\u00f6tigt. Bei diesem Nutzer werden alle Ordner, die erstellt werden, gespeichert. Um den Nutzer festzulegen muss in  Website-Administration \u25ba Plugins \u25ba Aktivit\u00e4ten \u25ba collaborativefolders  ein technischer Nutzer mit Hilfe des OAuth 2.0 Protokolls authentifiziert werden. \u00dcber einen Login Button muss sich in ownCloud authentifiziert werden. Bei nicht erfolgter Weiterleitung sind die Einstellungen im Admin tool oauth2owncloud fehlerhaft und diese sind zu \u00fcberpr\u00fcfen. Es ist darauf zu achten, dass sich nicht mit dem regul\u00e4ren privaten Account, sondern mit dem des technischen Nutzers angemeldet wird.", 
            "title": "Admin Einstellungen"
        }, 
        {
            "location": "/moodle/benutzung/#sicht-des-lehrenden", 
            "text": "Die Aktivit\u00e4t ist in jedem Moodle Kurs verf\u00fcgbar. Wenn ein Lehrender die Aktivit\u00e4t dem Kurs hinzuf\u00fcgt muss er dem Ordner einen Namen f\u00fcr die Moodle Instanz und einen f\u00fcr die ownCloud Instanz geben. Danach kann festlegt werden, ob Lehrende des Kurses Zugriff auf alle erstellten Ordner haben. Eins der wichtigsten Integrationsszenarien ist, dass nur f\u00fcr Gruppen  von Studierenden ein Ordner erstellt wird. Dies ist m\u00f6glich, wenn der Lehrende den Zugriff auf bestimmte Gruppen beschr\u00e4nkt. In diesem Fall werden nur f\u00fcr die gew\u00e4hlten Gruppen einzelne Ordner erstellt.", 
            "title": "Sicht des Lehrenden"
        }, 
        {
            "location": "/moodle/benutzung/#sicht-der-studierenden", 
            "text": "Wenn ein Ordner f\u00fcr einen Studierenden freigegeben wurde, sieht dieser die Aktivit\u00e4t in dem Kurs. Ordner werden von dem Plugin zeitverz\u00f6gert erstellt um den Server nicht zu \u00fcberlasten. Somit kann es passieren, dass der Nutzer, wenn er die Aktivit\u00e4t ausw\u00e4hlt, eine Nachricht bekommt, dass die Ordner noch nicht erstellt wurden. Sobald die Ordner erstellt wurden, wird der Nutzer aufgefordert dem Ordner einen individuellen Namen\nzu geben, wenn er die Aktivit\u00e4t ausw\u00e4hlt. Dieser Name wird nur f\u00fcr den derzeitigen Nutzer gespeichert.   Danach kann der Nutzer unter dem Men\u00fcpunkt  Change Folder Name  den gew\u00e4hlten Namen \u00e4ndern. Wenn der Nutzer noch nicht eingeloggt ist, kann er sich \u00fcber einen Login Button authentifizieren. Ansonsten kann er sich aus dem aktuellen Account ausloggen und sich mit einem anderen Account authentifizieren.\nWenn er authentifiziert ist, kann der Ordner unter dem Men\u00fcpunkt  Generate Link to Folder  dem privaten Account hinzugef\u00fcgt werden.   Nun kann der Nutzer \u00fcber einen Link in Moodle oder \u00fcber den normalen ownCloud Login auf\nden Ordner zugreifen.", 
            "title": "Sicht der Studierenden"
        }
    ]
}