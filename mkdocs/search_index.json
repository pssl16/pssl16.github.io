{
    "docs": [
        {
            "location": "/", 
            "text": "sciebo@Learnweb\n\n\nDiese Website dokumentiert das Projektseminar \nsciebo@Learnweb\n, das im Wintersemester 2016/17 an der \nWestf\u00e4lischen Wilhelms-Universit\u00e4t M\u00fcnster\n stattgefunden hat.\n\n\nGegenstand des Projektseminars war die Integration der Systeme \nsciebo\n und \nLearnweb\n. Sciebo ist ein Cloud-Dienst, der gemeinsam von 26 Hochschulen und Forschungseinrichtungen in NRW angeboten wird. Als Grundlage dient die Open-Source-L\u00f6sung \nownCloud\n. Das Learnweb ist ein auf der Open-Source-L\u00f6sung \nMoodle\n basierendes E-Learning System der Westf\u00e4lischen Wilhelms-Universit\u00e4t M\u00fcnster.\n\n\nEine m\u00f6gliche L\u00f6sung sollte dabei m\u00f6glichst allgemein einsetzbar sein, da die Kombination von Moodle und ownCloud an zahlreichen Universit\u00e4ten genutzt wird.\n\n\nUser Stories\n\n\nAls Integrationsszenarien der Systeme wurden verschiedene User Stories entwickelt. Als Integrationsrichtung konzentrierte man sich auf die Richtung Learnweb \n sciebo.\n\n\nAuthentifizierung und Autorisierung\n\n\nGrundlegend f\u00fcr die Integration beider Systeme ist die Authentifizierung und Autorisierung. Unter den g\u00e4ngigen Verfahren, die untersucht wurden, befinden sich:\n\n\n\n\nOAuth 2.0\n\n\nJSON Web Tokens\n\n\nFederated Single Sign-on mit beispielsweise \nShibboleth\n\n\n\n\nF\u00fcr das Projekt wurde das OAuth 2.0 Verfahren ausgew\u00e4hlt, da mit ihm ein standardisiertes Verfahren zur tokenbasierten Authentifizierung und Autorisierung vorliegt, das sich gut in bestehende Applikationen auf Basis vieler verschiedener Programmiersprachen einf\u00fcgen l\u00e4sst und damit keine weiteren Anforderungen an die Infrastruktur stellt.\n\n\nOAuth 2.0\n\n\nDer allgemeine OAuth 2.0 Protokollablauf ist in der nachfolgenden Abbildung dargestellt.\n\n\n\n\nZun\u00e4chst muss sich der Client (Learnweb), der im Namen des Resource Owners (sciebo Nutzer) auf eine gesch\u00fctzte Ressource auf dem Resource Server (sciebo) zugreifen m\u00f6chte, bei dem Authorization Server (sciebo) registrieren. Danach werden nach dem Protokoll folgende Schritte durchlaufen:\n\n\n\n\nAuthorization Request:\n\n\nAuthorization Response\n\n\nAccess Token Request\n\n\nAccess Token Response\n\n\nAnfrage mittels Access Token\n\n\nZugriff auf gesch\u00fctzte Ressourcen\n\n\n\n\n\n  \nTODO:\n Beschreibung der Schritte einf\u00fcgen.\n\n\n\n\nKomponenten\n\n\nownCloud\n\n\nMoodle\n\n\nZusammenspiel", 
            "title": "Home"
        }, 
        {
            "location": "/#sciebolearnweb", 
            "text": "Diese Website dokumentiert das Projektseminar  sciebo@Learnweb , das im Wintersemester 2016/17 an der  Westf\u00e4lischen Wilhelms-Universit\u00e4t M\u00fcnster  stattgefunden hat.  Gegenstand des Projektseminars war die Integration der Systeme  sciebo  und  Learnweb . Sciebo ist ein Cloud-Dienst, der gemeinsam von 26 Hochschulen und Forschungseinrichtungen in NRW angeboten wird. Als Grundlage dient die Open-Source-L\u00f6sung  ownCloud . Das Learnweb ist ein auf der Open-Source-L\u00f6sung  Moodle  basierendes E-Learning System der Westf\u00e4lischen Wilhelms-Universit\u00e4t M\u00fcnster.  Eine m\u00f6gliche L\u00f6sung sollte dabei m\u00f6glichst allgemein einsetzbar sein, da die Kombination von Moodle und ownCloud an zahlreichen Universit\u00e4ten genutzt wird.", 
            "title": "sciebo@Learnweb"
        }, 
        {
            "location": "/#user-stories", 
            "text": "Als Integrationsszenarien der Systeme wurden verschiedene User Stories entwickelt. Als Integrationsrichtung konzentrierte man sich auf die Richtung Learnweb   sciebo.", 
            "title": "User Stories"
        }, 
        {
            "location": "/#authentifizierung-und-autorisierung", 
            "text": "Grundlegend f\u00fcr die Integration beider Systeme ist die Authentifizierung und Autorisierung. Unter den g\u00e4ngigen Verfahren, die untersucht wurden, befinden sich:   OAuth 2.0  JSON Web Tokens  Federated Single Sign-on mit beispielsweise  Shibboleth   F\u00fcr das Projekt wurde das OAuth 2.0 Verfahren ausgew\u00e4hlt, da mit ihm ein standardisiertes Verfahren zur tokenbasierten Authentifizierung und Autorisierung vorliegt, das sich gut in bestehende Applikationen auf Basis vieler verschiedener Programmiersprachen einf\u00fcgen l\u00e4sst und damit keine weiteren Anforderungen an die Infrastruktur stellt.", 
            "title": "Authentifizierung und Autorisierung"
        }, 
        {
            "location": "/#oauth-20", 
            "text": "Der allgemeine OAuth 2.0 Protokollablauf ist in der nachfolgenden Abbildung dargestellt.   Zun\u00e4chst muss sich der Client (Learnweb), der im Namen des Resource Owners (sciebo Nutzer) auf eine gesch\u00fctzte Ressource auf dem Resource Server (sciebo) zugreifen m\u00f6chte, bei dem Authorization Server (sciebo) registrieren. Danach werden nach dem Protokoll folgende Schritte durchlaufen:   Authorization Request:  Authorization Response  Access Token Request  Access Token Response  Anfrage mittels Access Token  Zugriff auf gesch\u00fctzte Ressourcen   \n   TODO:  Beschreibung der Schritte einf\u00fcgen.", 
            "title": "OAuth 2.0"
        }, 
        {
            "location": "/#komponenten", 
            "text": "", 
            "title": "Komponenten"
        }, 
        {
            "location": "/#owncloud", 
            "text": "", 
            "title": "ownCloud"
        }, 
        {
            "location": "/#moodle", 
            "text": "", 
            "title": "Moodle"
        }, 
        {
            "location": "/#zusammenspiel", 
            "text": "", 
            "title": "Zusammenspiel"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/", 
            "text": "Technische Umsetzung\n\n\nDa man m\u00f6glichst keine neue Schnittstelle implementieren wollte, war es das Ziel, die bestehende WebDAV Schnittstelle um OAuth 2.0 zu erweitern. Die WebDAV Schnittstelle ist als \nownCloud App\n realisiert worden und nutzt die \nsabre/dav\n Bibliothek. Auf der anderen Seite musste das OAuth 2.0 Protokoll mit seinen Schnittstellen bereitgestellt werden, um die Authentifizierung in der WebDAV App um OAuth 2.0 zu erweitern zu k\u00f6nnen. Daf\u00fcr wurde eine weitere ownCloud App implementiert.\n\n\nImplementierung der \noauth2\n App\n\n\nIn der App sollte der h\u00e4ufig f\u00fcr Webapplikationen eingesetzte \nAuthorization Code Flow\n implementiert werden. Dazu mussten folgende User Stories umgesetzt werden:\n\n\n\n\nClientregistrierung:\n Als ownCloud-Administrator m\u00f6chte ich Clients in den Administrator-Einstellungen hinzuf\u00fcgen und l\u00f6schen k\u00f6nnen, um die Kontrolle \u00fcber erlaubte Clients zu haben.\n\n\nAuthorization URL:\n Als Client-Entwickler m\u00f6chte ich eine Authorization URL zur Verf\u00fcgung haben, um Authorization Codes anfordern zu k\u00f6nnen.\n\n\nAccess Token URL:\n Als Client-Entwickler m\u00f6chte ich eine Access Token URL zur Verf\u00fcgung haben, um Access Tokens anfordern zu k\u00f6nnen.\n\n\nVerwaltung autorisierter Applikationen\n: Als ownCloud-Nutzer m\u00f6chte ich in den pers\u00f6nlichen Einstellungen autorisierte Applikationen verwalten k\u00f6nnen, um einen \u00dcberblick zu haben und Autorisierungen widerrufen zu k\u00f6nnen.\n\n\n\n\nDatenmodell\n\n\nZun\u00e4chst musste ein Datenmodell zur Speicherung der ben\u00f6tigten Daten aufgestellt werden. Gem\u00e4\u00df dem Authorization Code Flow wurden folgende Entit\u00e4ten mit Attributen definiert:\n\n\n\n\nclient\n:\n Die Applikation, die f\u00fcr den Zugriff auf die WebDAV Schnittstelle autorisiert werden soll.\n\n\nidentifier\n: Zeichenkette, die einen Client eindeutig identifiziert.\n\n\nsecret\n: Zeichenkette, mit der ein Client sich beim Anfordern eines Access Tokens authentifizieren kann.\n\n\nredirect_uri\n: URI, an die nach erfolgter Autorisierung des Nutzers weitergeleitet wird.\n\n\n\n\n\n\nauthorization_code\n:\n Ein \nAuthorization Grant\n, mit dem der Client die Autorisierung des Nutzers darlegen und somit ein Access Token anfordern kann.\n\n\ncode\n: Zeichenkette, die als Authorization Code dient.\n\n\nclient_id\n: Client Identifier des Clients, f\u00fcr den der Authorization Code ausgegeben wird.\n\n\nuser_id\n: User ID des ownCloud-Nutzers, der den Client autorisiert hat.\n\n\nexpires\n: Zeitpunkt, zu dem der Authorization Code ung\u00fcltig wird (optional).\n\n\n\n\n\n\naccess_token\n:\n Eine Zeichenkette, die den Zugriff auf die WebDAV Schnittstelle erlaubt.\n\n\ncode\n: Zeichenkette, die als Access Token dient.\n\n\nclient_id\n: Client Identifier des Clients, f\u00fcr den der Access Token ausgegeben wird.\n\n\nuser_id\n: User ID des ownCloud-Nutzers, der den Client autorisiert hat.\n\n\nexpires\n: Zeitpunkt, zu dem der Access Token ung\u00fcltig wird (optional).\n\n\n\n\n\n\nrefresh_token\n:\n Eine Zeichenkette, mit der ein abgelaufener Access Token gegen einen neuen ausgetauscht werden kann.\n\n\ncode\n: Zeichenkette, die als Refresh Token dient.\n\n\nclient_id\n: Client Identifier des Clients, f\u00fcr den der Access Token ausgegeben wird.\n\n\nuser_id\n: User ID des ownCloud-Nutzers, der den Client autorisiert hat.\n\n\nexpires\n: Zeitpunkt, zu dem der Refresh Token ung\u00fcltig wird (optional).\n\n\n\n\n\n\n\n\nFolgendes Entity-Relationship-Modell fasst das Datenmodell nochmal grafisch zusammen.\n\n\n\n  \nTODO:\n ERM einf\u00fcgen.\n\n\n\n\nMapper und Entities\n\n\nF\u00fcr den Datenbank-Zugriff im PHP-Code ist es in ownCloud m\u00f6glich, \nMapper\n und \nEntities\n zu schreiben. Dadurch werden Tupel in einer Datenbank-Tabelle automatisch in ein Objekt umgewandelt.\n\n\nFolgendes Codebeispiel zeigt am Beispiel des Entitys \nClient\n, wie eine PHP-Klasse dazu aussehen muss.\n\n\n?php\nnamespace OCA\\OAuth2\\Db;\n\nuse OCP\\AppFramework\\Db\\Entity;\n\n/**\n * Class Client\n *\n * @method string getIdentifier()\n * @method void setIdentifier(string $identifier)\n * @method string getSecret()\n * @method void setSecret(string $secret)\n * @method string getRedirectUri()\n * @method void setRedirectUri(string $redirectUri)\n * @method string getName()\n * @method void setName(string $name)\n */\nclass Client extends Entity {\n\n    protected $identifier;\n    protected $secret;\n    protected $redirectUri;\n    protected $name;\n\n    public function __construct() {\n        $this-\naddType('id', 'int');\n        $this-\naddType('identifier', 'string');\n        $this-\naddType('secret', 'string');\n        $this-\naddType('redirect_uri', 'string');\n        $this-\naddType('name', 'string');\n    }\n\n}\n\n\n\n\nWichtig ist, dass die Klasse von \nEntity\n erbt und sowohl der Klassenname als auch die Attribute mit denen der Tabelle \u00fcbereinstimmen. Pascal bzw. Camel case im PHP-Code wird automatisch zu Snake case f\u00fcr die Datenbank umgewandelt. Getter und Setter werden ebenfalls automatisch generiert. Die PHPDoc Kommentare dienen lediglich dazu, in der Entwicklungsumgebung eine automatische Vervollst\u00e4ndigung zu haben. Die Angabe von \nTypen\n im Konstruktor dienen dazu, beim Lesen aus der Datenbank die richtige Umwandlung zu erhalten.\n\n\nDas folgende Codebeispiel zeigt einen Ausschnitt aus dem zur \nClient\n Entity geh\u00f6renden Mapper.\n\n\n?php\nnamespace OCA\\OAuth2\\Db;\n\nuse InvalidArgumentException;\nuse OCP\\AppFramework\\Db\\Entity;\nuse OCP\\IDb;\nuse OCP\\AppFramework\\Db\\Mapper;\n\nclass ClientMapper extends Mapper {\n\n    /**\n     * ClientMapper constructor.\n     *\n     * @param IDb $db Database Connection.\n     */\n    public function __construct(IDb $db) {\n        parent::__construct($db, 'oauth2_clients');\n    }\n\n    /**\n     * Selects a client by its ID.\n     *\n     * @param int $id The client's ID.\n     *\n     * @return Entity The client entity.\n     *\n     * @throws \\OCP\\AppFramework\\Db\\DoesNotExistException if not found.\n     * @throws \\OCP\\AppFramework\\Db\\MultipleObjectsReturnedException if more than one result.\n     */\n    public function find($id) {\n        if (!is_int($id)) {\n            throw new InvalidArgumentException('id must not be null');\n        }\n\n        $sql = 'SELECT * FROM `' . $this-\ntableName . '` WHERE `id` = ?';\n        return $this-\nfindEntity($sql, array($id), null, null);\n    }\n\n    /**\n     * Selects clients by the given user ID.\n     *\n     * @param string $userId The user ID.\n     *\n     * @return array The client entities.\n     */\n    public function findByUser($userId) {\n        if (!is_string($userId)) {\n            throw new InvalidArgumentException('userId must not be null');\n        }\n\n        $sql = 'SELECT * FROM `' . $this-\ntableName . '` '\n            . 'WHERE `id` IN ( '\n                . 'SELECT `client_id` FROM `oc_oauth2_authorization_codes` WHERE `user_id` = ? '\n                . 'UNION '\n                . 'SELECT `client_id` FROM `oc_oauth2_access_tokens` WHERE `user_id` = ? '\n            .')';\n        return $this-\nfindEntities($sql, array($userId, $userId), null, null);\n    }\n\n}\n\n\n\n\nBeim Mapper ist es wichtig, dass die Klasse von \nMapper\n erbt und eine Entity-Klasse zu ihm existiert. Dazu wird das Wort vor \u201eMapper\u201c als Entityname verwendet. Im Konstruktur wird der Tabellenname angegeben. Die beiden Funktionen \nfind\n und \nfindByUser\n demonstrieren \nSELECT\n-Anweisungen. Dazu wird die SQL-Anweisungen zusammen mit ben\u00f6tigten Parametern an \nfindEntity\n bzw. \nfindEntities\n \u00fcbergeben, abh\u00e4ngig davon, ob mehrere Entities im Ergebnis enthalten sein sollten. Funktionen zum l\u00f6schen, einf\u00fcgen und updaten werden von der Oberklasse bereits implementiert und mussten nicht angepasst werden.\n\n\nSchnittstellen und Routes\n\n\nUm in einer ownCloud App Schnittstellen anzubieten, m\u00fcssen \nRoutes\n registriert werden. Zur Umsetzung der erw\u00e4hnten User Stories waren folgende Routes notwendig:\n\n\n\n\n\n\n\n\nMethode\n\n\nEndpunkt\n\n\nBeschreibung\n\n\n\n\n\n\n\n\n\n\nGET\n\n\nauthorize\n\n\nEndpunkt, zu dem der Client den Nutzer weiterleitet, um die Autorisierung anzufragen (Authorization URL).\n\n\n\n\n\n\nPOST\n\n\nauthorize\n\n\nEndpunkt, der aufgerufen wird, sobald der Nutzer den Client autorisiert hat.\n\n\n\n\n\n\nPOST\n\n\napi/v1/token\n\n\nEndpunkt, an dem ein Access Token angefordert wird (Access Token URL).\n\n\n\n\n\n\nPOST\n\n\nclients\n\n\nEndpunkt, durch den der Administrator einen Client hinzuf\u00fcgen kann.\n\n\n\n\n\n\nPOST\n\n\nclients/{id}/delete\n\n\nEndpunkt, durch den der Administrator den Client mit der ID \nid\n l\u00f6schen kann.\n\n\n\n\n\n\nPOST\n\n\nclients/{id}/revoke\n\n\nEndpunkt, durch den der Nutzer die Autorisierung des Clients mit der ID \nid\n widerrufen kann.\n\n\n\n\n\n\n\n\nRegistriert werden die Routes in der Datei \nroutes.php\n, indem ein Array mit den Routes zur\u00fcckgegeben wird. Nachfolgendes Codebeispiel zeigt einige der obigen Routes:\n\n\n?php\nreturn [\n    'routes' =\n [\n        ['name' =\n 'page#authorize', 'url' =\n '/authorize', 'verb' =\n 'GET'],\n        ['name' =\n 'o_auth_api#generate_token', 'url' =\n '/api/v1/token', 'verb' =\n 'POST'],\n        ['name' =\n 'settings#deleteClient', 'url' =\n '/clients/{id}/delete', 'verb' =\n 'POST']\n    ]\n];\n\n\n\n\n\nDurch \nname\n wird f\u00fcr jede Route der Name des dazugeh\u00f6rigen \nControllers\n sowie die aufzurufende Funktion angegeben. Vor dem \n#\n-Zeichen steht der Controllername in Snake case und hinter dem \n#\n-Zeichen steht der Funktionsname (ebenfalls in Snake case). Mithilfe von \nurl\n wird der Endpunkt festgelegt und \nverb\n definiert die HTTP-Methode.\n\n\nController\n\n\nWenn an einem Endpunkt eine HTTP-Anfrage ankommt, so wird der in den Routes definierte \nController\n aufgerufen. Wichtig ist hierbei, dass von der Klasse \nController\n oder einer Unterklasse wie \nApiController\n geerbt wird.\n\n\nF\u00fcr den Controller notwendige Parameter wie \nMapper\n k\u00f6nnen im Konstruktor als Parameter angegeben und so durch \nDependency Injection\n erhalten werden. Nachfolgendes Codebeispiel zeigt den Konstruktor vom \nPageController\n.\n\n\n/**\n * PageController constructor.\n * \n * @param string $AppName The name of the app.\n * @param IRequest $request The request.\n * @param ClientMapper $clientMapper The client mapper.\n * @param AuthorizationCodeMapper $authorizationCodeMapper The authorization code mapper.\n * @param string $UserId The user ID.\n */\npublic function __construct($AppName, IRequest $request, ClientMapper $clientMapper,\n    AuthorizationCodeMapper $authorizationCodeMapper, $UserId) {\n    parent::__construct($AppName, $request);\n\n    $this-\nclientMapper = $clientMapper;\n    $this-\nauthorizationCodeMapper = $authorizationCodeMapper;\n    $this-\nuserId = $UserId;\n}\n\n\n\n\nDie hier notwendigen Parameter sind der Name der App, eine \nClientMapper\n Instanz, eine \nAuthorizationCodeMapper\n Instanz und die ID des Nutzers, um bei der Autorisierung des Clients speichern zu k\u00f6nnen, welcher Nutzers dies veranlasst hat.\n\n\nDie mit den Routes verkn\u00fcpften Funktionen k\u00f6nnen zur Zugriffskontrolle mit \nPHPDoc Annotationen\n versehen werden. Folgendes Codebeispiel zeigt die Annotationen f\u00fcr die Funktion \ngenerateToken\n im \nOAuthApiController\n.\n\n\n/**\n * Implements the OAuth 2.0 Access Token Response.\n *\n * @param string $code The authorization code.\n * @return JSONResponse The Access Token or an empty JSON Object.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n * @PublicPage\n * @CORS\n */\npublic function generateToken($code) { }\n\n\n\n\nDie Annotationen haben dabei folgende Bedeutungen.\n\n\n\n\n\n\n\n\nAnnotation\n\n\nBedeutung\n\n\n\n\n\n\n\n\n\n\n@NoAdminRequired\n\n\nAufruf auch von normalen Nutzern m\u00f6glich.\n\n\n\n\n\n\n@NoCSRFRequired\n\n\nZeigt an, dass die \u00dcberpr\u00fcfung des CSRF Tokens nicht gewollt ist.\n\n\n\n\n\n\n@PublicPage\n\n\nZugriff auch ohne Login m\u00f6glich.\n\n\n\n\n\n\n@CORS\n\n\nAufruf der API durch andere Web Applikationen von au\u00dfen m\u00f6glich.\n\n\n\n\n\n\n\n\nIn den Controller-Funktionen k\u00f6nnen verschiedene Inhalte zur\u00fcckgegeben werden. Hier genutzte R\u00fcckgabetypen sind in der folgenden Tabelle zusammengefasst.\n\n\n\n\n\n\n\n\nTyp\n\n\nBeschreibung\n\n\n\n\n\n\n\n\n\n\nTemplateResponse\n\n\nZur R\u00fcckgabe eines Templates, das dem Nutzer angezeigt werden soll.\n\n\n\n\n\n\nRedirectResponse\n\n\nZur Weiterleitung des Nutzers an eine andere URL.\n\n\n\n\n\n\nJSONResponse\n\n\nZur R\u00fcckgabe eines JSON Strings.\n\n\n\n\n\n\n\n\nEin Beispiel f\u00fcr die R\u00fcckgabetypen \nTemplateResponse\n und \nRedirectResponse\n gibt die Funktion \nauthorize\n im \nPageController\n, die im folgenden Codebeispiel zu sehen ist.\n\n\n/**\n * Shows a view for the user to authorize a client.\n *\n * @param string $response_type The expected response type.\n * @param string $client_id The client identifier.\n * @param string $redirect_uri The redirect URI.\n * @param string $state The state.\n * @param string $scope The scope.\n *\n * @return TemplateResponse|RedirectResponse The authorize view or a\n * redirection to the ownCloud main page.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n */\npublic function authorize($response_type, $client_id, $redirect_uri, $state = null, $scope = null) {\n    if (!is_string($response_type) || !is_string($client_id)\n        || !is_string($redirect_uri) || (isset($state) \n !is_string($state))\n        || (isset($scope) \n !is_string($scope))) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    try {\n        /** @var Client $client */\n        $client = $this-\nclientMapper-\nfindByIdentifier($client_id);\n    } catch (DoesNotExistException $exception) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    if (strcmp($client-\ngetRedirectUri(), urldecode($redirect_uri)) !== 0) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n    if (strcmp($response_type, 'code') !== 0) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    return new TemplateResponse('oauth2', 'authorize', ['client_name' =\n $client-\ngetName()]);\n}\n\n\n\n\nHier werden zun\u00e4chst die Parameter auf G\u00fcltigkeit \u00fcberpr\u00fcft. Sollten die Parameter nicht g\u00fcltig sein (beispielsweise deshalb, weil der angegebene Client nicht existiert oder dessen Redirect URI falsch angegeben wurde) wird mit einem \nRedirectResponse\n auf die ownCloud Startseite umgeleitet. Andernfalls wird ein \nTemplateResponse\n f\u00fcr das Template \nauthorize\n zur\u00fcckgegeben. F\u00fcr das Rendern des Templates k\u00f6nnen Parameter wie hier \nclient_name\n f\u00fcr den Namen des Clients \u00fcbergeben werden.\n\n\nDer R\u00fcckgabetyp \nJSONResponse\n wird f\u00fcr die R\u00fcckgabe des Access Tokens in der Funktion \ngenerateToken\n im \nOAuthApiController\n genutzt, wie nachfolgendes Codebeispiel zeigt. Zudem ist das Zusammenspiel mit Entities und Mappern zu sehen.\n\n\n/**\n * Implements the OAuth 2.0 Access Token Response.\n *\n * @param string $code The authorization code.\n * @return JSONResponse The Access Token or an empty JSON Object.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n * @PublicPage\n * @CORS\n */\npublic function generateToken($code) {\n    if (is_null($code) || is_null($_SERVER['PHP_AUTH_USER'])\n        || is_null($_SERVER['PHP_AUTH_PW'])) {\n        return new JSONResponse(['message' =\n 'Missing credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    try {\n        /** @var Client $client */\n        $client = $this-\nclientMapper-\nfindByIdentifier($_SERVER['PHP_AUTH_USER']);\n    } catch (DoesNotExistException $exception) {\n        return new JSONResponse(['message' =\n 'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    if (strcmp($client-\ngetSecret(), $_SERVER['PHP_AUTH_PW']) !== 0) {\n        return new JSONResponse(['message' =\n 'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    try {\n        /** @var AuthorizationCode $authorizationCode */\n        $authorizationCode = $this-\nauthorizationCodeMapper-\nfindByCode($code);\n    } catch (DoesNotExistException $exception) {\n        return new JSONResponse(['message' =\n 'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    if (strcmp($authorizationCode-\ngetClientId(), $client-\ngetId()) !== 0) {\n        return new JSONResponse(['message' =\n 'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    $token = Utilities::generateRandom();\n    $userId = $authorizationCode-\ngetUserId();\n    $accessToken = new AccessToken();\n    $accessToken-\nsetToken($token);\n    $accessToken-\nsetClientId($authorizationCode-\ngetClientId());\n    $accessToken-\nsetUserId($userId);\n    $this-\naccessTokenMapper-\ninsert($accessToken);\n\n    $this-\nauthorizationCodeMapper-\ndelete($authorizationCode);\n\n    return new JSONResponse(\n        [\n            'access_token' =\n $token,\n            'token_type' =\n 'Bearer',\n            'user_id' =\n $userId\n        ]\n    );\n}\n\n\n\n\nNach erfolgreicher \u00dcberpr\u00fcfung des Authorization Codes und der Angaben zur Client Authentication im Authorization Header wird eine neuer Access Token erstellt und in der Datenbank gespeichert. Der verwendete Authorization Code wird zudem gel\u00f6scht. Im JSON Response wird dann der Access Token, der Token Typ und die ID des Nutzers zur\u00fcckgegeben. Nachfolgend ist ein Beispiel dazu angegeben.\n\n\n{\n    \naccess_token\n : \n1vtnuo1NkIsbndAjVnhl7y0wJha59JyaAiFIVQDvcBY2uvKmj5EPBEhss0pauzdQ\n,\n    \ntoken_type\n : \nBearer\n,\n    \nuser_id\n : \nadmin\n\n}\n\n\n\n\nF\u00fcr die Token-Generierung wurde die Hilfsklasse \nUtilities\n mit der statischen Funktion \ngenerateRandom\n geschrieben, die mithilfe einer ownCloud-internen Funktion 64-stellige Zeichenketten erzeugt. Folgendes Codebeispiel zeigt diese Klasse.\n\n\n?php\nnamespace OCA\\OAuth2;\n\nclass Utilities {\n\n    /**\n     * Generates a random string with 64 characters.\n     *\n     * @return string The random string.\n     */\n    public static function generateRandom() {\n        return \\OC::$server-\ngetSecureRandom()-\ngenerate(64,\n            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789');\n    }\n\n}\n\n\n\n\nZusammenfassend werden im folgenden UML-Klassendiagramm die Controller mit ihren Beziehungen zu den Entities und Mappern dargestellt.\n\n\n\n  \nTODO:\n Klassendiagramm einf\u00fcgen.\n\n\n\n\nTemplates\n\n\nF\u00fcr die zweckm\u00e4\u00dfige Nutzung der OAuth2 App sind Templates von N\u00f6ten. Relevant sind diese als Darstellung des Authorisierungsfenster, sprich der Hauptfunktionalit\u00e4t der App, f\u00fcr die Einstellungen des Admins und in den pers\u00f6nlichen Einstellungen. \n    \nauthorize\n stellt ein umrahmtes Fenster mit entsprechendem Text zur Authorisierung und der M\u00f6glichkeit die Authorisierung zu akzeptieren oder abzulehnen dar.\n    \nsettings-admin\n stellt eine tabellarische Auflistung der registrierten Clients und ihrer jeweiligen redirectURIs, Identifiers und Secrets mit M\u00f6glichkeit die entsprechende Registrierung zu l\u00f6schen dar, oder eine Meldung, dass kein Client registriert sind. Zus\u00e4tzlich gibt es eine Eingabemaske zur Registrierung von neuen Clients, die einen Namen und eine redirectURI fordert.\n    \nsettings-personal\n stellt eine tabellarische Auflistung der autorisierten Applikationen mit M\u00f6glichkeit die entsprechende Authorisierung zu l\u00f6schen dar, oder eine Meldung, dass keine Applikationen authorisiert sind.\n\n\n\n\nTODO:\n Screenshots einf\u00fcgen.\n\n\n\n\nProtokollablauf\n\n\nTests\n\n\nZum Testen der PHP-Klassen wurde das Framework \nPHPUnit\n verwendet. Die aktuelle Testabdeckung ist bei Codecov einsehbar: \n.\n\n\nContinuous Integration\n\n\nAls Continuous Integration Integration Tool wurde Travis CI verwendet. Bei jeder \u00c4nderung im \nGitHub Repository\n wird ein Build angesto\u00dfen, in dem die App mithilfe eines Makefiles f\u00fcr den App Store gebaut wird und anschlie\u00dfend in verschiedenen Umgebungen installiert und getestet wird. Folgende Parameter werden variiert:\n\n\n\n\nPHP Versionen\n: 5.6, 7.0, 7.1, nightly\n\n\nDatenbanken\n: PostgreSQL, MySQL, SQLite\n\n\nBranches des ownCloud Core\n: \nstable9.1\n, \nmaster\n\n\n\n\nDer aktuelle Build-Status ist bei Travis einsehbar: \n.\n\n\nAnpassung der \ndav\n App\n\n\nAuthentication Backend\n\n\nTests", 
            "title": "Technische Umsetzung"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#technische-umsetzung", 
            "text": "Da man m\u00f6glichst keine neue Schnittstelle implementieren wollte, war es das Ziel, die bestehende WebDAV Schnittstelle um OAuth 2.0 zu erweitern. Die WebDAV Schnittstelle ist als  ownCloud App  realisiert worden und nutzt die  sabre/dav  Bibliothek. Auf der anderen Seite musste das OAuth 2.0 Protokoll mit seinen Schnittstellen bereitgestellt werden, um die Authentifizierung in der WebDAV App um OAuth 2.0 zu erweitern zu k\u00f6nnen. Daf\u00fcr wurde eine weitere ownCloud App implementiert.", 
            "title": "Technische Umsetzung"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#implementierung-der-oauth2-app", 
            "text": "In der App sollte der h\u00e4ufig f\u00fcr Webapplikationen eingesetzte  Authorization Code Flow  implementiert werden. Dazu mussten folgende User Stories umgesetzt werden:   Clientregistrierung:  Als ownCloud-Administrator m\u00f6chte ich Clients in den Administrator-Einstellungen hinzuf\u00fcgen und l\u00f6schen k\u00f6nnen, um die Kontrolle \u00fcber erlaubte Clients zu haben.  Authorization URL:  Als Client-Entwickler m\u00f6chte ich eine Authorization URL zur Verf\u00fcgung haben, um Authorization Codes anfordern zu k\u00f6nnen.  Access Token URL:  Als Client-Entwickler m\u00f6chte ich eine Access Token URL zur Verf\u00fcgung haben, um Access Tokens anfordern zu k\u00f6nnen.  Verwaltung autorisierter Applikationen : Als ownCloud-Nutzer m\u00f6chte ich in den pers\u00f6nlichen Einstellungen autorisierte Applikationen verwalten k\u00f6nnen, um einen \u00dcberblick zu haben und Autorisierungen widerrufen zu k\u00f6nnen.", 
            "title": "Implementierung der oauth2 App"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#datenmodell", 
            "text": "Zun\u00e4chst musste ein Datenmodell zur Speicherung der ben\u00f6tigten Daten aufgestellt werden. Gem\u00e4\u00df dem Authorization Code Flow wurden folgende Entit\u00e4ten mit Attributen definiert:   client :  Die Applikation, die f\u00fcr den Zugriff auf die WebDAV Schnittstelle autorisiert werden soll.  identifier : Zeichenkette, die einen Client eindeutig identifiziert.  secret : Zeichenkette, mit der ein Client sich beim Anfordern eines Access Tokens authentifizieren kann.  redirect_uri : URI, an die nach erfolgter Autorisierung des Nutzers weitergeleitet wird.    authorization_code :  Ein  Authorization Grant , mit dem der Client die Autorisierung des Nutzers darlegen und somit ein Access Token anfordern kann.  code : Zeichenkette, die als Authorization Code dient.  client_id : Client Identifier des Clients, f\u00fcr den der Authorization Code ausgegeben wird.  user_id : User ID des ownCloud-Nutzers, der den Client autorisiert hat.  expires : Zeitpunkt, zu dem der Authorization Code ung\u00fcltig wird (optional).    access_token :  Eine Zeichenkette, die den Zugriff auf die WebDAV Schnittstelle erlaubt.  code : Zeichenkette, die als Access Token dient.  client_id : Client Identifier des Clients, f\u00fcr den der Access Token ausgegeben wird.  user_id : User ID des ownCloud-Nutzers, der den Client autorisiert hat.  expires : Zeitpunkt, zu dem der Access Token ung\u00fcltig wird (optional).    refresh_token :  Eine Zeichenkette, mit der ein abgelaufener Access Token gegen einen neuen ausgetauscht werden kann.  code : Zeichenkette, die als Refresh Token dient.  client_id : Client Identifier des Clients, f\u00fcr den der Access Token ausgegeben wird.  user_id : User ID des ownCloud-Nutzers, der den Client autorisiert hat.  expires : Zeitpunkt, zu dem der Refresh Token ung\u00fcltig wird (optional).     Folgendes Entity-Relationship-Modell fasst das Datenmodell nochmal grafisch zusammen.  \n   TODO:  ERM einf\u00fcgen.", 
            "title": "Datenmodell"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#mapper-und-entities", 
            "text": "F\u00fcr den Datenbank-Zugriff im PHP-Code ist es in ownCloud m\u00f6glich,  Mapper  und  Entities  zu schreiben. Dadurch werden Tupel in einer Datenbank-Tabelle automatisch in ein Objekt umgewandelt.  Folgendes Codebeispiel zeigt am Beispiel des Entitys  Client , wie eine PHP-Klasse dazu aussehen muss.  ?php\nnamespace OCA\\OAuth2\\Db;\n\nuse OCP\\AppFramework\\Db\\Entity;\n\n/**\n * Class Client\n *\n * @method string getIdentifier()\n * @method void setIdentifier(string $identifier)\n * @method string getSecret()\n * @method void setSecret(string $secret)\n * @method string getRedirectUri()\n * @method void setRedirectUri(string $redirectUri)\n * @method string getName()\n * @method void setName(string $name)\n */\nclass Client extends Entity {\n\n    protected $identifier;\n    protected $secret;\n    protected $redirectUri;\n    protected $name;\n\n    public function __construct() {\n        $this- addType('id', 'int');\n        $this- addType('identifier', 'string');\n        $this- addType('secret', 'string');\n        $this- addType('redirect_uri', 'string');\n        $this- addType('name', 'string');\n    }\n\n}  Wichtig ist, dass die Klasse von  Entity  erbt und sowohl der Klassenname als auch die Attribute mit denen der Tabelle \u00fcbereinstimmen. Pascal bzw. Camel case im PHP-Code wird automatisch zu Snake case f\u00fcr die Datenbank umgewandelt. Getter und Setter werden ebenfalls automatisch generiert. Die PHPDoc Kommentare dienen lediglich dazu, in der Entwicklungsumgebung eine automatische Vervollst\u00e4ndigung zu haben. Die Angabe von  Typen  im Konstruktor dienen dazu, beim Lesen aus der Datenbank die richtige Umwandlung zu erhalten.  Das folgende Codebeispiel zeigt einen Ausschnitt aus dem zur  Client  Entity geh\u00f6renden Mapper.  ?php\nnamespace OCA\\OAuth2\\Db;\n\nuse InvalidArgumentException;\nuse OCP\\AppFramework\\Db\\Entity;\nuse OCP\\IDb;\nuse OCP\\AppFramework\\Db\\Mapper;\n\nclass ClientMapper extends Mapper {\n\n    /**\n     * ClientMapper constructor.\n     *\n     * @param IDb $db Database Connection.\n     */\n    public function __construct(IDb $db) {\n        parent::__construct($db, 'oauth2_clients');\n    }\n\n    /**\n     * Selects a client by its ID.\n     *\n     * @param int $id The client's ID.\n     *\n     * @return Entity The client entity.\n     *\n     * @throws \\OCP\\AppFramework\\Db\\DoesNotExistException if not found.\n     * @throws \\OCP\\AppFramework\\Db\\MultipleObjectsReturnedException if more than one result.\n     */\n    public function find($id) {\n        if (!is_int($id)) {\n            throw new InvalidArgumentException('id must not be null');\n        }\n\n        $sql = 'SELECT * FROM `' . $this- tableName . '` WHERE `id` = ?';\n        return $this- findEntity($sql, array($id), null, null);\n    }\n\n    /**\n     * Selects clients by the given user ID.\n     *\n     * @param string $userId The user ID.\n     *\n     * @return array The client entities.\n     */\n    public function findByUser($userId) {\n        if (!is_string($userId)) {\n            throw new InvalidArgumentException('userId must not be null');\n        }\n\n        $sql = 'SELECT * FROM `' . $this- tableName . '` '\n            . 'WHERE `id` IN ( '\n                . 'SELECT `client_id` FROM `oc_oauth2_authorization_codes` WHERE `user_id` = ? '\n                . 'UNION '\n                . 'SELECT `client_id` FROM `oc_oauth2_access_tokens` WHERE `user_id` = ? '\n            .')';\n        return $this- findEntities($sql, array($userId, $userId), null, null);\n    }\n\n}  Beim Mapper ist es wichtig, dass die Klasse von  Mapper  erbt und eine Entity-Klasse zu ihm existiert. Dazu wird das Wort vor \u201eMapper\u201c als Entityname verwendet. Im Konstruktur wird der Tabellenname angegeben. Die beiden Funktionen  find  und  findByUser  demonstrieren  SELECT -Anweisungen. Dazu wird die SQL-Anweisungen zusammen mit ben\u00f6tigten Parametern an  findEntity  bzw.  findEntities  \u00fcbergeben, abh\u00e4ngig davon, ob mehrere Entities im Ergebnis enthalten sein sollten. Funktionen zum l\u00f6schen, einf\u00fcgen und updaten werden von der Oberklasse bereits implementiert und mussten nicht angepasst werden.", 
            "title": "Mapper und Entities"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#schnittstellen-und-routes", 
            "text": "Um in einer ownCloud App Schnittstellen anzubieten, m\u00fcssen  Routes  registriert werden. Zur Umsetzung der erw\u00e4hnten User Stories waren folgende Routes notwendig:     Methode  Endpunkt  Beschreibung      GET  authorize  Endpunkt, zu dem der Client den Nutzer weiterleitet, um die Autorisierung anzufragen (Authorization URL).    POST  authorize  Endpunkt, der aufgerufen wird, sobald der Nutzer den Client autorisiert hat.    POST  api/v1/token  Endpunkt, an dem ein Access Token angefordert wird (Access Token URL).    POST  clients  Endpunkt, durch den der Administrator einen Client hinzuf\u00fcgen kann.    POST  clients/{id}/delete  Endpunkt, durch den der Administrator den Client mit der ID  id  l\u00f6schen kann.    POST  clients/{id}/revoke  Endpunkt, durch den der Nutzer die Autorisierung des Clients mit der ID  id  widerrufen kann.     Registriert werden die Routes in der Datei  routes.php , indem ein Array mit den Routes zur\u00fcckgegeben wird. Nachfolgendes Codebeispiel zeigt einige der obigen Routes:  ?php\nreturn [\n    'routes' =  [\n        ['name' =  'page#authorize', 'url' =  '/authorize', 'verb' =  'GET'],\n        ['name' =  'o_auth_api#generate_token', 'url' =  '/api/v1/token', 'verb' =  'POST'],\n        ['name' =  'settings#deleteClient', 'url' =  '/clients/{id}/delete', 'verb' =  'POST']\n    ]\n];  Durch  name  wird f\u00fcr jede Route der Name des dazugeh\u00f6rigen  Controllers  sowie die aufzurufende Funktion angegeben. Vor dem  # -Zeichen steht der Controllername in Snake case und hinter dem  # -Zeichen steht der Funktionsname (ebenfalls in Snake case). Mithilfe von  url  wird der Endpunkt festgelegt und  verb  definiert die HTTP-Methode.", 
            "title": "Schnittstellen und Routes"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#controller", 
            "text": "Wenn an einem Endpunkt eine HTTP-Anfrage ankommt, so wird der in den Routes definierte  Controller  aufgerufen. Wichtig ist hierbei, dass von der Klasse  Controller  oder einer Unterklasse wie  ApiController  geerbt wird.  F\u00fcr den Controller notwendige Parameter wie  Mapper  k\u00f6nnen im Konstruktor als Parameter angegeben und so durch  Dependency Injection  erhalten werden. Nachfolgendes Codebeispiel zeigt den Konstruktor vom  PageController .  /**\n * PageController constructor.\n * \n * @param string $AppName The name of the app.\n * @param IRequest $request The request.\n * @param ClientMapper $clientMapper The client mapper.\n * @param AuthorizationCodeMapper $authorizationCodeMapper The authorization code mapper.\n * @param string $UserId The user ID.\n */\npublic function __construct($AppName, IRequest $request, ClientMapper $clientMapper,\n    AuthorizationCodeMapper $authorizationCodeMapper, $UserId) {\n    parent::__construct($AppName, $request);\n\n    $this- clientMapper = $clientMapper;\n    $this- authorizationCodeMapper = $authorizationCodeMapper;\n    $this- userId = $UserId;\n}  Die hier notwendigen Parameter sind der Name der App, eine  ClientMapper  Instanz, eine  AuthorizationCodeMapper  Instanz und die ID des Nutzers, um bei der Autorisierung des Clients speichern zu k\u00f6nnen, welcher Nutzers dies veranlasst hat.  Die mit den Routes verkn\u00fcpften Funktionen k\u00f6nnen zur Zugriffskontrolle mit  PHPDoc Annotationen  versehen werden. Folgendes Codebeispiel zeigt die Annotationen f\u00fcr die Funktion  generateToken  im  OAuthApiController .  /**\n * Implements the OAuth 2.0 Access Token Response.\n *\n * @param string $code The authorization code.\n * @return JSONResponse The Access Token or an empty JSON Object.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n * @PublicPage\n * @CORS\n */\npublic function generateToken($code) { }  Die Annotationen haben dabei folgende Bedeutungen.     Annotation  Bedeutung      @NoAdminRequired  Aufruf auch von normalen Nutzern m\u00f6glich.    @NoCSRFRequired  Zeigt an, dass die \u00dcberpr\u00fcfung des CSRF Tokens nicht gewollt ist.    @PublicPage  Zugriff auch ohne Login m\u00f6glich.    @CORS  Aufruf der API durch andere Web Applikationen von au\u00dfen m\u00f6glich.     In den Controller-Funktionen k\u00f6nnen verschiedene Inhalte zur\u00fcckgegeben werden. Hier genutzte R\u00fcckgabetypen sind in der folgenden Tabelle zusammengefasst.     Typ  Beschreibung      TemplateResponse  Zur R\u00fcckgabe eines Templates, das dem Nutzer angezeigt werden soll.    RedirectResponse  Zur Weiterleitung des Nutzers an eine andere URL.    JSONResponse  Zur R\u00fcckgabe eines JSON Strings.     Ein Beispiel f\u00fcr die R\u00fcckgabetypen  TemplateResponse  und  RedirectResponse  gibt die Funktion  authorize  im  PageController , die im folgenden Codebeispiel zu sehen ist.  /**\n * Shows a view for the user to authorize a client.\n *\n * @param string $response_type The expected response type.\n * @param string $client_id The client identifier.\n * @param string $redirect_uri The redirect URI.\n * @param string $state The state.\n * @param string $scope The scope.\n *\n * @return TemplateResponse|RedirectResponse The authorize view or a\n * redirection to the ownCloud main page.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n */\npublic function authorize($response_type, $client_id, $redirect_uri, $state = null, $scope = null) {\n    if (!is_string($response_type) || !is_string($client_id)\n        || !is_string($redirect_uri) || (isset($state)   !is_string($state))\n        || (isset($scope)   !is_string($scope))) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    try {\n        /** @var Client $client */\n        $client = $this- clientMapper- findByIdentifier($client_id);\n    } catch (DoesNotExistException $exception) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    if (strcmp($client- getRedirectUri(), urldecode($redirect_uri)) !== 0) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n    if (strcmp($response_type, 'code') !== 0) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    return new TemplateResponse('oauth2', 'authorize', ['client_name' =  $client- getName()]);\n}  Hier werden zun\u00e4chst die Parameter auf G\u00fcltigkeit \u00fcberpr\u00fcft. Sollten die Parameter nicht g\u00fcltig sein (beispielsweise deshalb, weil der angegebene Client nicht existiert oder dessen Redirect URI falsch angegeben wurde) wird mit einem  RedirectResponse  auf die ownCloud Startseite umgeleitet. Andernfalls wird ein  TemplateResponse  f\u00fcr das Template  authorize  zur\u00fcckgegeben. F\u00fcr das Rendern des Templates k\u00f6nnen Parameter wie hier  client_name  f\u00fcr den Namen des Clients \u00fcbergeben werden.  Der R\u00fcckgabetyp  JSONResponse  wird f\u00fcr die R\u00fcckgabe des Access Tokens in der Funktion  generateToken  im  OAuthApiController  genutzt, wie nachfolgendes Codebeispiel zeigt. Zudem ist das Zusammenspiel mit Entities und Mappern zu sehen.  /**\n * Implements the OAuth 2.0 Access Token Response.\n *\n * @param string $code The authorization code.\n * @return JSONResponse The Access Token or an empty JSON Object.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n * @PublicPage\n * @CORS\n */\npublic function generateToken($code) {\n    if (is_null($code) || is_null($_SERVER['PHP_AUTH_USER'])\n        || is_null($_SERVER['PHP_AUTH_PW'])) {\n        return new JSONResponse(['message' =  'Missing credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    try {\n        /** @var Client $client */\n        $client = $this- clientMapper- findByIdentifier($_SERVER['PHP_AUTH_USER']);\n    } catch (DoesNotExistException $exception) {\n        return new JSONResponse(['message' =  'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    if (strcmp($client- getSecret(), $_SERVER['PHP_AUTH_PW']) !== 0) {\n        return new JSONResponse(['message' =  'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    try {\n        /** @var AuthorizationCode $authorizationCode */\n        $authorizationCode = $this- authorizationCodeMapper- findByCode($code);\n    } catch (DoesNotExistException $exception) {\n        return new JSONResponse(['message' =  'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    if (strcmp($authorizationCode- getClientId(), $client- getId()) !== 0) {\n        return new JSONResponse(['message' =  'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    $token = Utilities::generateRandom();\n    $userId = $authorizationCode- getUserId();\n    $accessToken = new AccessToken();\n    $accessToken- setToken($token);\n    $accessToken- setClientId($authorizationCode- getClientId());\n    $accessToken- setUserId($userId);\n    $this- accessTokenMapper- insert($accessToken);\n\n    $this- authorizationCodeMapper- delete($authorizationCode);\n\n    return new JSONResponse(\n        [\n            'access_token' =  $token,\n            'token_type' =  'Bearer',\n            'user_id' =  $userId\n        ]\n    );\n}  Nach erfolgreicher \u00dcberpr\u00fcfung des Authorization Codes und der Angaben zur Client Authentication im Authorization Header wird eine neuer Access Token erstellt und in der Datenbank gespeichert. Der verwendete Authorization Code wird zudem gel\u00f6scht. Im JSON Response wird dann der Access Token, der Token Typ und die ID des Nutzers zur\u00fcckgegeben. Nachfolgend ist ein Beispiel dazu angegeben.  {\n     access_token  :  1vtnuo1NkIsbndAjVnhl7y0wJha59JyaAiFIVQDvcBY2uvKmj5EPBEhss0pauzdQ ,\n     token_type  :  Bearer ,\n     user_id  :  admin \n}  F\u00fcr die Token-Generierung wurde die Hilfsklasse  Utilities  mit der statischen Funktion  generateRandom  geschrieben, die mithilfe einer ownCloud-internen Funktion 64-stellige Zeichenketten erzeugt. Folgendes Codebeispiel zeigt diese Klasse.  ?php\nnamespace OCA\\OAuth2;\n\nclass Utilities {\n\n    /**\n     * Generates a random string with 64 characters.\n     *\n     * @return string The random string.\n     */\n    public static function generateRandom() {\n        return \\OC::$server- getSecureRandom()- generate(64,\n            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789');\n    }\n\n}  Zusammenfassend werden im folgenden UML-Klassendiagramm die Controller mit ihren Beziehungen zu den Entities und Mappern dargestellt.  \n   TODO:  Klassendiagramm einf\u00fcgen.", 
            "title": "Controller"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#templates", 
            "text": "F\u00fcr die zweckm\u00e4\u00dfige Nutzung der OAuth2 App sind Templates von N\u00f6ten. Relevant sind diese als Darstellung des Authorisierungsfenster, sprich der Hauptfunktionalit\u00e4t der App, f\u00fcr die Einstellungen des Admins und in den pers\u00f6nlichen Einstellungen. \n     authorize  stellt ein umrahmtes Fenster mit entsprechendem Text zur Authorisierung und der M\u00f6glichkeit die Authorisierung zu akzeptieren oder abzulehnen dar.\n     settings-admin  stellt eine tabellarische Auflistung der registrierten Clients und ihrer jeweiligen redirectURIs, Identifiers und Secrets mit M\u00f6glichkeit die entsprechende Registrierung zu l\u00f6schen dar, oder eine Meldung, dass kein Client registriert sind. Zus\u00e4tzlich gibt es eine Eingabemaske zur Registrierung von neuen Clients, die einen Namen und eine redirectURI fordert.\n     settings-personal  stellt eine tabellarische Auflistung der autorisierten Applikationen mit M\u00f6glichkeit die entsprechende Authorisierung zu l\u00f6schen dar, oder eine Meldung, dass keine Applikationen authorisiert sind.   TODO:  Screenshots einf\u00fcgen.", 
            "title": "Templates"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#protokollablauf", 
            "text": "", 
            "title": "Protokollablauf"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#tests", 
            "text": "Zum Testen der PHP-Klassen wurde das Framework  PHPUnit  verwendet. Die aktuelle Testabdeckung ist bei Codecov einsehbar:  .", 
            "title": "Tests"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#continuous-integration", 
            "text": "Als Continuous Integration Integration Tool wurde Travis CI verwendet. Bei jeder \u00c4nderung im  GitHub Repository  wird ein Build angesto\u00dfen, in dem die App mithilfe eines Makefiles f\u00fcr den App Store gebaut wird und anschlie\u00dfend in verschiedenen Umgebungen installiert und getestet wird. Folgende Parameter werden variiert:   PHP Versionen : 5.6, 7.0, 7.1, nightly  Datenbanken : PostgreSQL, MySQL, SQLite  Branches des ownCloud Core :  stable9.1 ,  master   Der aktuelle Build-Status ist bei Travis einsehbar:  .", 
            "title": "Continuous Integration"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#anpassung-der-dav-app", 
            "text": "", 
            "title": "Anpassung der dav App"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#authentication-backend", 
            "text": "", 
            "title": "Authentication Backend"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#tests_1", 
            "text": "", 
            "title": "Tests"
        }, 
        {
            "location": "/owncloud/benutzung/", 
            "text": "Benutzung\n\n\nInstallation\n\n\n\n\nHinweis:\n Zur Zeit liegen die Anpassungen der \ndav\n App als \nPull Request\n vor. Falls die \u00c4nderungen angenommen werden, sind sie in einer der n\u00e4chsten ownCloud Versionen enthalten.\n\n\n\n\nDa die \u00c4nderungen zum aktuellen Zeitpunkt noch nicht in den Core aufgenommen wurden, muss der \ndav-oauth\n-Branch des \ngeforkten Repositorys\n geklont werden:\n\n\n$ git clone -b dav-oauth https://github.com/pssl16/core\n\n\n\n\nDanach m\u00fcssen die Dependencies installiert werden. Dazu gen\u00fcgt es, im Verzeichnis des Repositorys folgenden Befehl auszuf\u00fchren:\n\n\n$ make\n\n\n\n\nDie restlichen Installationsschritte unterscheiden sich nicht von denen im \nownCloud Handbuch\n.\n\n\nClientregistrierung\n\n\nAuthorization Code Flow\n\n\nDie nachfolgende Abbildung stellt den durch die \noauth2\n App implementierten \nOAuth 2.0 Authorization Code Flow\n dar.\n\n\n\n\n\n  \nTODO:\n Beschreibung der Schritte einf\u00fcgen.\n\n\n\n\nAngepasste WebDAV Schnittstelle", 
            "title": "Benutzung"
        }, 
        {
            "location": "/owncloud/benutzung/#benutzung", 
            "text": "", 
            "title": "Benutzung"
        }, 
        {
            "location": "/owncloud/benutzung/#installation", 
            "text": "Hinweis:  Zur Zeit liegen die Anpassungen der  dav  App als  Pull Request  vor. Falls die \u00c4nderungen angenommen werden, sind sie in einer der n\u00e4chsten ownCloud Versionen enthalten.   Da die \u00c4nderungen zum aktuellen Zeitpunkt noch nicht in den Core aufgenommen wurden, muss der  dav-oauth -Branch des  geforkten Repositorys  geklont werden:  $ git clone -b dav-oauth https://github.com/pssl16/core  Danach m\u00fcssen die Dependencies installiert werden. Dazu gen\u00fcgt es, im Verzeichnis des Repositorys folgenden Befehl auszuf\u00fchren:  $ make  Die restlichen Installationsschritte unterscheiden sich nicht von denen im  ownCloud Handbuch .", 
            "title": "Installation"
        }, 
        {
            "location": "/owncloud/benutzung/#clientregistrierung", 
            "text": "", 
            "title": "Clientregistrierung"
        }, 
        {
            "location": "/owncloud/benutzung/#authorization-code-flow", 
            "text": "Die nachfolgende Abbildung stellt den durch die  oauth2  App implementierten  OAuth 2.0 Authorization Code Flow  dar.   \n   TODO:  Beschreibung der Schritte einf\u00fcgen.", 
            "title": "Authorization Code Flow"
        }, 
        {
            "location": "/owncloud/benutzung/#angepasste-webdav-schnittstelle", 
            "text": "", 
            "title": "Angepasste WebDAV Schnittstelle"
        }, 
        {
            "location": "/moodle/software-architektur/", 
            "text": "Software Architektur\n\n\nMoodle\n ist eine Open Source Online Lehr- und Lernplattform in Form einer Webapplikation, welche an zahlreichen \nUniversit\u00e4ten und diversen anderen Institutionen im Bildungssektor weltweit als Kommunikationswerkzeug eingesetzt wird. \n\n\nZur Umsetzung des Projektziels, musste moodle um n\u00f6tige Funktionalit\u00e4ten erg\u00e4nzt werden, die weder durch den \nmoodle Core\n\nbereitgestellt werden, noch mit Hilfe von externen Plugins hinzugef\u00fcgt werden konnten. Im Folgenden wird beschrieben, \nwie moodle im Rahmen des Projektes erweitert wurde und welche Auswirkungen sich daraus ergaben.\n\n\n\u00dcbersicht \u00fcber die Plugin-Struktur\n\n\nMoodle \nPlugins\n dienen dazu um im Core angebotene Funktionalit\u00e4ten dahingehend zu erweitern, sodass diese den \nindividuellen Bed\u00fcrfnissen des Nutzers entsprechen. Daher eignete sich die Implementierung solcher Plugins ideal zur \nUmsetzung der definierten Integrationsszenarien.\nIn moodle wird ein plugin einer Kategorie zugeordnet, welche eine Bestimmte Art von Funktionalit\u00e4t repr\u00e4sentiert. \n\n\nIm Laufe des Projekts hat man sich auf folgende zu implementierende Plugins geeinigt:\n\n\n\n\n\n\n\n\nPlugintyp\n\n\nBeschreibung\n\n\nZweck f\u00fcr das Projekt\n\n\n\n\n\n\n\n\n\n\nadmin tool\n\n\nBietet Dienste zur Site-Administration an\n\n\nVerwaltung der Authentifizierung mittels OAuth 2.0\n\n\n\n\n\n\nrepository\n\n\nStellt Verbindung zu einer externen Datenquelle her\n\n\nDatenbeschaffung aus Sciebo\n\n\n\n\n\n\nactivity\n\n\nStellt Aktivit\u00e4t in einem Kurs zur Verf\u00fcgung\n\n\nBereitstellung eines Ordners f\u00fcr kollaborative Arbeit\n\n\n\n\n\n\n\n\nZwar bietet das \nRepository Plugin\n die n\u00f6tige Funktionalit\u00e4t \u00fcber die gegebene \n\nSchnittstelle\n um Dateien aus Sciebo nach moodle hochzuladen, jedoch kann \u00fcber die Schnittstelle \nhinaus keine weitere Funktionalit\u00e4t darin implementiert werden. Weil daher nur eine beschr\u00e4nkte Anzahl von \nIntegrationsszenarien abgedeckt werden w\u00fcrde, hat man sich f\u00fcr ein erg\u00e4nzendes \nActivity Module\n \nenschieden. Basierend auf dieser Entscheidung erschien es als sinnvoll den \nAuthentifizierungsprozess\n ebenfalls zentral \nzu implementieren, sodass allen zus\u00e4tzlichen Plugins der Zugriff auf das Verfahren erm\u00f6glicht wird.\n\n\nAbh\u00e4ngigkeiten\n\n\nDie aus der Aufteilung der Funktionen in verschiedene Plugins resultierenden Abh\u00e4ngigkeiten werden in folgender Abbildung\ndargestellt:\n\n\n\n  \nTODO:\n Grafik einf\u00fcgen.\n\n\n\n\nZu beachten ist, dass eine m\u00f6glichst hohe Flexibilit\u00e4t und Modularit\u00e4t bei dem Entwurf der Software Architektur erzielt\nwerden sollte. Das f\u00fchrt zwar mit sich, dass funktionale Plugins (also das \nrepository\n und das \nactivity\n Plugin) nicht\neigenst\u00e4ndig ohne das \nadmin tool\n existieren k\u00f6nnen, allerdings wird weiteren, in Zukunft entwickelten Plugins ebenfalls\nZugriff auf die OAuth 2.0 Schnittstelle in \nSciebo\n bzw. \nownCloud\n erm\u00f6glicht,\nwodurch sich das Projektergebnis zu einer guten Wiederverwendbarkeit qualifiziert.\n\n\nFunktions\u00fcbersicht\n\n\nDie in den verschiedenen Plugins angebotenen Funktionalit\u00e4ten k\u00f6nnen wie folgt zusammengefasst werden:\n\n\n\n\nAdmin Tool\n:\n \noauth2sciebo\n\n\nUmfasst sowohl OAuth 2.0, als auch WebDAV Client.\n\n\nSteuert Protokollablauf von OAuth 2.0 und verwaltet alle dazu n\u00f6tigen Informationen.\n\n\nStellt das Verbindungsst\u00fcck von moodle zu Sciebo bzw. ownCloud\n\n\n\n\n\n\nRepository\n:\n \nsciebo\n\n\nBewerkstelligt die Datenbeschaffung aus Sciebo bzw. ownCloud nach moodle.\n\n\nErm\u00f6glicht den Upload von Dateien aus einer pers\u00f6nlichen Sciebo Instanz.\n\n\nErm\u00f6glicht die Verlinkung von Dateien aus Sciebo in moodle.\n\n\n\n\n\n\nActivity Module\n:\n \ncollaborative folders\n\n\nErm\u00f6glicht die Erstellung und Freigabe von Ordern in Sciebo f\u00fcr bestimmte Gruppen in moodle.\n\n\n\n\n\n\n\n\n\n  \nTODO:\n Liste im Laufe weiterer Sprints erweitern.", 
            "title": "Software Architektur"
        }, 
        {
            "location": "/moodle/software-architektur/#software-architektur", 
            "text": "Moodle  ist eine Open Source Online Lehr- und Lernplattform in Form einer Webapplikation, welche an zahlreichen \nUniversit\u00e4ten und diversen anderen Institutionen im Bildungssektor weltweit als Kommunikationswerkzeug eingesetzt wird.   Zur Umsetzung des Projektziels, musste moodle um n\u00f6tige Funktionalit\u00e4ten erg\u00e4nzt werden, die weder durch den  moodle Core \nbereitgestellt werden, noch mit Hilfe von externen Plugins hinzugef\u00fcgt werden konnten. Im Folgenden wird beschrieben, \nwie moodle im Rahmen des Projektes erweitert wurde und welche Auswirkungen sich daraus ergaben.", 
            "title": "Software Architektur"
        }, 
        {
            "location": "/moodle/software-architektur/#ubersicht-uber-die-plugin-struktur", 
            "text": "Moodle  Plugins  dienen dazu um im Core angebotene Funktionalit\u00e4ten dahingehend zu erweitern, sodass diese den \nindividuellen Bed\u00fcrfnissen des Nutzers entsprechen. Daher eignete sich die Implementierung solcher Plugins ideal zur \nUmsetzung der definierten Integrationsszenarien.\nIn moodle wird ein plugin einer Kategorie zugeordnet, welche eine Bestimmte Art von Funktionalit\u00e4t repr\u00e4sentiert.   Im Laufe des Projekts hat man sich auf folgende zu implementierende Plugins geeinigt:     Plugintyp  Beschreibung  Zweck f\u00fcr das Projekt      admin tool  Bietet Dienste zur Site-Administration an  Verwaltung der Authentifizierung mittels OAuth 2.0    repository  Stellt Verbindung zu einer externen Datenquelle her  Datenbeschaffung aus Sciebo    activity  Stellt Aktivit\u00e4t in einem Kurs zur Verf\u00fcgung  Bereitstellung eines Ordners f\u00fcr kollaborative Arbeit     Zwar bietet das  Repository Plugin  die n\u00f6tige Funktionalit\u00e4t \u00fcber die gegebene  Schnittstelle  um Dateien aus Sciebo nach moodle hochzuladen, jedoch kann \u00fcber die Schnittstelle \nhinaus keine weitere Funktionalit\u00e4t darin implementiert werden. Weil daher nur eine beschr\u00e4nkte Anzahl von \nIntegrationsszenarien abgedeckt werden w\u00fcrde, hat man sich f\u00fcr ein erg\u00e4nzendes  Activity Module  \nenschieden. Basierend auf dieser Entscheidung erschien es als sinnvoll den  Authentifizierungsprozess  ebenfalls zentral \nzu implementieren, sodass allen zus\u00e4tzlichen Plugins der Zugriff auf das Verfahren erm\u00f6glicht wird.", 
            "title": "\u00dcbersicht \u00fcber die Plugin-Struktur"
        }, 
        {
            "location": "/moodle/software-architektur/#abhangigkeiten", 
            "text": "Die aus der Aufteilung der Funktionen in verschiedene Plugins resultierenden Abh\u00e4ngigkeiten werden in folgender Abbildung\ndargestellt:  \n   TODO:  Grafik einf\u00fcgen.  Zu beachten ist, dass eine m\u00f6glichst hohe Flexibilit\u00e4t und Modularit\u00e4t bei dem Entwurf der Software Architektur erzielt\nwerden sollte. Das f\u00fchrt zwar mit sich, dass funktionale Plugins (also das  repository  und das  activity  Plugin) nicht\neigenst\u00e4ndig ohne das  admin tool  existieren k\u00f6nnen, allerdings wird weiteren, in Zukunft entwickelten Plugins ebenfalls\nZugriff auf die OAuth 2.0 Schnittstelle in  Sciebo  bzw.  ownCloud  erm\u00f6glicht,\nwodurch sich das Projektergebnis zu einer guten Wiederverwendbarkeit qualifiziert.", 
            "title": "Abh\u00e4ngigkeiten"
        }, 
        {
            "location": "/moodle/software-architektur/#funktionsubersicht", 
            "text": "Die in den verschiedenen Plugins angebotenen Funktionalit\u00e4ten k\u00f6nnen wie folgt zusammengefasst werden:   Admin Tool :   oauth2sciebo  Umfasst sowohl OAuth 2.0, als auch WebDAV Client.  Steuert Protokollablauf von OAuth 2.0 und verwaltet alle dazu n\u00f6tigen Informationen.  Stellt das Verbindungsst\u00fcck von moodle zu Sciebo bzw. ownCloud    Repository :   sciebo  Bewerkstelligt die Datenbeschaffung aus Sciebo bzw. ownCloud nach moodle.  Erm\u00f6glicht den Upload von Dateien aus einer pers\u00f6nlichen Sciebo Instanz.  Erm\u00f6glicht die Verlinkung von Dateien aus Sciebo in moodle.    Activity Module :   collaborative folders  Erm\u00f6glicht die Erstellung und Freigabe von Ordern in Sciebo f\u00fcr bestimmte Gruppen in moodle.     \n   TODO:  Liste im Laufe weiterer Sprints erweitern.", 
            "title": "Funktions\u00fcbersicht"
        }, 
        {
            "location": "/moodle/admin-tool/", 
            "text": "Admin Tool: \noauth2sciebo\n\n\nZweck des Plugins\n\n\nWie bereits im Kapitel \nSoftware Architektur\n angeschnitten, ist der Hauptzweck dieses Plugins\ndie Schnittstelle zu Sciebo bzw. ownCloud bereitzustellen. Zu diesem Zweck wird die im Projekt implementierte ownCloud \nApp \nOAuth2\n mit Hilfe eines OAuth 2.0 Clients \u00fcber die WebDAV Schnittstelle angesprochen.\nGleichzeitig kann dieses Plugin auch f\u00fcr \u00e4hnliche externe Datenquellen verwendet werden, sofern diese \u00fcber die n\u00f6tigen\nOAuth 2.0 und WebDAV Schnittstellen verf\u00fcgen.\n\n\nIm Wesentlichen implementiert dieses Plugin folgende \nIntegrationsszenarien\n:\n\n\n\n\nBeispiel 1:\n ...\n\n\nBeispiel 2:\n ...\n\n\n\n\n\n  \nTODO:\n Integrationsszenarien definieren und hier einf\u00fcgen.\n\n\n\n\nVorgegebene Schnittstelle\n\n\nF\u00fcr Admin Tools ist in moodle lediglich eine schwach definierte Schnittstelle gegeben. Wie in jedem anderen moodle Plugin \nauch, m\u00fcssen zun\u00e4chst einige Standartdateien implementiert werden: \n\n\n\n\nversion.php\n:\n Beschreibt die Versionsnummer des Plugins, die ben\u00f6tigte moodle Version und Abh\u00e4ngigkeiten des Plugins.\n\n\naccess.php\n:\n Legt die Berechtigungen f\u00fcr definierte Aktionen innerhalb des Plugins anhand von Nutzerrollen fest.\n\n\ntool_oauth2sciebo.php\n:\n Beinhaltet Sprachstrings f\u00fcr unterschiedliche Regionen und Sprachen, sodass definierte Strings,\nabh\u00e4ngig von der jeweiligen Sprache, dynamisch angezeigt werden k\u00f6nnen.\n\n\n\n\nZus\u00e4tzlich zu den allgemeinen Plugindateien, sollte unser Admin Tool auch mindestens noch eine Datei namens \nsettings.php\n\nbeinhalten. Diese umfasst alle Einstellungen, die f\u00fcr das Admin Tool geltend dem Administrator der moodle Instanz zur \nVerf\u00fcgung gestellt werden sollen. Nach der Eingabe, wird diese Konfiguration moodle-intern in dem sogenannten \nAdmin Tree\n\ngespeichert. Aus dieser Baumstruktur k\u00f6nnen anschlie\u00dfend ben\u00f6tigte Einstellungen beschafft werden.\n\n\nInsgesamt ergibt sich folgende Struktur von Ordnern und Dateien, die mindestens f\u00fcr die Implementierung des von uns gebrauchten\nAdmin Tools notwendig ist:\n\n\n\n  \nTODO:\n Grafik f\u00fcr Ordnerstruktur einf\u00fcgen.\n\n\n\n\nImplementierung der vorgegebenen Schnittstelle\n\n\nEingabemaske\n\n\nUm die OAuth 2.0 und WebDAV Clients erfolgreich zum Zugriff auf eine entsprechende Sciebo bzw. ownCloud Instanz zu bef\u00e4higen,\nm\u00fcssen diese zun\u00e4chst mit Hilfe ben\u00f6tigter Eingabedaten konfiguriert werden. Diese sollen zentral im Admin Tool eingegeben und\ngespeichert werden k\u00f6nnen, um sie anschlie\u00dfend von anderen Plugins aus nutzen zu k\u00f6nnen. Dies ist einer der Gegens\u00e4tze zu\n\u00e4hnlichen, vor Allem repository Plugins, welche die ben\u00f6tigte Daten auf Plugin-Ebene abfragen und benutzen.\n\n\nEine solche Eingabemaske kann im Rahmen der \nsettings\n definiert werden. Zu diesem Zweck muss zun\u00e4chst ein neues Objekt vom Typ \nadmin_settingpage\n\ninnerhalb der \nsettings.php\n Datei erstellt werden. Dieses Objekt umfasst eine Gruppe von Einstellungen, welche, sobald hinzugef\u00fcgt,\nin dem Admin Tree eingeordnet und gespeichert werden. Die zugeh\u00f6rige Klasse befindet sich in Funktionsbibliothek\n\nadminlib.php\n, welche Teil des moodle Cores ist. Beim \nAufruf des Konstruktors m\u00fcssen Name des Plugins, welcher sp\u00e4ter dazu verwendet wird die Einstellung im Admin Tree wiederzufinden,\nund der Anzeigename f\u00fcr die Einstellungsseite \u00fcbergeben werden. \n\n\nUm den OAuth 2.0 Protokollablauf zu erm\u00f6glichen, m\u00fcssen folgende Daten im Vorfeld erfasst werden:\n\n\n\n\nClient ID\n:\n wird in ownCloud generiert und dient der Identifizierung eines regstrierten Clients.\n\n\nSecret\n:\n wird ebenfalls in ownCloud generiert und zur Authentifizierung verwendet.\n\n\n\n\nBeide Datens\u00e4tze sind Strings und daher eignet sich f\u00fcr beide ein Textfeld zur Eingabe.\n\n\nZur Nutzung des WebDAV Clients werden dar\u00fcber hinaus folgende Daten ben\u00f6tigt:\n\n\n\n\nServer Addresse\n:\n Url \u00fcber die der ownCloud Server erreicht werden kann.\n\n\nServer Pfad\n:\n der angehangene Pfad, \u00fcber den die WebDAV Schnittstelle erreicht werden kann.\n\n\nPort\n:\n Port des WebDAV-Servers.\n\n\nSSL-Verschl\u00fcsselung\n:\n Wahl zwischen HTTP und HTTPS.\n\n\nAuthentifizierung\n:\n Wahl zwischen Basic und Bearer Authentifizierung.  \n\n\n\n\nW\u00e4hrend Server Adresse, Pfad und Port mittels eines Textfeldes abgefragt werden k\u00f6nnen, sollten die anderen Optionen mit Hilfe\neiner Auswahl aus den angebotenen M\u00f6glicheiten erfragt werden k\u00f6nnen.\n\n\nUm nun die Eingabeeinstellungen dem Admin Tree anzuh\u00e4ngen, muss jedes vorgesehene Eingabefeld der \nadmin_settingpage\n \nmittels der Methode \nadd\n hinzugef\u00fcgt werden. Der daf\u00fcr notwendige Code sieht wie folgt aus:\n\n\n?php\n\n$temp = new admin_settingpage('oauth2sciebo', new lang_string('pluginname', 'tool_oauth2sciebo'));\n$temp-\nadd(new admin_setting_heading('coursebank_proxy_head',\n        get_string('configplugin', 'tool_oauth2sciebo'),\n        ''\n        ));\n$temp-\nadd(new admin_setting_configtext('tool_oauth2sciebo/clientid',\n        get_string('clientid', 'tool_oauth2sciebo'),\n        '', ''\n        ));\n$temp-\nadd(new admin_setting_configtext('tool_oauth2sciebo/secret',\n        get_string('secret', 'tool_oauth2sciebo'),\n        '', ''\n        ));\n$temp-\nadd(new admin_setting_configtext('tool_oauth2sciebo/server',\n        get_string('server', 'tool_oauth2sciebo'),\n        '', ''\n    ));\n$temp-\nadd(new admin_setting_configtext('tool_oauth2sciebo/path',\n        get_string('path', 'tool_oauth2sciebo'),\n        '', ''\n    ));\n$temp-\nadd(new admin_setting_configtext('tool_oauth2sciebo/port',\n        get_string('port', 'tool_oauth2sciebo'),\n        '', ''\n    ));\n$temp-\nadd(new admin_setting_configselect('tool_oauth2sciebo/auth',\n        get_string('auth', 'tool_oauth2sciebo'),\n        '', '', array('basic' =\n 'Basic', 'bearer' =\n 'Bearer')\n    ));\n\n$ADMIN-\nadd('authsettings', $temp);\n\n\n\n\nHierbei sind die Klassen \nadmin_setting_heading\n, \nadmin_configtext\n und \nadmin_configselect\n ebenfalls Teil der \nadminlib.php\n\nund die \u00dcberschrift der Einstellungen, eine Eingabetextfeld und eine Eingabeauswahl. Beim Erstellen eines Objektes der Klassen \n\nadmin_configtext\n und \nadmin_configselect\n m\u00fcssen neben dem einzigartigen Einstellungsnamen Anzeigename, Beschreibung und Standartwert\n\u00fcbergeben werden, wobei bei letzterem die Auswahlm\u00f6glichkeiten angegeben werden m\u00fcssen.\n\n\nSobald alle n\u00f6tigen Optionen erstellt worden und der \nadmin_settingpage\n hinzugef\u00fcgt worden sind, muss diese dem Globalen\n\nADMIN\n Objekt hinzugef\u00fcgt werden. Dabei wird auch die Stelle \u00fcbergeben, an der die Einstellungen in moodle gefunden werden\nk\u00f6nnen. Im Fall des hier implementierten Admin Tools, werden die Einstellungen unter den Authentifizierungs-Optionen\ngelistet. Damit ist die Erstellung der Eingabemaske abgeschlossen.\n\n\nOAuth 2.0 Client\n\n\nDen funktionalen Kern des Plugins stellt der OAuth 2.0 Client dar. Dieser befindet sich in Form der Klasse \nsciebo\n in der\nDatei \nsciebo.php\n in dem \nclasses\n Ordner des Plugins. Diese Klasse steuert sowohl den moodle-seitigen Protokollablauf\nvon OAuth 2.0, als auch den Verbindungsaufbau zu ownCloud mittels WebDAV. Dadurch, dass \nsciebo\n von der im moodle Core\nenthaltenen Klasse \noauth2_client\n erbt, ist ein Gro\u00dfteil des Protokollablaufs bereits abgedeckt.\nDer Konstruktor der Klasse \noauth2_client\n muss mit den \nClient ID\n und \nSecret\n Daten aufgerufen werden. \nDiese werden aus den zuvor angewandten Einstellungen beschafft:\n\n\n?php\n\nnamespace tool_oauth2sciebo;\n\ndefined('MOODLE_INTERNAL') || die();\n\nrequire_once($CFG-\nlibdir . '/oauthlib.php');\n\nuse tool_oauth2sciebo\\sciebo_client;\n\nclass sciebo extends \\oauth2_client {\n\n    /**\n     * Create the DropBox API Client.\n     *\n     * @param   string      $key        The API key\n     * @param   string      $secret     The API secret\n     * @param   string      $callback   The callback URL\n     */\n    public function __construct($callback) {\n        parent::__construct(get_config('tool_oauth2sciebo', 'clientid'),\n            get_config('tool_oauth2sciebo', 'secret'), $callback, '');\n\n\n\n\nZu diesem Zweck wird die Methode \nget_config\n verwendet. Sie gibt den f\u00fcr ein Plugin und einen zuvor einzigartig definierten\nNamen aus dem Admin Tree heraus die dazu gespeicherte Einstellung.\nDar\u00fcber hinaus muss eine \ncallback URL\n angef\u00fcgt werden, die den Pfad angibt, an den nach der Authentifizierung und Autorisierung\nweitergeleitet werden soll. Dieser wird allerdings wird extern in den Plugins erzeugt, die die \nsciebo\n Klasse benutzen.\n\n\nWeiterhin m\u00fcssen die Methoden \nauth_url\n und \ntoken_url\n der Elternklasse zwingend \u00fcberschrieben werden, um bei der Authentifizierung\nauf die richtigen Pfade zu verweisen:\n\n\n    /**\n     * Returns the auth url for OAuth 2.0 request\n     * @return string the auth url\n     */\n    protected function auth_url() {\n        // Dynamically generated from the admin tool settings.\n        return get_config('tool_oauth2sciebo', 'auth_url');\n    }\n\n    /**\n     * Returns the token url for OAuth 2.0 request\n     * @return string the auth url\n     */\n    protected function token_url() {\n        return get_config('tool_oauth2sciebo', 'token_url');\n    }\n\n\n\n\n\n  \nTODO:\n Sp\u00e4ter wird der Pfad aus den gegebenen Daten berechnet.\n\n\n\n\nHierf\u00fcr werden die beiden Pfade aus der Serveraddresse und dem Serverpfad berechnet, da der Endpunkt f\u00fcr die oauth2 App in\nownCloud gleich bleibt.\n\n\n\n  \nTODO:\n \u00dcberschriebene post Methode.\n\n\n\n\nTests und CI\n\n\n\u00c4nderungen an Core Bibliotheken\n\n\nAnpassung des WebDAV Clients", 
            "title": "Admin Tool"
        }, 
        {
            "location": "/moodle/admin-tool/#admin-tool-oauth2sciebo", 
            "text": "", 
            "title": "Admin Tool: oauth2sciebo"
        }, 
        {
            "location": "/moodle/admin-tool/#zweck-des-plugins", 
            "text": "Wie bereits im Kapitel  Software Architektur  angeschnitten, ist der Hauptzweck dieses Plugins\ndie Schnittstelle zu Sciebo bzw. ownCloud bereitzustellen. Zu diesem Zweck wird die im Projekt implementierte ownCloud \nApp  OAuth2  mit Hilfe eines OAuth 2.0 Clients \u00fcber die WebDAV Schnittstelle angesprochen.\nGleichzeitig kann dieses Plugin auch f\u00fcr \u00e4hnliche externe Datenquellen verwendet werden, sofern diese \u00fcber die n\u00f6tigen\nOAuth 2.0 und WebDAV Schnittstellen verf\u00fcgen.  Im Wesentlichen implementiert dieses Plugin folgende  Integrationsszenarien :   Beispiel 1:  ...  Beispiel 2:  ...   \n   TODO:  Integrationsszenarien definieren und hier einf\u00fcgen.", 
            "title": "Zweck des Plugins"
        }, 
        {
            "location": "/moodle/admin-tool/#vorgegebene-schnittstelle", 
            "text": "F\u00fcr Admin Tools ist in moodle lediglich eine schwach definierte Schnittstelle gegeben. Wie in jedem anderen moodle Plugin \nauch, m\u00fcssen zun\u00e4chst einige Standartdateien implementiert werden:    version.php :  Beschreibt die Versionsnummer des Plugins, die ben\u00f6tigte moodle Version und Abh\u00e4ngigkeiten des Plugins.  access.php :  Legt die Berechtigungen f\u00fcr definierte Aktionen innerhalb des Plugins anhand von Nutzerrollen fest.  tool_oauth2sciebo.php :  Beinhaltet Sprachstrings f\u00fcr unterschiedliche Regionen und Sprachen, sodass definierte Strings,\nabh\u00e4ngig von der jeweiligen Sprache, dynamisch angezeigt werden k\u00f6nnen.   Zus\u00e4tzlich zu den allgemeinen Plugindateien, sollte unser Admin Tool auch mindestens noch eine Datei namens  settings.php \nbeinhalten. Diese umfasst alle Einstellungen, die f\u00fcr das Admin Tool geltend dem Administrator der moodle Instanz zur \nVerf\u00fcgung gestellt werden sollen. Nach der Eingabe, wird diese Konfiguration moodle-intern in dem sogenannten  Admin Tree \ngespeichert. Aus dieser Baumstruktur k\u00f6nnen anschlie\u00dfend ben\u00f6tigte Einstellungen beschafft werden.  Insgesamt ergibt sich folgende Struktur von Ordnern und Dateien, die mindestens f\u00fcr die Implementierung des von uns gebrauchten\nAdmin Tools notwendig ist:  \n   TODO:  Grafik f\u00fcr Ordnerstruktur einf\u00fcgen.", 
            "title": "Vorgegebene Schnittstelle"
        }, 
        {
            "location": "/moodle/admin-tool/#implementierung-der-vorgegebenen-schnittstelle", 
            "text": "", 
            "title": "Implementierung der vorgegebenen Schnittstelle"
        }, 
        {
            "location": "/moodle/admin-tool/#eingabemaske", 
            "text": "Um die OAuth 2.0 und WebDAV Clients erfolgreich zum Zugriff auf eine entsprechende Sciebo bzw. ownCloud Instanz zu bef\u00e4higen,\nm\u00fcssen diese zun\u00e4chst mit Hilfe ben\u00f6tigter Eingabedaten konfiguriert werden. Diese sollen zentral im Admin Tool eingegeben und\ngespeichert werden k\u00f6nnen, um sie anschlie\u00dfend von anderen Plugins aus nutzen zu k\u00f6nnen. Dies ist einer der Gegens\u00e4tze zu\n\u00e4hnlichen, vor Allem repository Plugins, welche die ben\u00f6tigte Daten auf Plugin-Ebene abfragen und benutzen.  Eine solche Eingabemaske kann im Rahmen der  settings  definiert werden. Zu diesem Zweck muss zun\u00e4chst ein neues Objekt vom Typ  admin_settingpage \ninnerhalb der  settings.php  Datei erstellt werden. Dieses Objekt umfasst eine Gruppe von Einstellungen, welche, sobald hinzugef\u00fcgt,\nin dem Admin Tree eingeordnet und gespeichert werden. Die zugeh\u00f6rige Klasse befindet sich in Funktionsbibliothek adminlib.php , welche Teil des moodle Cores ist. Beim \nAufruf des Konstruktors m\u00fcssen Name des Plugins, welcher sp\u00e4ter dazu verwendet wird die Einstellung im Admin Tree wiederzufinden,\nund der Anzeigename f\u00fcr die Einstellungsseite \u00fcbergeben werden.   Um den OAuth 2.0 Protokollablauf zu erm\u00f6glichen, m\u00fcssen folgende Daten im Vorfeld erfasst werden:   Client ID :  wird in ownCloud generiert und dient der Identifizierung eines regstrierten Clients.  Secret :  wird ebenfalls in ownCloud generiert und zur Authentifizierung verwendet.   Beide Datens\u00e4tze sind Strings und daher eignet sich f\u00fcr beide ein Textfeld zur Eingabe.  Zur Nutzung des WebDAV Clients werden dar\u00fcber hinaus folgende Daten ben\u00f6tigt:   Server Addresse :  Url \u00fcber die der ownCloud Server erreicht werden kann.  Server Pfad :  der angehangene Pfad, \u00fcber den die WebDAV Schnittstelle erreicht werden kann.  Port :  Port des WebDAV-Servers.  SSL-Verschl\u00fcsselung :  Wahl zwischen HTTP und HTTPS.  Authentifizierung :  Wahl zwischen Basic und Bearer Authentifizierung.     W\u00e4hrend Server Adresse, Pfad und Port mittels eines Textfeldes abgefragt werden k\u00f6nnen, sollten die anderen Optionen mit Hilfe\neiner Auswahl aus den angebotenen M\u00f6glicheiten erfragt werden k\u00f6nnen.  Um nun die Eingabeeinstellungen dem Admin Tree anzuh\u00e4ngen, muss jedes vorgesehene Eingabefeld der  admin_settingpage  \nmittels der Methode  add  hinzugef\u00fcgt werden. Der daf\u00fcr notwendige Code sieht wie folgt aus:  ?php\n\n$temp = new admin_settingpage('oauth2sciebo', new lang_string('pluginname', 'tool_oauth2sciebo'));\n$temp- add(new admin_setting_heading('coursebank_proxy_head',\n        get_string('configplugin', 'tool_oauth2sciebo'),\n        ''\n        ));\n$temp- add(new admin_setting_configtext('tool_oauth2sciebo/clientid',\n        get_string('clientid', 'tool_oauth2sciebo'),\n        '', ''\n        ));\n$temp- add(new admin_setting_configtext('tool_oauth2sciebo/secret',\n        get_string('secret', 'tool_oauth2sciebo'),\n        '', ''\n        ));\n$temp- add(new admin_setting_configtext('tool_oauth2sciebo/server',\n        get_string('server', 'tool_oauth2sciebo'),\n        '', ''\n    ));\n$temp- add(new admin_setting_configtext('tool_oauth2sciebo/path',\n        get_string('path', 'tool_oauth2sciebo'),\n        '', ''\n    ));\n$temp- add(new admin_setting_configtext('tool_oauth2sciebo/port',\n        get_string('port', 'tool_oauth2sciebo'),\n        '', ''\n    ));\n$temp- add(new admin_setting_configselect('tool_oauth2sciebo/auth',\n        get_string('auth', 'tool_oauth2sciebo'),\n        '', '', array('basic' =  'Basic', 'bearer' =  'Bearer')\n    ));\n\n$ADMIN- add('authsettings', $temp);  Hierbei sind die Klassen  admin_setting_heading ,  admin_configtext  und  admin_configselect  ebenfalls Teil der  adminlib.php \nund die \u00dcberschrift der Einstellungen, eine Eingabetextfeld und eine Eingabeauswahl. Beim Erstellen eines Objektes der Klassen  admin_configtext  und  admin_configselect  m\u00fcssen neben dem einzigartigen Einstellungsnamen Anzeigename, Beschreibung und Standartwert\n\u00fcbergeben werden, wobei bei letzterem die Auswahlm\u00f6glichkeiten angegeben werden m\u00fcssen.  Sobald alle n\u00f6tigen Optionen erstellt worden und der  admin_settingpage  hinzugef\u00fcgt worden sind, muss diese dem Globalen ADMIN  Objekt hinzugef\u00fcgt werden. Dabei wird auch die Stelle \u00fcbergeben, an der die Einstellungen in moodle gefunden werden\nk\u00f6nnen. Im Fall des hier implementierten Admin Tools, werden die Einstellungen unter den Authentifizierungs-Optionen\ngelistet. Damit ist die Erstellung der Eingabemaske abgeschlossen.", 
            "title": "Eingabemaske"
        }, 
        {
            "location": "/moodle/admin-tool/#oauth-20-client", 
            "text": "Den funktionalen Kern des Plugins stellt der OAuth 2.0 Client dar. Dieser befindet sich in Form der Klasse  sciebo  in der\nDatei  sciebo.php  in dem  classes  Ordner des Plugins. Diese Klasse steuert sowohl den moodle-seitigen Protokollablauf\nvon OAuth 2.0, als auch den Verbindungsaufbau zu ownCloud mittels WebDAV. Dadurch, dass  sciebo  von der im moodle Core\nenthaltenen Klasse  oauth2_client  erbt, ist ein Gro\u00dfteil des Protokollablaufs bereits abgedeckt.\nDer Konstruktor der Klasse  oauth2_client  muss mit den  Client ID  und  Secret  Daten aufgerufen werden. \nDiese werden aus den zuvor angewandten Einstellungen beschafft:  ?php\n\nnamespace tool_oauth2sciebo;\n\ndefined('MOODLE_INTERNAL') || die();\n\nrequire_once($CFG- libdir . '/oauthlib.php');\n\nuse tool_oauth2sciebo\\sciebo_client;\n\nclass sciebo extends \\oauth2_client {\n\n    /**\n     * Create the DropBox API Client.\n     *\n     * @param   string      $key        The API key\n     * @param   string      $secret     The API secret\n     * @param   string      $callback   The callback URL\n     */\n    public function __construct($callback) {\n        parent::__construct(get_config('tool_oauth2sciebo', 'clientid'),\n            get_config('tool_oauth2sciebo', 'secret'), $callback, '');  Zu diesem Zweck wird die Methode  get_config  verwendet. Sie gibt den f\u00fcr ein Plugin und einen zuvor einzigartig definierten\nNamen aus dem Admin Tree heraus die dazu gespeicherte Einstellung.\nDar\u00fcber hinaus muss eine  callback URL  angef\u00fcgt werden, die den Pfad angibt, an den nach der Authentifizierung und Autorisierung\nweitergeleitet werden soll. Dieser wird allerdings wird extern in den Plugins erzeugt, die die  sciebo  Klasse benutzen.  Weiterhin m\u00fcssen die Methoden  auth_url  und  token_url  der Elternklasse zwingend \u00fcberschrieben werden, um bei der Authentifizierung\nauf die richtigen Pfade zu verweisen:      /**\n     * Returns the auth url for OAuth 2.0 request\n     * @return string the auth url\n     */\n    protected function auth_url() {\n        // Dynamically generated from the admin tool settings.\n        return get_config('tool_oauth2sciebo', 'auth_url');\n    }\n\n    /**\n     * Returns the token url for OAuth 2.0 request\n     * @return string the auth url\n     */\n    protected function token_url() {\n        return get_config('tool_oauth2sciebo', 'token_url');\n    }  \n   TODO:  Sp\u00e4ter wird der Pfad aus den gegebenen Daten berechnet.  Hierf\u00fcr werden die beiden Pfade aus der Serveraddresse und dem Serverpfad berechnet, da der Endpunkt f\u00fcr die oauth2 App in\nownCloud gleich bleibt.  \n   TODO:  \u00dcberschriebene post Methode.", 
            "title": "OAuth 2.0 Client"
        }, 
        {
            "location": "/moodle/admin-tool/#tests-und-ci", 
            "text": "", 
            "title": "Tests und CI"
        }, 
        {
            "location": "/moodle/admin-tool/#anderungen-an-core-bibliotheken", 
            "text": "", 
            "title": "\u00c4nderungen an Core Bibliotheken"
        }, 
        {
            "location": "/moodle/admin-tool/#anpassung-des-webdav-clients", 
            "text": "", 
            "title": "Anpassung des WebDAV Clients"
        }, 
        {
            "location": "/moodle/repository/", 
            "text": "Repository: \nsciebo\n\n\nZweck des Plugins\n\n\nVorgegebene Schnittstelle\n\n\nImplementierung der vorgegebenen Schnittstelle\n\n\nTests und CI", 
            "title": "Repository"
        }, 
        {
            "location": "/moodle/repository/#repository-sciebo", 
            "text": "", 
            "title": "Repository: sciebo"
        }, 
        {
            "location": "/moodle/repository/#zweck-des-plugins", 
            "text": "", 
            "title": "Zweck des Plugins"
        }, 
        {
            "location": "/moodle/repository/#vorgegebene-schnittstelle", 
            "text": "", 
            "title": "Vorgegebene Schnittstelle"
        }, 
        {
            "location": "/moodle/repository/#implementierung-der-vorgegebenen-schnittstelle", 
            "text": "", 
            "title": "Implementierung der vorgegebenen Schnittstelle"
        }, 
        {
            "location": "/moodle/repository/#tests-und-ci", 
            "text": "", 
            "title": "Tests und CI"
        }, 
        {
            "location": "/moodle/activity/", 
            "text": "Aktivit\u00e4t: \ncollaborative folders\n\n\nZweck des Plugins\n\n\nVorgegebene Schnittstelle\n\n\nImplementierung der vorgegebenen Schnittstelle\n\n\nTests und CI", 
            "title": "Collaborative Folders"
        }, 
        {
            "location": "/moodle/activity/#aktivitat-collaborative-folders", 
            "text": "", 
            "title": "Aktivit\u00e4t: collaborative folders"
        }, 
        {
            "location": "/moodle/activity/#zweck-des-plugins", 
            "text": "", 
            "title": "Zweck des Plugins"
        }, 
        {
            "location": "/moodle/activity/#vorgegebene-schnittstelle", 
            "text": "", 
            "title": "Vorgegebene Schnittstelle"
        }, 
        {
            "location": "/moodle/activity/#implementierung-der-vorgegebenen-schnittstelle", 
            "text": "", 
            "title": "Implementierung der vorgegebenen Schnittstelle"
        }, 
        {
            "location": "/moodle/activity/#tests-und-ci", 
            "text": "", 
            "title": "Tests und CI"
        }, 
        {
            "location": "/moodle/benutzung/", 
            "text": "Benutzung\n\n\nInstallation", 
            "title": "Benutzung"
        }, 
        {
            "location": "/moodle/benutzung/#benutzung", 
            "text": "", 
            "title": "Benutzung"
        }, 
        {
            "location": "/moodle/benutzung/#installation", 
            "text": "", 
            "title": "Installation"
        }
    ]
}