{
    "docs": [
        {
            "location": "/", 
            "text": "sciebo@Learnweb\n\n\nDiese Website dokumentiert die Integration von \nsciebo\n in das \nLearnweb\n\nvon dem Projektseminar \nsciebo@Learnweb\n, das im Wintersemester 2016/17 an der \nWestf\u00e4lischen Wilhelms-Universit\u00e4t M\u00fcnster\n stattgefunden hat.\n\n\nSciebo ist ein Cloud-Dienst, der gemeinsam von 26 Hochschulen und Forschungseinrichtungen in NRW angeboten wird. Als Grundlage dient die Enterprise-Edition von \nownCloud\n.\nDas Learnweb ist ein auf der Open-Source-L\u00f6sung \nMoodle\n basierendes E-Learning System der Westf\u00e4lischen Wilhelms-Universit\u00e4t M\u00fcnster.\n\n\nEine m\u00f6gliche L\u00f6sung sollte dabei m\u00f6glichst allgemein einsetzbar sein, da die Kombination von Moodle und ownCloud an zahlreichen Universit\u00e4ten genutzt wird.\n\n\nAllgemeine Motivation f\u00fcr die Arbeit\n\n\nDie grunds\u00e4tzliche Motivation f\u00fcr das Projektseminar war es, die beiden Systeme \nsciebo\n und \nLearnweb\n passwortlos miteinander kommunizieren zu lassen.\nBedeutet, dass einmalig ein Passwort eingegeben werden muss, welches aber nicht im Klartext auf dem jeweils anderen System gespeichert wird.\nDer Zugriff sollte also \u00fcber ein tokenbasiertes Authentifizierungsverfahren wie zum Beispiel OAuth 2.0 ablaufen.\nDadurch sollte es unter Anderem erm\u00f6glicht werden, dass Dateien aus Sciebo im Learnweb abgerufen werden k\u00f6nnen und kollaborative Ordner in sciebo vom Learnweb aus erstellt werden k\u00f6nnen.\n\n\nStruktur der Dokumentation\n\n\nDie hier vorliegende Dokumentation ist in mehrere Teile strukturiert. Zu erst die Aufteilung in \nHome\n, \nownCloud\n und \nMoodle\n. Sie befinden sich gerade im Abschnitt \nHome\n,\nwelcher grundlegende Informationen zum Projektseminar enth\u00e4lt und einen groben \u00dcberblick verschafft, was in der Dokumentation enthalten ist. Die Abschnitte \nownCloud\n und \nMoodle\n dokumentieren\njeweils die spezifische \nBenutzung\n (Teil der Dokumention, welcher eher an die Nutzer gerichtet ist), und die jeweilige \nTechnische Umsetzung\n, welche die Dokumentation f\u00fcr Entwickler bereitstellt. Der Punkt \nTechnische Umsetzung\n im Abschnitt\n\nownCloud\n enth\u00e4lt die Themen \nSoftwarearchitektur\n, \nOAuth 2.0 App\n\nund \nCore Anpassungen\n. Der gleiche Unterpunkt im Abschnitt \nMoodle\n behandelt die Themen \nSoftwarearchitektur\n,\n\nAdmin Tool\n, \nRepository\n und \nCollaborative Folders\n.\n\n\nIntegrationsszenarien\n\n\nAls Integrationsszenarien der Systeme wurden verschiedene User Stories entwickelt.\nDiese haben wir nach Schwierigkeit, Interesse, Benutzbarkeit und Implementationsaufwand priorisiert.\nAls Integrationsrichtung konzentrierte wir uns auf die Richtung Learnweb \n sciebo.\n\n\nRealisierte Szenarien\n\n\n1. Als \nNutzer\n m\u00f6chte ich OAuth2 benutzen k\u00f6nnen, um mich im Learnweb als ownCloud Nutzer anzumelden.\n\n\nDieser Use Case implementiert die grundlegende Authentifizierung mit dem \nOAuth 2.0\n Verfahren.\nIm Rahmen unserer Vorbereiungsphase auf das Projektseminar haben wir verschiedene Authentifizierungsmethoden evaluiert. Im Abschnitt\n \nAuthentifizierung und Autorisierung\n finden sie hierf\u00fcr genauere Informationen. Hierf\u00fcr ist in Moodle das\n \nAdmin Tool\n implementiert worden. Es \u00fcbernimmt s\u00e4mtliche Aufgaben der Authentifizierung. Alle anderen Plugins nutzen dieses Tool.\n In OwnCloud wurde hierf\u00fcr eine \nApp\n entwickelt.\n\n\n2. Als \nNutzer\n m\u00f6chte ich in der Dateiauswahl im Learnweb eine Datei aus meiner ownCloud Instanz hochladen.\n\n\nDer vorherige Use Case war f\u00fcr den Benutzer der Moodle Instanz noch nicht sichtbar. Das wichtigste Anwendungsszenario ist das Nutzer im Learnweb Dateien aus ihrer\nownCloud Account hochladen k\u00f6nnen. Hierf\u00fcr haben wir in Moodle ein \nRepository-Plugins\n entwickelt. Sobald das Reposiotory einer Moodle\nInstanz hinzugef\u00fcgt wurde kann der Nutzer \u00fcber einen anmelde Button Moodle autorisieren Dateien aus dem privaten ownCloud account anzuzeigen\nund mit Hilfe des File Pickers k\u00f6nnen nun Dateien ausgew\u00e4hlt werden.\n\n\n  \nTODO:\n BILDER! (Wenn get_listing wieder funktioniert)\n\n\n\n3. Als \nNutzer\n m\u00f6chte ich in der Dateiauswahl im Learnweb eine Datei aus meiner ownCloud Instanz verlinken.\n\n\nEine Erweiterung des vorherigen Szenarios ist die Verlinkung von Dateien. Hier wird zu der bestehenden Datei ein public-link erstellt.\nDieser kann nun von Nutzern angeklickt werden. Diese Funktionalit\u00e4t ist auch Teil des \nRepository-Plugins\n. Das Verlinken ist\njedoch nur in der Aktivit\u00e4t URL verf\u00fcgbar.\n\n\n4. Als \nLehrender\n m\u00f6chte ich Studierenden oder Gruppen von Studierenden Ordner f\u00fcr kollaboratives Arbeiten bereitstellen.\n\n\nDie letzte User Story die wir implementiert haben, wurde vermehrt von Lehrenden der Universit\u00e4t M\u00fcnster nachgefragt. Ein Lehrender kann mir Hilfe der\nAktivit\u00e4t \ncollaborativefolders\n in einem Kurs Ordner erstellen auf den Studierende Zugriff haben und den sie ihrem sciebo account hinzuf\u00fcgen k\u00f6nnen.\n\n\nWeitere User Storys die jedoch nicht im Rahmen diese Projektseminars implementiert werden konnten finden sie unter dem Abschnitt\n\nWeitere Anwendungsszenarien\n.\n\n\nAuthentifizierung und Autorisierung\n\n\nGrundlegend f\u00fcr die Integration beider Systeme ist die Authentifizierung und Autorisierung. Unter den g\u00e4ngigen Verfahren, die untersucht wurden, befinden sich:\n\n\n\n\nOAuth 2.0\n\n\nJSON Web Tokens\n\n\nFederated Single Sign-on mit beispielsweise \nShibboleth\n\n\n\n\nF\u00fcr das Projekt wurde das OAuth 2.0 Verfahren ausgew\u00e4hlt, da mit ihm ein standardisiertes Verfahren zur tokenbasierten Authentifizierung und\nAutorisierung vorliegt, das sich gut in bestehende Applikationen auf Basis vieler verschiedener Programmiersprachen einf\u00fcgen l\u00e4sst und damit keine weiteren Anforderungen an die Infrastruktur stellt.\n\n\nOAuth 2.0\n\n\nDer allgemeine \nOAuth 2.0 Protokollablauf\n ist in der nachfolgenden Abbildung dargestellt.\n\n\n\n\nZun\u00e4chst muss sich der Client (Learnweb), der im Namen des Resource Owners (ownCloud Nutzer) auf eine gesch\u00fctzte Ressource auf dem Resource Server (sciebo) zugreifen m\u00f6chte,\nbei dem Authorization Server (ownCloud) registrieren. Danach werden nach dem Protokoll folgende Schritte durchlaufen:\n\n\n\n\nAuthorization Request: Der Client fordert eine Autorisierung vom Resource Owner an.\n\n\nAuthorization Response: Der Client erh\u00e4lt eine Autorisierungsgenehmigung vom Resource Owner. Die Autorisierung kann \u00fcber eine\nder vier Autorisierungsgenehmigungen (authorization grant type) erfolgen, oder es wird ein erweiterer Genehmigungsprozess verwendet.\n\n\nAccess Token Request: Der Client fordert ein Access Token vom Authorization Server an. Hierf\u00fcr nutzt er die Autorisierungsgenehmigung vom Resource Owner.\n\n\nAccess Token Response: Der Authorization Server authentifiziert den Client und pr\u00fcft die Autorisierungsgenehmigung.\nIst die Pr\u00fcfung erfolgreich, wird ein Access Token ausgestellt.\n\n\nAnfrage mittels Access Token: Der Client fragt die gesch\u00fctzten Daten beim Resource Server an. Zur Authentifizierung benutzt er den Access Token.\n\n\nZugriff auf gesch\u00fctzte Ressourcen: Der Resource Server pr\u00fcft den Access Token und stellt, wenn g\u00fcltig, die gew\u00fcnschten Daten zur Verf\u00fcgung.\n\n\n\n\nKomponenten\n\n\n\n  \nTODO:\n W\u00fcrde ich nicht in den Index packen, sondern einzelne Komponenten nur in dem Moodle und ownCloud Unterpunkt beschreiben.\n\n\n\nownCloud\n\n\nDie Komponenten, die wir ben\u00f6tigen um eine L\u00f6sung anzubieten, sind die von uns implementierte oauth2 App und der ownCloud Core mit \u00c4nderungen aus unserem Pull request,\ndamit die oauth2 App die volle Funktionalit\u00e4t bereitstellen kann. Die oauth2 App implementiert den OAuth 2.0 Prozessfluss.\nSie agiert als Endpunkt f\u00fcr die Authorisierung und die Bereitstellung von Access Tokens und Refresh Tokens.\nDie App ist also das Mittel zur Verbindung von Resource Owner, Authorization Server und auch Resource Server mit dem Client.\n\n\nMoodle\n\n\n\n  \nTODO:\n Bestandteile der L\u00f6sung in moodle auflisten und kurz die Funktion anschneiden.\n\n\n\n\nZusammenspiel\n\n\n\n  \nTODO:\n Wie arbeiten die einzelnen Komponenten zusammen, um das Problem zu l\u00f6sen? (WebDAV: Wie wird der\n  komplette OAuth Protokollablauf erf\u00fcllt?).\n\n\n\n\nWeitere Integrationsszenarien\n\n\nIm Rahmen unseres Projektseminars haben wir uns auf die f\u00fcr uns wichtigsten Integrationsszenarien konzentriert. Im Folgenden werden weitere Szenarien erl\u00e4utert, \u00fcber deren Implementierung wir nachgedacht haben und die eine Erweiterung\nzu den bestehenden Szenarien bilden k\u00f6nnten.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich auf einen Button klicken, um hochgeladene Dateien zu aktualisieren.\n\n\n\n\n\n\nAls \nStudierender\n m\u00f6chte ich Dateien aus dem Learnweb direkt in meiner ownCloud Instanz speichern k\u00f6nnen.\n\n\n\n\n\n\nAls \nStudierender\n m\u00f6chte ich anderen Studierenden Schreib- und Lese-Rechte geben um kollaborativ zu arbeiten.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich Nutzern auf Modul-Basis das Recht entziehen eine Datei zu verlinken.\n\n\n\n\n\n\nAls \nNutzer\n m\u00f6chte ich in der Dateiauswahl im Learnweb einen Ordner aus meiner ownCloud Instanz hochladen.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich in der Dateiauswahl im Learnweb einen Ordner aus meiner ownCloud Instanz verlinken.\n\n\n\n\n\n\nAls \nStudierender\n m\u00f6chte ich Lehrenden Schreib- oder Lese-Rechte auf mein Dokument geben k\u00f6nnen um Feedback zu erhalten.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich die M\u00f6glichkeit haben, einen Zielordner in ownCloud zur Speicherung auszuw\u00e4hlen, um Abgaben herunterzuladen.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich ownCloud als prim\u00e4ren Speicher f\u00fcr alle Dateien im Kurs verwenden k\u00f6nnen.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich in ownCloud die Teilen-Funktion nutzen, um Dateien oder Dokumente f\u00fcr Kursteilnehmer freigeben zu k\u00f6nnen.\n\n\n\n\n\n\nZusammenfassung\n\n\n\n  \nTODO:\n Ausf\u00fchrung.\n\n\nErf\u00fcllungsgrad der User Stories, Geschaffene Funktionalit\u00e4ten, (bekannte, ggf. bewusst gew\u00e4hlte) Einschr\u00e4nkungen, Ausblick auf weitere Entwicklungsm\u00f6glichkeiten.\nEinschr\u00e4nkungen festhalten; den Rest ganz zum Schluss des PS beschreiben", 
            "title": "Home"
        }, 
        {
            "location": "/#sciebolearnweb", 
            "text": "Diese Website dokumentiert die Integration von  sciebo  in das  Learnweb \nvon dem Projektseminar  sciebo@Learnweb , das im Wintersemester 2016/17 an der  Westf\u00e4lischen Wilhelms-Universit\u00e4t M\u00fcnster  stattgefunden hat.  Sciebo ist ein Cloud-Dienst, der gemeinsam von 26 Hochschulen und Forschungseinrichtungen in NRW angeboten wird. Als Grundlage dient die Enterprise-Edition von  ownCloud .\nDas Learnweb ist ein auf der Open-Source-L\u00f6sung  Moodle  basierendes E-Learning System der Westf\u00e4lischen Wilhelms-Universit\u00e4t M\u00fcnster.  Eine m\u00f6gliche L\u00f6sung sollte dabei m\u00f6glichst allgemein einsetzbar sein, da die Kombination von Moodle und ownCloud an zahlreichen Universit\u00e4ten genutzt wird.", 
            "title": "sciebo@Learnweb"
        }, 
        {
            "location": "/#allgemeine-motivation-fur-die-arbeit", 
            "text": "Die grunds\u00e4tzliche Motivation f\u00fcr das Projektseminar war es, die beiden Systeme  sciebo  und  Learnweb  passwortlos miteinander kommunizieren zu lassen.\nBedeutet, dass einmalig ein Passwort eingegeben werden muss, welches aber nicht im Klartext auf dem jeweils anderen System gespeichert wird.\nDer Zugriff sollte also \u00fcber ein tokenbasiertes Authentifizierungsverfahren wie zum Beispiel OAuth 2.0 ablaufen.\nDadurch sollte es unter Anderem erm\u00f6glicht werden, dass Dateien aus Sciebo im Learnweb abgerufen werden k\u00f6nnen und kollaborative Ordner in sciebo vom Learnweb aus erstellt werden k\u00f6nnen.", 
            "title": "Allgemeine Motivation f\u00fcr die Arbeit"
        }, 
        {
            "location": "/#struktur-der-dokumentation", 
            "text": "Die hier vorliegende Dokumentation ist in mehrere Teile strukturiert. Zu erst die Aufteilung in  Home ,  ownCloud  und  Moodle . Sie befinden sich gerade im Abschnitt  Home ,\nwelcher grundlegende Informationen zum Projektseminar enth\u00e4lt und einen groben \u00dcberblick verschafft, was in der Dokumentation enthalten ist. Die Abschnitte  ownCloud  und  Moodle  dokumentieren\njeweils die spezifische  Benutzung  (Teil der Dokumention, welcher eher an die Nutzer gerichtet ist), und die jeweilige  Technische Umsetzung , welche die Dokumentation f\u00fcr Entwickler bereitstellt. Der Punkt  Technische Umsetzung  im Abschnitt ownCloud  enth\u00e4lt die Themen  Softwarearchitektur ,  OAuth 2.0 App \nund  Core Anpassungen . Der gleiche Unterpunkt im Abschnitt  Moodle  behandelt die Themen  Softwarearchitektur , Admin Tool ,  Repository  und  Collaborative Folders .", 
            "title": "Struktur der Dokumentation"
        }, 
        {
            "location": "/#integrationsszenarien", 
            "text": "Als Integrationsszenarien der Systeme wurden verschiedene User Stories entwickelt.\nDiese haben wir nach Schwierigkeit, Interesse, Benutzbarkeit und Implementationsaufwand priorisiert.\nAls Integrationsrichtung konzentrierte wir uns auf die Richtung Learnweb   sciebo.", 
            "title": "Integrationsszenarien"
        }, 
        {
            "location": "/#realisierte-szenarien", 
            "text": "", 
            "title": "Realisierte Szenarien"
        }, 
        {
            "location": "/#1-als-nutzer-mochte-ich-oauth2-benutzen-konnen-um-mich-im-learnweb-als-owncloud-nutzer-anzumelden", 
            "text": "Dieser Use Case implementiert die grundlegende Authentifizierung mit dem  OAuth 2.0  Verfahren.\nIm Rahmen unserer Vorbereiungsphase auf das Projektseminar haben wir verschiedene Authentifizierungsmethoden evaluiert. Im Abschnitt\n  Authentifizierung und Autorisierung  finden sie hierf\u00fcr genauere Informationen. Hierf\u00fcr ist in Moodle das\n  Admin Tool  implementiert worden. Es \u00fcbernimmt s\u00e4mtliche Aufgaben der Authentifizierung. Alle anderen Plugins nutzen dieses Tool.\n In OwnCloud wurde hierf\u00fcr eine  App  entwickelt.", 
            "title": "1. Als Nutzer m\u00f6chte ich OAuth2 benutzen k\u00f6nnen, um mich im Learnweb als ownCloud Nutzer anzumelden."
        }, 
        {
            "location": "/#2-als-nutzer-mochte-ich-in-der-dateiauswahl-im-learnweb-eine-datei-aus-meiner-owncloud-instanz-hochladen", 
            "text": "Der vorherige Use Case war f\u00fcr den Benutzer der Moodle Instanz noch nicht sichtbar. Das wichtigste Anwendungsszenario ist das Nutzer im Learnweb Dateien aus ihrer\nownCloud Account hochladen k\u00f6nnen. Hierf\u00fcr haben wir in Moodle ein  Repository-Plugins  entwickelt. Sobald das Reposiotory einer Moodle\nInstanz hinzugef\u00fcgt wurde kann der Nutzer \u00fcber einen anmelde Button Moodle autorisieren Dateien aus dem privaten ownCloud account anzuzeigen\nund mit Hilfe des File Pickers k\u00f6nnen nun Dateien ausgew\u00e4hlt werden. \n   TODO:  BILDER! (Wenn get_listing wieder funktioniert)", 
            "title": "2. Als Nutzer m\u00f6chte ich in der Dateiauswahl im Learnweb eine Datei aus meiner ownCloud Instanz hochladen."
        }, 
        {
            "location": "/#3-als-nutzer-mochte-ich-in-der-dateiauswahl-im-learnweb-eine-datei-aus-meiner-owncloud-instanz-verlinken", 
            "text": "Eine Erweiterung des vorherigen Szenarios ist die Verlinkung von Dateien. Hier wird zu der bestehenden Datei ein public-link erstellt.\nDieser kann nun von Nutzern angeklickt werden. Diese Funktionalit\u00e4t ist auch Teil des  Repository-Plugins . Das Verlinken ist\njedoch nur in der Aktivit\u00e4t URL verf\u00fcgbar.", 
            "title": "3. Als Nutzer m\u00f6chte ich in der Dateiauswahl im Learnweb eine Datei aus meiner ownCloud Instanz verlinken."
        }, 
        {
            "location": "/#4-als-lehrender-mochte-ich-studierenden-oder-gruppen-von-studierenden-ordner-fur-kollaboratives-arbeiten-bereitstellen", 
            "text": "Die letzte User Story die wir implementiert haben, wurde vermehrt von Lehrenden der Universit\u00e4t M\u00fcnster nachgefragt. Ein Lehrender kann mir Hilfe der\nAktivit\u00e4t  collaborativefolders  in einem Kurs Ordner erstellen auf den Studierende Zugriff haben und den sie ihrem sciebo account hinzuf\u00fcgen k\u00f6nnen.  Weitere User Storys die jedoch nicht im Rahmen diese Projektseminars implementiert werden konnten finden sie unter dem Abschnitt Weitere Anwendungsszenarien .", 
            "title": "4. Als Lehrender m\u00f6chte ich Studierenden oder Gruppen von Studierenden Ordner f\u00fcr kollaboratives Arbeiten bereitstellen."
        }, 
        {
            "location": "/#authentifizierung-und-autorisierung", 
            "text": "Grundlegend f\u00fcr die Integration beider Systeme ist die Authentifizierung und Autorisierung. Unter den g\u00e4ngigen Verfahren, die untersucht wurden, befinden sich:   OAuth 2.0  JSON Web Tokens  Federated Single Sign-on mit beispielsweise  Shibboleth   F\u00fcr das Projekt wurde das OAuth 2.0 Verfahren ausgew\u00e4hlt, da mit ihm ein standardisiertes Verfahren zur tokenbasierten Authentifizierung und\nAutorisierung vorliegt, das sich gut in bestehende Applikationen auf Basis vieler verschiedener Programmiersprachen einf\u00fcgen l\u00e4sst und damit keine weiteren Anforderungen an die Infrastruktur stellt.", 
            "title": "Authentifizierung und Autorisierung"
        }, 
        {
            "location": "/#oauth-20", 
            "text": "Der allgemeine  OAuth 2.0 Protokollablauf  ist in der nachfolgenden Abbildung dargestellt.   Zun\u00e4chst muss sich der Client (Learnweb), der im Namen des Resource Owners (ownCloud Nutzer) auf eine gesch\u00fctzte Ressource auf dem Resource Server (sciebo) zugreifen m\u00f6chte,\nbei dem Authorization Server (ownCloud) registrieren. Danach werden nach dem Protokoll folgende Schritte durchlaufen:   Authorization Request: Der Client fordert eine Autorisierung vom Resource Owner an.  Authorization Response: Der Client erh\u00e4lt eine Autorisierungsgenehmigung vom Resource Owner. Die Autorisierung kann \u00fcber eine\nder vier Autorisierungsgenehmigungen (authorization grant type) erfolgen, oder es wird ein erweiterer Genehmigungsprozess verwendet.  Access Token Request: Der Client fordert ein Access Token vom Authorization Server an. Hierf\u00fcr nutzt er die Autorisierungsgenehmigung vom Resource Owner.  Access Token Response: Der Authorization Server authentifiziert den Client und pr\u00fcft die Autorisierungsgenehmigung.\nIst die Pr\u00fcfung erfolgreich, wird ein Access Token ausgestellt.  Anfrage mittels Access Token: Der Client fragt die gesch\u00fctzten Daten beim Resource Server an. Zur Authentifizierung benutzt er den Access Token.  Zugriff auf gesch\u00fctzte Ressourcen: Der Resource Server pr\u00fcft den Access Token und stellt, wenn g\u00fcltig, die gew\u00fcnschten Daten zur Verf\u00fcgung.", 
            "title": "OAuth 2.0"
        }, 
        {
            "location": "/#komponenten", 
            "text": "TODO:  W\u00fcrde ich nicht in den Index packen, sondern einzelne Komponenten nur in dem Moodle und ownCloud Unterpunkt beschreiben.", 
            "title": "Komponenten"
        }, 
        {
            "location": "/#owncloud", 
            "text": "Die Komponenten, die wir ben\u00f6tigen um eine L\u00f6sung anzubieten, sind die von uns implementierte oauth2 App und der ownCloud Core mit \u00c4nderungen aus unserem Pull request,\ndamit die oauth2 App die volle Funktionalit\u00e4t bereitstellen kann. Die oauth2 App implementiert den OAuth 2.0 Prozessfluss.\nSie agiert als Endpunkt f\u00fcr die Authorisierung und die Bereitstellung von Access Tokens und Refresh Tokens.\nDie App ist also das Mittel zur Verbindung von Resource Owner, Authorization Server und auch Resource Server mit dem Client.", 
            "title": "ownCloud"
        }, 
        {
            "location": "/#moodle", 
            "text": "TODO:  Bestandteile der L\u00f6sung in moodle auflisten und kurz die Funktion anschneiden.", 
            "title": "Moodle"
        }, 
        {
            "location": "/#zusammenspiel", 
            "text": "TODO:  Wie arbeiten die einzelnen Komponenten zusammen, um das Problem zu l\u00f6sen? (WebDAV: Wie wird der\n  komplette OAuth Protokollablauf erf\u00fcllt?).", 
            "title": "Zusammenspiel"
        }, 
        {
            "location": "/#weitere-integrationsszenarien", 
            "text": "Im Rahmen unseres Projektseminars haben wir uns auf die f\u00fcr uns wichtigsten Integrationsszenarien konzentriert. Im Folgenden werden weitere Szenarien erl\u00e4utert, \u00fcber deren Implementierung wir nachgedacht haben und die eine Erweiterung\nzu den bestehenden Szenarien bilden k\u00f6nnten.    Als  Lehrender  m\u00f6chte ich auf einen Button klicken, um hochgeladene Dateien zu aktualisieren.    Als  Studierender  m\u00f6chte ich Dateien aus dem Learnweb direkt in meiner ownCloud Instanz speichern k\u00f6nnen.    Als  Studierender  m\u00f6chte ich anderen Studierenden Schreib- und Lese-Rechte geben um kollaborativ zu arbeiten.    Als  Lehrender  m\u00f6chte ich Nutzern auf Modul-Basis das Recht entziehen eine Datei zu verlinken.    Als  Nutzer  m\u00f6chte ich in der Dateiauswahl im Learnweb einen Ordner aus meiner ownCloud Instanz hochladen.    Als  Lehrender  m\u00f6chte ich in der Dateiauswahl im Learnweb einen Ordner aus meiner ownCloud Instanz verlinken.    Als  Studierender  m\u00f6chte ich Lehrenden Schreib- oder Lese-Rechte auf mein Dokument geben k\u00f6nnen um Feedback zu erhalten.    Als  Lehrender  m\u00f6chte ich die M\u00f6glichkeit haben, einen Zielordner in ownCloud zur Speicherung auszuw\u00e4hlen, um Abgaben herunterzuladen.    Als  Lehrender  m\u00f6chte ich ownCloud als prim\u00e4ren Speicher f\u00fcr alle Dateien im Kurs verwenden k\u00f6nnen.    Als  Lehrender  m\u00f6chte ich in ownCloud die Teilen-Funktion nutzen, um Dateien oder Dokumente f\u00fcr Kursteilnehmer freigeben zu k\u00f6nnen.", 
            "title": "Weitere Integrationsszenarien"
        }, 
        {
            "location": "/#zusammenfassung", 
            "text": "TODO:  Ausf\u00fchrung. \nErf\u00fcllungsgrad der User Stories, Geschaffene Funktionalit\u00e4ten, (bekannte, ggf. bewusst gew\u00e4hlte) Einschr\u00e4nkungen, Ausblick auf weitere Entwicklungsm\u00f6glichkeiten.\nEinschr\u00e4nkungen festhalten; den Rest ganz zum Schluss des PS beschreiben", 
            "title": "Zusammenfassung"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/softwarearchitektur/", 
            "text": "Softwarearchitektur\n\n\nDa wir m\u00f6glichst keine neue Schnittstelle implementieren wollten, war es das Ziel, die bestehenden Schnittstellen in ownCloud um OAuth 2.0 zu erweitern. Zun\u00e4chst war daf\u00fcr die Implementierung des OAuth 2.0 Protokolls mit seinen Schnittstellen notwendig. Au\u00dferdem musste zur Umsetzung der \nIntegrationsszenarien\n der Zugriff auf \nWebDAV\n und die \nOCS Share API\n \u00fcber OAuth 2.0 bereitgestellt werden.\n\n\nBestandteile\n\n\nOAuth 2.0 App\n\n\nZur Implementierung von OAuth 2.0 entschieden wir uns in Absprache mit einem ownCloud Entwickler, eine \nownCloud App\n namens \noauth2\n zu erstellen. Der Vorteil einer solchen L\u00f6sung ist, dass OAuth 2.0 zu einer bestehenden ownCloud Installation einfach hinzugef\u00fcgt und auch wieder entfernt werden kann. Die M\u00f6glichkeit, \nRESTful APIs\n und eigene \nDatenmodelle\n in Apps zu definieren, stellten alle notwendigen Werkzeuge f\u00fcr die Umsetzung des OAuth 2.0 Protokolls bereit.\n\n\nCore Anpassungen\n\n\nZur Erweiterung der WebDAV Schnittstelle um OAuth 2.0 wurde die Implementierung von WebDAV im \nownCloud Core\n untersucht. Es stellte sich heraus, dass hierf\u00fcr auch eine ownCloud App namens \ndav\n verwendet wurde, die die \nsabre/dav\n Bibliothek zur Implementierung des WebDAV-Serves nutzt. Da die Bibliothek den Austausch der Authentifizierung \u00fcber eigene Authentication Backends unterst\u00fctzt, entschieden wir uns f\u00fcr die Implementierung eines Backends f\u00fcr OAuth 2.0,\ndas wir ebenfalls \u00fcber die \noauth2\n App bereitstellen wollten. Um eigene Authentication Backends f\u00fcr die \ndav\n App bekannt zu machen und gleichzeitig keine Abh\u00e4ngigkeit zwischen den Apps zu schaffen,\nnutzten wir Event Listener. Notwendig daf\u00fcr war die Registrierung des OAuth 2.0 Backends durch die \noauth2\n App. Au\u00dferdem musste die \ndav\n App dahingehend angepasst werden, zus\u00e4tzliche Authentication Backends zu laden. Hierf\u00fcr wurde der Pull Request \nowncloud/core#26742\n erstellt. Ein Backport f\u00fcr ownCloud 9.1 ist im Pull Request \nowncloud/core#27370\n zu finden.\n\n\nSchlie\u00dflich musste noch die OCS Share API um OAuth 2.0 erweitert werden. Die Implementierung dieser API wird gr\u00f6\u00dftenteils durch die ownCloud App \nfiles_sharing\n bereitgestellt. Daher mussten \u00c4nderungen auf Ebene von ownCloud Apps und im Speziellen bei der Authentifizierung der von ihnen definierten APIs durchgef\u00fchrt werden. Das bedeutete, dass auch hierf\u00fcr \u00c4nderungen am ownCloud Core notwendig waren. Gleichzeitig sollten aber keine Abh\u00e4ngigkeiten zwischen dem Core und der \noauth2\n App geschaffen werden. Wir folgten dem Vorschlag eines ownCloud Entwicklers, daf\u00fcr einen Plugin Mechanismus zu implementieren. Auch diese \u00c4nderungen sind im Pull Request \nowncloud/core#26742\n (analog dazu \nowncloud/core#27370\n) zu finden.\n\n\nFolgende Tabelle fasst die Funktionen der einzelnen Bestandteile zusammen.\n\n\n\n\n\n\n\n\nBestandteil\n\n\nFunktion\n\n\n\n\n\n\n\n\n\n\nOAuth 2.0 App\n\n\nImplementierung des OAuth 2.0 Protokolls mit der notwendigen Authentifizierungslogik f\u00fcr die WebDAV Schnittstelle und ownCloud APIs\n\n\n\n\n\n\nCore Anpassungen\n\n\nErweiterung der Authentifizierung in der \ndav\n App und f\u00fcr ownCloud APIs um das Laden benutzerdefinierter Authentifizierungsmethoden", 
            "title": "Softwarearchitektur"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/softwarearchitektur/#softwarearchitektur", 
            "text": "Da wir m\u00f6glichst keine neue Schnittstelle implementieren wollten, war es das Ziel, die bestehenden Schnittstellen in ownCloud um OAuth 2.0 zu erweitern. Zun\u00e4chst war daf\u00fcr die Implementierung des OAuth 2.0 Protokolls mit seinen Schnittstellen notwendig. Au\u00dferdem musste zur Umsetzung der  Integrationsszenarien  der Zugriff auf  WebDAV  und die  OCS Share API  \u00fcber OAuth 2.0 bereitgestellt werden.", 
            "title": "Softwarearchitektur"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/softwarearchitektur/#bestandteile", 
            "text": "", 
            "title": "Bestandteile"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/softwarearchitektur/#oauth-20-app", 
            "text": "Zur Implementierung von OAuth 2.0 entschieden wir uns in Absprache mit einem ownCloud Entwickler, eine  ownCloud App  namens  oauth2  zu erstellen. Der Vorteil einer solchen L\u00f6sung ist, dass OAuth 2.0 zu einer bestehenden ownCloud Installation einfach hinzugef\u00fcgt und auch wieder entfernt werden kann. Die M\u00f6glichkeit,  RESTful APIs  und eigene  Datenmodelle  in Apps zu definieren, stellten alle notwendigen Werkzeuge f\u00fcr die Umsetzung des OAuth 2.0 Protokolls bereit.", 
            "title": "OAuth 2.0 App"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/softwarearchitektur/#core-anpassungen", 
            "text": "Zur Erweiterung der WebDAV Schnittstelle um OAuth 2.0 wurde die Implementierung von WebDAV im  ownCloud Core  untersucht. Es stellte sich heraus, dass hierf\u00fcr auch eine ownCloud App namens  dav  verwendet wurde, die die  sabre/dav  Bibliothek zur Implementierung des WebDAV-Serves nutzt. Da die Bibliothek den Austausch der Authentifizierung \u00fcber eigene Authentication Backends unterst\u00fctzt, entschieden wir uns f\u00fcr die Implementierung eines Backends f\u00fcr OAuth 2.0,\ndas wir ebenfalls \u00fcber die  oauth2  App bereitstellen wollten. Um eigene Authentication Backends f\u00fcr die  dav  App bekannt zu machen und gleichzeitig keine Abh\u00e4ngigkeit zwischen den Apps zu schaffen,\nnutzten wir Event Listener. Notwendig daf\u00fcr war die Registrierung des OAuth 2.0 Backends durch die  oauth2  App. Au\u00dferdem musste die  dav  App dahingehend angepasst werden, zus\u00e4tzliche Authentication Backends zu laden. Hierf\u00fcr wurde der Pull Request  owncloud/core#26742  erstellt. Ein Backport f\u00fcr ownCloud 9.1 ist im Pull Request  owncloud/core#27370  zu finden.  Schlie\u00dflich musste noch die OCS Share API um OAuth 2.0 erweitert werden. Die Implementierung dieser API wird gr\u00f6\u00dftenteils durch die ownCloud App  files_sharing  bereitgestellt. Daher mussten \u00c4nderungen auf Ebene von ownCloud Apps und im Speziellen bei der Authentifizierung der von ihnen definierten APIs durchgef\u00fchrt werden. Das bedeutete, dass auch hierf\u00fcr \u00c4nderungen am ownCloud Core notwendig waren. Gleichzeitig sollten aber keine Abh\u00e4ngigkeiten zwischen dem Core und der  oauth2  App geschaffen werden. Wir folgten dem Vorschlag eines ownCloud Entwicklers, daf\u00fcr einen Plugin Mechanismus zu implementieren. Auch diese \u00c4nderungen sind im Pull Request  owncloud/core#26742  (analog dazu  owncloud/core#27370 ) zu finden.  Folgende Tabelle fasst die Funktionen der einzelnen Bestandteile zusammen.     Bestandteil  Funktion      OAuth 2.0 App  Implementierung des OAuth 2.0 Protokolls mit der notwendigen Authentifizierungslogik f\u00fcr die WebDAV Schnittstelle und ownCloud APIs    Core Anpassungen  Erweiterung der Authentifizierung in der  dav  App und f\u00fcr ownCloud APIs um das Laden benutzerdefinierter Authentifizierungsmethoden", 
            "title": "Core Anpassungen"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/", 
            "text": "App: \noauth2\n\n\nZweck\n\n\nIn der App sollte der h\u00e4ufig f\u00fcr Webapplikationen eingesetzte \nAuthorization Code Flow\n implementiert werden. Dazu mussten folgende User Stories umgesetzt werden:\n\n\n\n\nClientregistrierung:\n Als ownCloud-Administrator m\u00f6chte ich Clients in den Administrator-Einstellungen hinzuf\u00fcgen und l\u00f6schen k\u00f6nnen, um die Kontrolle \u00fcber erlaubte Clients zu haben.\n\n\nAuthorization URL:\n Als Client-Entwickler m\u00f6chte ich eine Authorization URL zur Verf\u00fcgung haben, um Authorization Codes anfordern zu k\u00f6nnen.\n\n\nAccess Token URL:\n Als Client-Entwickler m\u00f6chte ich eine Access Token URL zur Verf\u00fcgung haben, um Access Tokens anfordern zu k\u00f6nnen.\n\n\nVerwaltung autorisierter Applikationen\n: Als ownCloud-Nutzer m\u00f6chte ich in den pers\u00f6nlichen Einstellungen autorisierte Applikationen verwalten k\u00f6nnen, um einen \u00dcberblick zu haben und Autorisierungen widerrufen zu k\u00f6nnen.\n\n\n\n\nDatenmodell\n\n\nZun\u00e4chst musste ein Datenmodell zur Speicherung der ben\u00f6tigten Daten aufgestellt werden. Gem\u00e4\u00df dem Authorization Code Flow wurden folgende Entit\u00e4ten mit Attributen definiert:\n\n\n\n\nclient\n:\n Die Applikation, die f\u00fcr den Zugriff auf die WebDAV Schnittstelle autorisiert werden soll.\n\n\nidentifier\n: Zeichenkette, die einen Client eindeutig identifiziert.\n\n\nsecret\n: Zeichenkette, mit der ein Client sich beim Anfordern eines Access Tokens authentifizieren kann.\n\n\nredirect_uri\n: URI, an die nach erfolgter Autorisierung des Nutzers weitergeleitet wird.\n\n\n\n\n\n\nauthorization_code\n:\n Ein \nAuthorization Grant\n, \nmit dem der Client die Autorisierung des Nutzers darlegen und somit ein Access Token anfordern kann.\n\n\ncode\n: Zeichenkette, die als Authorization Code dient.\n\n\nclient_id\n: Client Identifier des Clients, f\u00fcr den der Authorization Code ausgegeben wird.\n\n\nuser_id\n: User ID des ownCloud-Nutzers, der den Client autorisiert hat.\n\n\nexpires\n: Zeitpunkt, zu dem der Authorization Code ung\u00fcltig wird (optional).\n\n\n\n\n\n\naccess_token\n:\n Eine Zeichenkette, die den Zugriff auf die WebDAV Schnittstelle erlaubt.\n\n\ncode\n: Zeichenkette, die als Access Token dient.\n\n\nclient_id\n: Client Identifier des Clients, f\u00fcr den der Access Token ausgegeben wird.\n\n\nuser_id\n: User ID des ownCloud-Nutzers, der den Client autorisiert hat.\n\n\nexpires\n: Zeitpunkt, zu dem der Access Token ung\u00fcltig wird (optional).\n\n\n\n\n\n\nrefresh_token\n:\n Eine Zeichenkette, mit der ein abgelaufener Access Token gegen einen neuen ausgetauscht werden kann.\n\n\ncode\n: Zeichenkette, die als Refresh Token dient.\n\n\nclient_id\n: Client Identifier des Clients, f\u00fcr den der Access Token ausgegeben wird.\n\n\nuser_id\n: User ID des ownCloud-Nutzers, der den Client autorisiert hat.\n\n\nexpires\n: Zeitpunkt, zu dem der Refresh Token ung\u00fcltig wird (optional).\n\n\n\n\n\n\n\n\nFolgendes Entity-Relationship-Modell fasst das Datenmodell nochmal grafisch zusammen.\n\n\n\n\nVorgegebene Schnittstelle\n\n\n\n  \nTODO:\n Die durch ownCloud Apps vorgegebene Schnittstelle beschreiben.\n\n\n\n\nImplementierung\n\n\nMapper und Entities\n\n\nF\u00fcr den Datenbank-Zugriff im PHP-Code ist es in ownCloud m\u00f6glich, \nMapper\n und \n\nEntities\n zu schreiben. \nDadurch werden Tupel in einer Datenbank-Tabelle automatisch in ein Objekt umgewandelt.\n\n\nFolgendes Codebeispiel zeigt am Beispiel des Entitys \nClient\n, wie eine PHP-Klasse dazu aussehen muss.\n\n\n?php\nnamespace OCA\\OAuth2\\Db;\n\nuse OCP\\AppFramework\\Db\\Entity;\n\n/**\n * Class Client\n *\n * @method string getIdentifier()\n * @method void setIdentifier(string $identifier)\n * @method string getSecret()\n * @method void setSecret(string $secret)\n * @method string getRedirectUri()\n * @method void setRedirectUri(string $redirectUri)\n * @method string getName()\n * @method void setName(string $name)\n */\nclass Client extends Entity {\n\n    protected $identifier;\n    protected $secret;\n    protected $redirectUri;\n    protected $name;\n\n    public function __construct() {\n        $this-\naddType('id', 'int');\n        $this-\naddType('identifier', 'string');\n        $this-\naddType('secret', 'string');\n        $this-\naddType('redirect_uri', 'string');\n        $this-\naddType('name', 'string');\n    }\n\n}\n\n\n\n\nWichtig ist, dass die Klasse von \nEntity\n erbt und sowohl der Klassenname als auch die Attribute mit denen der Tabelle \u00fcbereinstimmen. \nPascal bzw. Camel case im PHP-Code wird automatisch zu Snake case f\u00fcr die Datenbank umgewandelt. \nGetter und Setter werden ebenfalls automatisch generiert. Die PHPDoc Kommentare dienen lediglich dazu, in der Entwicklungsumgebung eine automatische Vervollst\u00e4ndigung zu haben. \nDie Angabe von \nTypen\n im Konstruktor dienen dazu, beim Lesen aus der Datenbank die richtige Umwandlung zu erhalten.\n\n\nDas folgende Codebeispiel zeigt einen Ausschnitt aus dem zur \nClient\n Entity geh\u00f6renden Mapper.\n\n\n?php\nnamespace OCA\\OAuth2\\Db;\n\nuse InvalidArgumentException;\nuse OCP\\AppFramework\\Db\\Entity;\nuse OCP\\IDb;\nuse OCP\\AppFramework\\Db\\Mapper;\n\nclass ClientMapper extends Mapper {\n\n    /**\n     * ClientMapper constructor.\n     *\n     * @param IDb $db Database Connection.\n     */\n    public function __construct(IDb $db) {\n        parent::__construct($db, 'oauth2_clients');\n    }\n\n    /**\n     * Selects a client by its ID.\n     *\n     * @param int $id The client's ID.\n     *\n     * @return Entity The client entity.\n     *\n     * @throws \\OCP\\AppFramework\\Db\\DoesNotExistException if not found.\n     * @throws \\OCP\\AppFramework\\Db\\MultipleObjectsReturnedException if more than one result.\n     */\n    public function find($id) {\n        if (!is_int($id)) {\n            throw new InvalidArgumentException('id must not be null');\n        }\n\n        $sql = 'SELECT * FROM `' . $this-\ntableName . '` WHERE `id` = ?';\n        return $this-\nfindEntity($sql, array($id), null, null);\n    }\n\n    /**\n     * Selects clients by the given user ID.\n     *\n     * @param string $userId The user ID.\n     *\n     * @return array The client entities.\n     */\n    public function findByUser($userId) {\n        if (!is_string($userId)) {\n            throw new InvalidArgumentException('userId must not be null');\n        }\n\n        $sql = 'SELECT * FROM `' . $this-\ntableName . '` '\n            . 'WHERE `id` IN ( '\n                . 'SELECT `client_id` FROM `oc_oauth2_authorization_codes` WHERE `user_id` = ? '\n                . 'UNION '\n                . 'SELECT `client_id` FROM `oc_oauth2_access_tokens` WHERE `user_id` = ? '\n            .')';\n        return $this-\nfindEntities($sql, array($userId, $userId), null, null);\n    }\n\n}\n\n\n\n\nBeim Mapper ist es wichtig, dass die Klasse von \nMapper\n erbt und eine Entity-Klasse zu ihm existiert. \nDazu wird das Wort vor \u201eMapper\u201c als Entityname verwendet. Im Konstruktur wird der Tabellenname angegeben. \nDie beiden Funktionen \nfind\n und \nfindByUser\n demonstrieren \nSELECT\n-Anweisungen. \nDazu wird die SQL-Anweisungen zusammen mit ben\u00f6tigten Parametern an \nfindEntity\n bzw. \nfindEntities\n \u00fcbergeben, abh\u00e4ngig davon, ob mehrere Entities im Ergebnis enthalten sein sollten. \nFunktionen zum l\u00f6schen, einf\u00fcgen und updaten werden von der Oberklasse bereits implementiert und mussten nicht angepasst werden.\n\n\nSchnittstellen und Routes\n\n\nUm in einer ownCloud App Schnittstellen anzubieten, m\u00fcssen \nRoutes\n registriert werden. \nZur Umsetzung der erw\u00e4hnten User Stories waren folgende Routes notwendig:\n\n\n\n\n\n\n\n\nMethode\n\n\nEndpunkt\n\n\nBeschreibung\n\n\n\n\n\n\n\n\n\n\nGET\n\n\nauthorize\n\n\nEndpunkt, zu dem der Client den Nutzer weiterleitet, um die Autorisierung anzufragen (Authorization URL).\n\n\n\n\n\n\nPOST\n\n\nauthorize\n\n\nEndpunkt, der aufgerufen wird, sobald der Nutzer den Client autorisiert hat.\n\n\n\n\n\n\nPOST\n\n\napi/v1/token\n\n\nEndpunkt, an dem ein Access Token angefordert wird (Access Token URL).\n\n\n\n\n\n\nPOST\n\n\nclients\n\n\nEndpunkt, durch den der Administrator einen Client hinzuf\u00fcgen kann.\n\n\n\n\n\n\nPOST\n\n\nclients/{id}/delete\n\n\nEndpunkt, durch den der Administrator den Client mit der ID \nid\n l\u00f6schen kann.\n\n\n\n\n\n\nPOST\n\n\nclients/{id}/revoke\n\n\nEndpunkt, durch den der Nutzer die Autorisierung des Clients mit der ID \nid\n widerrufen kann.\n\n\n\n\n\n\n\n\nRegistriert werden die Routes in der Datei \nroutes.php\n, indem ein Array mit den Routes zur\u00fcckgegeben wird. Nachfolgendes Codebeispiel zeigt einige der obigen Routes:\n\n\n?php\nreturn [\n    'routes' =\n [\n        ['name' =\n 'page#authorize', 'url' =\n '/authorize', 'verb' =\n 'GET'],\n        ['name' =\n 'o_auth_api#generate_token', 'url' =\n '/api/v1/token', 'verb' =\n 'POST'],\n        ['name' =\n 'settings#deleteClient', 'url' =\n '/clients/{id}/delete', 'verb' =\n 'POST']\n    ]\n];\n\n\n\n\n\nDurch \nname\n wird f\u00fcr jede Route der Name des dazugeh\u00f6rigen \nControllers\n sowie die aufzurufende Funktion angegeben. \nVor dem \n#\n-Zeichen steht der Controllername in Snake case und hinter dem \n#\n-Zeichen steht der Funktionsname (ebenfalls in Snake case). \nMithilfe von \nurl\n wird der Endpunkt festgelegt und \nverb\n definiert die HTTP-Methode.\n\n\nController\n\n\nWenn an einem Endpunkt eine HTTP-Anfrage ankommt, so wird der in den Routes definierte \nController\n aufgerufen. \nWichtig ist hierbei, dass von der Klasse \nController\n oder \neiner Unterklasse wie \nApiController\n geerbt wird.\n\n\nF\u00fcr den Controller notwendige Parameter wie \nMapper\n k\u00f6nnen im Konstruktor als Parameter angegeben und so durch \n\nDependency Injection\n erhalten werden. \nNachfolgendes Codebeispiel zeigt den Konstruktor vom \nPageController\n.\n\n\n/**\n * PageController constructor.\n * \n * @param string $AppName The name of the app.\n * @param IRequest $request The request.\n * @param ClientMapper $clientMapper The client mapper.\n * @param AuthorizationCodeMapper $authorizationCodeMapper The authorization code mapper.\n * @param string $UserId The user ID.\n */\npublic function __construct($AppName, IRequest $request, ClientMapper $clientMapper,\n    AuthorizationCodeMapper $authorizationCodeMapper, $UserId) {\n    parent::__construct($AppName, $request);\n\n    $this-\nclientMapper = $clientMapper;\n    $this-\nauthorizationCodeMapper = $authorizationCodeMapper;\n    $this-\nuserId = $UserId;\n}\n\n\n\n\nDie hier notwendigen Parameter sind der Name der App, eine \nClientMapper\n Instanz, eine \nAuthorizationCodeMapper\n Instanz und die ID des Nutzers, \num bei der Autorisierung des Clients speichern zu k\u00f6nnen, welcher Nutzers dies veranlasst hat.\n\n\nDie mit den Routes verkn\u00fcpften Funktionen k\u00f6nnen zur Zugriffskontrolle mit \nPHPDoc Annotationen\n \nversehen werden. Folgendes Codebeispiel zeigt die Annotationen f\u00fcr die Funktion \ngenerateToken\n im \nOAuthApiController\n.\n\n\n/**\n * Implements the OAuth 2.0 Access Token Response.\n *\n * @param string $code The authorization code.\n * @return JSONResponse The Access Token or an empty JSON Object.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n * @PublicPage\n * @CORS\n */\npublic function generateToken($code) { }\n\n\n\n\nDie Annotationen haben dabei folgende Bedeutungen.\n\n\n\n\n\n\n\n\nAnnotation\n\n\nBedeutung\n\n\n\n\n\n\n\n\n\n\n@NoAdminRequired\n\n\nAufruf auch von normalen Nutzern m\u00f6glich.\n\n\n\n\n\n\n@NoCSRFRequired\n\n\nZeigt an, dass die \u00dcberpr\u00fcfung des CSRF Tokens nicht gewollt ist.\n\n\n\n\n\n\n@PublicPage\n\n\nZugriff auch ohne Login m\u00f6glich.\n\n\n\n\n\n\n@CORS\n\n\nAufruf der API durch andere Web Applikationen von au\u00dfen m\u00f6glich.\n\n\n\n\n\n\n\n\nIn den Controller-Funktionen k\u00f6nnen verschiedene Inhalte zur\u00fcckgegeben werden. Hier genutzte R\u00fcckgabetypen sind in der folgenden Tabelle zusammengefasst.\n\n\n\n\n\n\n\n\nTyp\n\n\nBeschreibung\n\n\n\n\n\n\n\n\n\n\nTemplateResponse\n\n\nZur R\u00fcckgabe eines Templates, das dem Nutzer angezeigt werden soll.\n\n\n\n\n\n\nRedirectResponse\n\n\nZur Weiterleitung des Nutzers an eine andere URL.\n\n\n\n\n\n\nJSONResponse\n\n\nZur R\u00fcckgabe eines JSON Strings.\n\n\n\n\n\n\n\n\nEin Beispiel f\u00fcr die R\u00fcckgabetypen \nTemplateResponse\n und \nRedirectResponse\n gibt die Funktion \nauthorize\n im \nPageController\n, die im folgenden Codebeispiel zu sehen ist.\n\n\n/**\n * Shows a view for the user to authorize a client.\n *\n * @param string $response_type The expected response type.\n * @param string $client_id The client identifier.\n * @param string $redirect_uri The redirect URI.\n * @param string $state The state.\n * @param string $scope The scope.\n *\n * @return TemplateResponse|RedirectResponse The authorize view or a\n * redirection to the ownCloud main page.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n */\npublic function authorize($response_type, $client_id, $redirect_uri, $state = null, $scope = null) {\n    if (!is_string($response_type) || !is_string($client_id)\n        || !is_string($redirect_uri) || (isset($state) \n !is_string($state))\n        || (isset($scope) \n !is_string($scope))) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    try {\n        /** @var Client $client */\n        $client = $this-\nclientMapper-\nfindByIdentifier($client_id);\n    } catch (DoesNotExistException $exception) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    if (strcmp($client-\ngetRedirectUri(), urldecode($redirect_uri)) !== 0) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n    if (strcmp($response_type, 'code') !== 0) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    return new TemplateResponse('oauth2', 'authorize', ['client_name' =\n $client-\ngetName()]);\n}\n\n\n\n\nHier werden zun\u00e4chst die Parameter auf G\u00fcltigkeit \u00fcberpr\u00fcft. Sollten die Parameter nicht g\u00fcltig sein (beispielsweise deshalb, \nweil der angegebene Client nicht existiert oder dessen Redirect URI falsch angegeben wurde) wird mit einem \nRedirectResponse\n auf die ownCloud Startseite umgeleitet. \nAndernfalls wird ein \nTemplateResponse\n f\u00fcr das Template \nauthorize\n zur\u00fcckgegeben. \nF\u00fcr das Rendern des Templates k\u00f6nnen Parameter wie hier \nclient_name\n f\u00fcr den Namen des Clients \u00fcbergeben werden.\n\n\nDer R\u00fcckgabetyp \nJSONResponse\n wird f\u00fcr die R\u00fcckgabe des Access Tokens in der Funktion \ngenerateToken\n im \nOAuthApiController\n genutzt, \nwie nachfolgendes Codebeispiel zeigt. Zudem ist das Zusammenspiel mit Entities und Mappern zu sehen.\n\n\n/**\n * Implements the OAuth 2.0 Access Token Response.\n *\n * @param string $code The authorization code.\n * @return JSONResponse The Access Token or an empty JSON Object.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n * @PublicPage\n * @CORS\n */\npublic function generateToken($code) {\n    if (is_null($code) || is_null($_SERVER['PHP_AUTH_USER'])\n        || is_null($_SERVER['PHP_AUTH_PW'])) {\n        return new JSONResponse(['message' =\n 'Missing credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    try {\n        /** @var Client $client */\n        $client = $this-\nclientMapper-\nfindByIdentifier($_SERVER['PHP_AUTH_USER']);\n    } catch (DoesNotExistException $exception) {\n        return new JSONResponse(['message' =\n 'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    if (strcmp($client-\ngetSecret(), $_SERVER['PHP_AUTH_PW']) !== 0) {\n        return new JSONResponse(['message' =\n 'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    try {\n        /** @var AuthorizationCode $authorizationCode */\n        $authorizationCode = $this-\nauthorizationCodeMapper-\nfindByCode($code);\n    } catch (DoesNotExistException $exception) {\n        return new JSONResponse(['message' =\n 'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    if (strcmp($authorizationCode-\ngetClientId(), $client-\ngetId()) !== 0) {\n        return new JSONResponse(['message' =\n 'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    $token = Utilities::generateRandom();\n    $userId = $authorizationCode-\ngetUserId();\n    $accessToken = new AccessToken();\n    $accessToken-\nsetToken($token);\n    $accessToken-\nsetClientId($authorizationCode-\ngetClientId());\n    $accessToken-\nsetUserId($userId);\n    $this-\naccessTokenMapper-\ninsert($accessToken);\n\n    $this-\nauthorizationCodeMapper-\ndelete($authorizationCode);\n\n    return new JSONResponse(\n        [\n            'access_token' =\n $token,\n            'token_type' =\n 'Bearer',\n            'user_id' =\n $userId\n        ]\n    );\n}\n\n\n\n\nNach erfolgreicher \u00dcberpr\u00fcfung des Authorization Codes und der Angaben zur Client Authentication im Authorization Header wird eine neuer Access Token erstellt und in der Datenbank gespeichert. \nDer verwendete Authorization Code wird zudem gel\u00f6scht. Im JSON Response wird dann der Access Token, der Token Typ und die ID des Nutzers zur\u00fcckgegeben. \nNachfolgend ist ein Beispiel dazu angegeben.\n\n\n{\n    \naccess_token\n : \n1vtnuo1NkIsbndAjVnhl7y0wJha59JyaAiFIVQDvcBY2uvKmj5EPBEhss0pauzdQ\n,\n    \ntoken_type\n : \nBearer\n,\n    \nuser_id\n : \nadmin\n\n}\n\n\n\n\nF\u00fcr die Token-Generierung wurde die Hilfsklasse \nUtilities\n mit der statischen Funktion \ngenerateRandom\n geschrieben, \ndie mithilfe einer ownCloud-internen Funktion 64-stellige Zeichenketten erzeugt. \nFolgendes Codebeispiel zeigt diese Klasse.\n\n\n?php\nnamespace OCA\\OAuth2;\n\nclass Utilities {\n\n    /**\n     * Generates a random string with 64 characters.\n     *\n     * @return string The random string.\n     */\n    public static function generateRandom() {\n        return \\OC::$server-\ngetSecureRandom()-\ngenerate(64,\n            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789');\n    }\n\n}\n\n\n\n\nZusammenfassend werden im folgenden UML-Klassendiagramm die Controller mit ihren Beziehungen zu den Entities und Mappern dargestellt.\n\n\n\n  \nTODO:\n Klassendiagramme zusammenf\u00fcgen bzw. vervollst\u00e4ndigen.\n\n\n\n\n\n\n\n\n\n\nTemplates\n\n\nIn den \nTemplates\n einer ownCloud App wird die f\u00fcr den Nutzer sichtbare Oberfl\u00e4che definiert. \nEs k\u00f6nnen die vom \nController\n \u00fcbergebenen Parameter genutzt werden. Dazu gibt es ein Array mit dem Namen \n$_\n. \nZur Vermeidung von Cross-Site-Scripting gibt es die ownCloud-interne Funktion \np()\n, mithilfe derer Werte ausgegeben werden k\u00f6nnen.\n\n\nFolgende Templates wurden in der App definiert:\n\n\n\n\nauthorize\n: Zur Darstellung des Authroization Requests, bei dem der Nutzer um Autorisierung eines Clients gebeten wird. \nEs werden ein Text zur Erkl\u00e4rung sowie Buttons zum Akzeptieren oder Ablehnen angezeigt.\n\n\nsettings-admin\n: Stellt zur Verwaltung der Clients eine tabellarische Auflistung der Clients sowie ein Formular zum Hinzuf\u00fcgen von Clients dar.\n\n\nsettings-personal\n: Stellt eine tabellarische Auflistung der vom Nutzer autorisierten Clients dar, mit der M\u00f6glichkeit, die Autorisierung zu widerrufen.\n\n\n\n\nFolgendes Codebeispiel zeigt das Template \nsettings-admin\n.\n\n\n?php\n\ndiv class=\nsection\n id=\noauth2\n\n    \nh2\n?php p($l-\nt('OAuth 2.0')); ?\n/h2\n\n\n    \nh3\n?php p($l-\nt('Registered clients')); ?\n/h3\n\n    \n?php if (empty($_['clients'])) {\n        p($l-\nt('No clients registered.'));\n    }\n    else { ?\n\n    \ntable class=\ngrid\n\n        \nthead\n\n        \ntr\n\n            \nth id=\nheaderName\n scope=\ncol\n?php p($l-\nt('Name')); ?\n/th\n\n            \nth id=\nheaderRedirectUri\n scope=\ncol\n?php p($l-\nt('Redirect URI')); ?\n/th\n\n            \nth id=\nheaderClientIdentifier\n scope=\ncol\n?php p($l-\nt('Client Identifier')); ?\n/th\n\n            \nth id=\nheaderSecret\n scope=\ncol\n?php p($l-\nt('Secret')); ?\n/th\n\n            \nth id=\nheaderRemove\nnbsp;\n/th\n\n        \n/tr\n\n        \n/thead\n\n        \ntbody\n\n            \n?php foreach ($_['clients'] as $client) { ?\n\n                \ntr\n\n                    \ntd\n?php p($client-\ngetName()); ?\n/td\n\n                    \ntd\n?php p($client-\ngetRedirectUri()); ?\n/td\n\n                    \ntd\n?php p($client-\ngetIdentifier()); ?\n/td\n\n                    \ntd\n?php p($client-\ngetSecret()); ?\n/td\n\n                    \ntd\n\n                        \nform action=\n../apps/oauth2/clients/\n?php p($client-\ngetId()); ?\n/delete\n method=\npost\n\n                              style='display:inline;'\n\n                            \ninput type=\nsubmit\n class=\nbutton icon-delete\n value=\n\n                        \n/form\n\n                    \n/td\n\n                \n/tr\n\n            \n?php } ?\n\n        \n/tbody\n\n    \n/table\n\n    \n?php } ?\n\n\n    \nh3\n?php p($l-\nt('Add client')); ?\n/h3\n\n    \nform action=\n../apps/oauth2/clients\n method=\npost\n\n        \ninput id=\nname\n name=\nname\n type=\ntext\n placeholder=\n?php p($l-\nt('Name')); ?\n\n        \ninput id=\nredirect_uri\n name=\nredirect_uri\n type=\nurl\n placeholder=\n?php p($l-\nt('Redirect URI')); ?\n\n        \ninput type=\nsubmit\n class=\nbutton\n value=\n?php p($l-\nt('Add')); ?\n\n    \n/form\n\n\n/div\n\n\n\n\n\nIn diesem Template wird eine Tabelle mit den registrierten Clients angezeigt. Durch eine \nfor\n-Schleife wird f\u00fcr jeden Client aus dem Parameter \nclients\n ein Tabelleneintrag angezeigt. \nSollten noch keine Clients registriert worden sein, sorgt die \nif\n-Anweisung daf\u00fcr, dass die Meldung \u201eNo clients registered\u201c angezeigt wird. \nDurch Nutzung von \n$l-\nt()\n k\u00f6nnen die Strings auch \nin andere Sprachen \u00dcbersetzt werden\n.\n\n\n\n  \nTODO:\n Auf die Integration mit Transifex als \u00dcbersetzungsplattform eingehen.\n\n\n\n\nDes Weiteren gibt es unter der Tabelle ein Formular f\u00fcr das Hinzuf\u00fcgen von Clients. Die in dem Formular angegebene Aktion l\u00f6st die Funktion \naddClient\n im \nSettingsController\n aus. \nAnalog dazu gibt es f\u00fcr jeden Tabelleneintrag ein Formular zum L\u00f6schen des Eintrags, das die Funktion \ndeleteClient\n im \nSettingsController\n ausl\u00f6st.\n\n\n\n  \nTODO:\n Einbindung eigener CSS und JavaScript Dateien erw\u00e4hnen.\n\n\n\n\nHooks\n\n\nWenn ein Nutzer gel\u00f6scht wird, sollen dementsprechend auch alle seine Daten gel\u00f6scht werden, wozu auch jegliche Art von \nAuthorization Codes und Tokens aus dem OAuth 2.0 Protokollablauf geh\u00f6ren. Hooks m\u00fcssen also implementiert werden, um die \nS\u00e4uberung von Datenbankeintr\u00e4gen durchzuf\u00fchren. \n\n\nIn den \nHooks\n einer ownCloud App wird Code gespeichert, \nder vor oder nach einem bestimmten Ereignis ausgef\u00fchrt werden soll. \nDiese Hooks sind teilweise vorgefertig, k\u00f6nnen aber auch f\u00fcr bestimmte Funktionalit\u00e4ten selbst entworfen werden. \nDiese Hooks m\u00fcssen in den \nroutes\n registriert werden und die zugeh\u00f6rige Logik im \nContainer\n gespeichert werden.\n\n\nIn der App wurden Userhooks definiert, welche vor dem endg\u00fcltigen L\u00f6schen eines Nutzers Code ausf\u00fchren. \nZuerst wird eine Konstruktorfunktion aufgerufen, welche den \nuserManager\n, den \nauthorizationCodeMapper\n, den \naccessTokenMapper\n und den \nrefreshTokenMapper\n aufruft. \nDann wird der pre-delete Hook registriert und ein \ncallback\n f\u00fcr den Hook definiert. \nDieser \ncallback\n l\u00f6scht jegliche, dem Nutzer zugeh\u00f6rige, \nauthorizationCodes\n, \naccessTokens\n und \nrefreshTokens\n. \nDazu wird in den jeweiligen Konstruktoren die Methode \ndeleteByUID\n aufgerufen.\n\n\nFolgendes Codebeispiel zeigt den genannten Fall der \nUserHooks\n.\n\n\nclass UserHooks {\n\n    /**\n     * UserHooks constructor.\n     *\n     * @param IUserManager $userManager The user manager\n     * @param AuthorizationCodeMapper $authorizationCodeMapper The authorization code mapper\n     * @param AccessTokenMapper $accessTokenMapper The access token mapper\n     * @param RefreshTokenMapper $refreshTokenMapper The refresh token mapper\n     */\n    public function __construct(IUserManager $userManager,\n                                AuthorizationCodeMapper $authorizationCodeMapper,\n                                AccessTokenMapper $accessTokenMapper,\n                                RefreshTokenMapper $refreshTokenMapper) {\n        $this-\nuserManager = $userManager;\n        $this-\nauthorizationCodeMapper = $authorizationCodeMapper;\n        $this-\naccessTokenMapper = $accessTokenMapper;\n        $this-\nrefreshTokenMapper = $refreshTokenMapper;\n    }\n    /**\n     * Registers a pre-delete hook for users to delete authorization codes,\n     * access tokens and refresh tokens that reference the user.\n     */\n    public function register() {\n        /**\n         * @param User $user\n         */\n        $callback = function ($user) {\n            if (!is_null($user-\ngetUID())) {\n                $this-\nauthorizationCodeMapper-\ndeleteByUser($user-\ngetUID());\n                $this-\naccessTokenMapper-\ndeleteByUser($user-\ngetUID());\n                $this-\nrefreshTokenMapper-\ndeleteByUser($user-\ngetUID());\n            }\n        };\n        $this-\nuserManager-\nlisten('\\OC\\User', 'preDelete', $callback);\n    }\n}\n\n\n\n\nAuthentifizierungslogik\n\n\n\n  \nTODO:\n Implementierung der Authentifizierungslogik f\u00fcr WebDAV und die OCS Share API beschreiben. Registrierung in \ninfo.xml\n (\ntypes\n und \nauth-modules\n) und durch Event Listener beschreiben.\n\n\n\n\nBackground Job\n\n\n\n  \nTODO:\n Background Job, der abgelaufene Authorization Codes und Access Tokens l\u00f6scht, beschreiben.\n\n\n\n\nLogging\n\n\n\n  \nTODO:\n Logging beschreiben.\n\n\n\n\nProtokollablauf\n\n\nDer Protokollablauf der oauth2 App ist dem regul\u00e4ren OAuth2 Protokollablauf nachempfunden. \n\n\nZun\u00e4chst wird vom Moodle Plugin die Methode \nGET authorize\n mit den Parametern \nresponse_type\n, \nclient_id\n und \nredirect_uri\n ausgef\u00fchrt, welche die OAuth 2.0 App anspricht und f\u00fcr eine Weiterleitung an ownCloud sorgt. \nDann wird von ownCloud eine Authentifizierung erfragt, sprich der regul\u00e4re Anmeldebildschirm wird gezeigt, oder die Weiterleitung erfolgt sofort zur Autorisierungsabfrage der OAuth 2.0 App. \nNach erfolgter Autorisierung wird zur \nredirectURI\n aus der \nGET authorize\n Methode weitergeleitet, sprich zur\u00fcck zum Moodle Plugin. \n\n\nAnschlie\u00dfend f\u00fchrt das Moodle Plugin die Methode \nPOST /api/v1/token\n aus, die den Authorizationcode an die OAuth 2.0 App sendet und als Antwort einen Access Token erh\u00e4lt.\n\n\nNach erfolgter Autorisierung von Moodle mit ownCloud via OAuth 2.0 kann nun der WebDAV Zugriff folgen. Dieser erfolgt mit dem Access Code auf die OAuth WebDAV App. \nDiese kommuniziert daraufhin mit der OAuth 2.0 App \u00fcber die Methode \nGET api/v1/validate\n und dem Access Token und pr\u00fcft diesen. \nBei erfolgreicher \u00dcberpr\u00fcfung wird dann der WebDAV Zugriff entsprechend erm\u00f6glicht.\n\n\n\n\nTests und Continuous Integration\n\n\nZum Testen der PHP-Klassen wurde das Framework \nPHPUnit\n verwendet. Die aktuelle Testabdeckung ist bei Codecov einsehbar: \n.\n\n\nAls Continuous Integration Tool wurde Travis CI verwendet. Bei jeder \u00c4nderung im \nGitHub Repository\n wird ein Build angesto\u00dfen, in dem die App mithilfe eines Makefiles f\u00fcr den App Store gebaut wird und anschlie\u00dfend in verschiedenen Umgebungen installiert und getestet wird. Folgende Parameter werden variiert:\n\n\n\n\nPHP Versionen\n: 5.6, 7.0, 7.1, nightly\n\n\nDatenbanken\n: PostgreSQL, MySQL, SQLite\n\n\nBranches des ownCloud Core\n: \nmaster\n\n\n\n\nDer aktuelle Build-Status ist bei Travis einsehbar: \n.\n\n\nEinschr\u00e4nkungen\n\n\n\n  \nTODO:\n Einschr\u00e4nkungen mit der \nencryption\n App beschreiben.", 
            "title": "OAuth 2.0 App"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#app-oauth2", 
            "text": "", 
            "title": "App: oauth2"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#zweck", 
            "text": "In der App sollte der h\u00e4ufig f\u00fcr Webapplikationen eingesetzte  Authorization Code Flow  implementiert werden. Dazu mussten folgende User Stories umgesetzt werden:   Clientregistrierung:  Als ownCloud-Administrator m\u00f6chte ich Clients in den Administrator-Einstellungen hinzuf\u00fcgen und l\u00f6schen k\u00f6nnen, um die Kontrolle \u00fcber erlaubte Clients zu haben.  Authorization URL:  Als Client-Entwickler m\u00f6chte ich eine Authorization URL zur Verf\u00fcgung haben, um Authorization Codes anfordern zu k\u00f6nnen.  Access Token URL:  Als Client-Entwickler m\u00f6chte ich eine Access Token URL zur Verf\u00fcgung haben, um Access Tokens anfordern zu k\u00f6nnen.  Verwaltung autorisierter Applikationen : Als ownCloud-Nutzer m\u00f6chte ich in den pers\u00f6nlichen Einstellungen autorisierte Applikationen verwalten k\u00f6nnen, um einen \u00dcberblick zu haben und Autorisierungen widerrufen zu k\u00f6nnen.", 
            "title": "Zweck"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#datenmodell", 
            "text": "Zun\u00e4chst musste ein Datenmodell zur Speicherung der ben\u00f6tigten Daten aufgestellt werden. Gem\u00e4\u00df dem Authorization Code Flow wurden folgende Entit\u00e4ten mit Attributen definiert:   client :  Die Applikation, die f\u00fcr den Zugriff auf die WebDAV Schnittstelle autorisiert werden soll.  identifier : Zeichenkette, die einen Client eindeutig identifiziert.  secret : Zeichenkette, mit der ein Client sich beim Anfordern eines Access Tokens authentifizieren kann.  redirect_uri : URI, an die nach erfolgter Autorisierung des Nutzers weitergeleitet wird.    authorization_code :  Ein  Authorization Grant , \nmit dem der Client die Autorisierung des Nutzers darlegen und somit ein Access Token anfordern kann.  code : Zeichenkette, die als Authorization Code dient.  client_id : Client Identifier des Clients, f\u00fcr den der Authorization Code ausgegeben wird.  user_id : User ID des ownCloud-Nutzers, der den Client autorisiert hat.  expires : Zeitpunkt, zu dem der Authorization Code ung\u00fcltig wird (optional).    access_token :  Eine Zeichenkette, die den Zugriff auf die WebDAV Schnittstelle erlaubt.  code : Zeichenkette, die als Access Token dient.  client_id : Client Identifier des Clients, f\u00fcr den der Access Token ausgegeben wird.  user_id : User ID des ownCloud-Nutzers, der den Client autorisiert hat.  expires : Zeitpunkt, zu dem der Access Token ung\u00fcltig wird (optional).    refresh_token :  Eine Zeichenkette, mit der ein abgelaufener Access Token gegen einen neuen ausgetauscht werden kann.  code : Zeichenkette, die als Refresh Token dient.  client_id : Client Identifier des Clients, f\u00fcr den der Access Token ausgegeben wird.  user_id : User ID des ownCloud-Nutzers, der den Client autorisiert hat.  expires : Zeitpunkt, zu dem der Refresh Token ung\u00fcltig wird (optional).     Folgendes Entity-Relationship-Modell fasst das Datenmodell nochmal grafisch zusammen.", 
            "title": "Datenmodell"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#vorgegebene-schnittstelle", 
            "text": "TODO:  Die durch ownCloud Apps vorgegebene Schnittstelle beschreiben.", 
            "title": "Vorgegebene Schnittstelle"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#implementierung", 
            "text": "", 
            "title": "Implementierung"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#mapper-und-entities", 
            "text": "F\u00fcr den Datenbank-Zugriff im PHP-Code ist es in ownCloud m\u00f6glich,  Mapper  und  Entities  zu schreiben. \nDadurch werden Tupel in einer Datenbank-Tabelle automatisch in ein Objekt umgewandelt.  Folgendes Codebeispiel zeigt am Beispiel des Entitys  Client , wie eine PHP-Klasse dazu aussehen muss.  ?php\nnamespace OCA\\OAuth2\\Db;\n\nuse OCP\\AppFramework\\Db\\Entity;\n\n/**\n * Class Client\n *\n * @method string getIdentifier()\n * @method void setIdentifier(string $identifier)\n * @method string getSecret()\n * @method void setSecret(string $secret)\n * @method string getRedirectUri()\n * @method void setRedirectUri(string $redirectUri)\n * @method string getName()\n * @method void setName(string $name)\n */\nclass Client extends Entity {\n\n    protected $identifier;\n    protected $secret;\n    protected $redirectUri;\n    protected $name;\n\n    public function __construct() {\n        $this- addType('id', 'int');\n        $this- addType('identifier', 'string');\n        $this- addType('secret', 'string');\n        $this- addType('redirect_uri', 'string');\n        $this- addType('name', 'string');\n    }\n\n}  Wichtig ist, dass die Klasse von  Entity  erbt und sowohl der Klassenname als auch die Attribute mit denen der Tabelle \u00fcbereinstimmen. \nPascal bzw. Camel case im PHP-Code wird automatisch zu Snake case f\u00fcr die Datenbank umgewandelt. \nGetter und Setter werden ebenfalls automatisch generiert. Die PHPDoc Kommentare dienen lediglich dazu, in der Entwicklungsumgebung eine automatische Vervollst\u00e4ndigung zu haben. \nDie Angabe von  Typen  im Konstruktor dienen dazu, beim Lesen aus der Datenbank die richtige Umwandlung zu erhalten.  Das folgende Codebeispiel zeigt einen Ausschnitt aus dem zur  Client  Entity geh\u00f6renden Mapper.  ?php\nnamespace OCA\\OAuth2\\Db;\n\nuse InvalidArgumentException;\nuse OCP\\AppFramework\\Db\\Entity;\nuse OCP\\IDb;\nuse OCP\\AppFramework\\Db\\Mapper;\n\nclass ClientMapper extends Mapper {\n\n    /**\n     * ClientMapper constructor.\n     *\n     * @param IDb $db Database Connection.\n     */\n    public function __construct(IDb $db) {\n        parent::__construct($db, 'oauth2_clients');\n    }\n\n    /**\n     * Selects a client by its ID.\n     *\n     * @param int $id The client's ID.\n     *\n     * @return Entity The client entity.\n     *\n     * @throws \\OCP\\AppFramework\\Db\\DoesNotExistException if not found.\n     * @throws \\OCP\\AppFramework\\Db\\MultipleObjectsReturnedException if more than one result.\n     */\n    public function find($id) {\n        if (!is_int($id)) {\n            throw new InvalidArgumentException('id must not be null');\n        }\n\n        $sql = 'SELECT * FROM `' . $this- tableName . '` WHERE `id` = ?';\n        return $this- findEntity($sql, array($id), null, null);\n    }\n\n    /**\n     * Selects clients by the given user ID.\n     *\n     * @param string $userId The user ID.\n     *\n     * @return array The client entities.\n     */\n    public function findByUser($userId) {\n        if (!is_string($userId)) {\n            throw new InvalidArgumentException('userId must not be null');\n        }\n\n        $sql = 'SELECT * FROM `' . $this- tableName . '` '\n            . 'WHERE `id` IN ( '\n                . 'SELECT `client_id` FROM `oc_oauth2_authorization_codes` WHERE `user_id` = ? '\n                . 'UNION '\n                . 'SELECT `client_id` FROM `oc_oauth2_access_tokens` WHERE `user_id` = ? '\n            .')';\n        return $this- findEntities($sql, array($userId, $userId), null, null);\n    }\n\n}  Beim Mapper ist es wichtig, dass die Klasse von  Mapper  erbt und eine Entity-Klasse zu ihm existiert. \nDazu wird das Wort vor \u201eMapper\u201c als Entityname verwendet. Im Konstruktur wird der Tabellenname angegeben. \nDie beiden Funktionen  find  und  findByUser  demonstrieren  SELECT -Anweisungen. \nDazu wird die SQL-Anweisungen zusammen mit ben\u00f6tigten Parametern an  findEntity  bzw.  findEntities  \u00fcbergeben, abh\u00e4ngig davon, ob mehrere Entities im Ergebnis enthalten sein sollten. \nFunktionen zum l\u00f6schen, einf\u00fcgen und updaten werden von der Oberklasse bereits implementiert und mussten nicht angepasst werden.", 
            "title": "Mapper und Entities"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#schnittstellen-und-routes", 
            "text": "Um in einer ownCloud App Schnittstellen anzubieten, m\u00fcssen  Routes  registriert werden. \nZur Umsetzung der erw\u00e4hnten User Stories waren folgende Routes notwendig:     Methode  Endpunkt  Beschreibung      GET  authorize  Endpunkt, zu dem der Client den Nutzer weiterleitet, um die Autorisierung anzufragen (Authorization URL).    POST  authorize  Endpunkt, der aufgerufen wird, sobald der Nutzer den Client autorisiert hat.    POST  api/v1/token  Endpunkt, an dem ein Access Token angefordert wird (Access Token URL).    POST  clients  Endpunkt, durch den der Administrator einen Client hinzuf\u00fcgen kann.    POST  clients/{id}/delete  Endpunkt, durch den der Administrator den Client mit der ID  id  l\u00f6schen kann.    POST  clients/{id}/revoke  Endpunkt, durch den der Nutzer die Autorisierung des Clients mit der ID  id  widerrufen kann.     Registriert werden die Routes in der Datei  routes.php , indem ein Array mit den Routes zur\u00fcckgegeben wird. Nachfolgendes Codebeispiel zeigt einige der obigen Routes:  ?php\nreturn [\n    'routes' =  [\n        ['name' =  'page#authorize', 'url' =  '/authorize', 'verb' =  'GET'],\n        ['name' =  'o_auth_api#generate_token', 'url' =  '/api/v1/token', 'verb' =  'POST'],\n        ['name' =  'settings#deleteClient', 'url' =  '/clients/{id}/delete', 'verb' =  'POST']\n    ]\n];  Durch  name  wird f\u00fcr jede Route der Name des dazugeh\u00f6rigen  Controllers  sowie die aufzurufende Funktion angegeben. \nVor dem  # -Zeichen steht der Controllername in Snake case und hinter dem  # -Zeichen steht der Funktionsname (ebenfalls in Snake case). \nMithilfe von  url  wird der Endpunkt festgelegt und  verb  definiert die HTTP-Methode.", 
            "title": "Schnittstellen und Routes"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#controller", 
            "text": "Wenn an einem Endpunkt eine HTTP-Anfrage ankommt, so wird der in den Routes definierte  Controller  aufgerufen. \nWichtig ist hierbei, dass von der Klasse  Controller  oder \neiner Unterklasse wie  ApiController  geerbt wird.  F\u00fcr den Controller notwendige Parameter wie  Mapper  k\u00f6nnen im Konstruktor als Parameter angegeben und so durch  Dependency Injection  erhalten werden. \nNachfolgendes Codebeispiel zeigt den Konstruktor vom  PageController .  /**\n * PageController constructor.\n * \n * @param string $AppName The name of the app.\n * @param IRequest $request The request.\n * @param ClientMapper $clientMapper The client mapper.\n * @param AuthorizationCodeMapper $authorizationCodeMapper The authorization code mapper.\n * @param string $UserId The user ID.\n */\npublic function __construct($AppName, IRequest $request, ClientMapper $clientMapper,\n    AuthorizationCodeMapper $authorizationCodeMapper, $UserId) {\n    parent::__construct($AppName, $request);\n\n    $this- clientMapper = $clientMapper;\n    $this- authorizationCodeMapper = $authorizationCodeMapper;\n    $this- userId = $UserId;\n}  Die hier notwendigen Parameter sind der Name der App, eine  ClientMapper  Instanz, eine  AuthorizationCodeMapper  Instanz und die ID des Nutzers, \num bei der Autorisierung des Clients speichern zu k\u00f6nnen, welcher Nutzers dies veranlasst hat.  Die mit den Routes verkn\u00fcpften Funktionen k\u00f6nnen zur Zugriffskontrolle mit  PHPDoc Annotationen  \nversehen werden. Folgendes Codebeispiel zeigt die Annotationen f\u00fcr die Funktion  generateToken  im  OAuthApiController .  /**\n * Implements the OAuth 2.0 Access Token Response.\n *\n * @param string $code The authorization code.\n * @return JSONResponse The Access Token or an empty JSON Object.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n * @PublicPage\n * @CORS\n */\npublic function generateToken($code) { }  Die Annotationen haben dabei folgende Bedeutungen.     Annotation  Bedeutung      @NoAdminRequired  Aufruf auch von normalen Nutzern m\u00f6glich.    @NoCSRFRequired  Zeigt an, dass die \u00dcberpr\u00fcfung des CSRF Tokens nicht gewollt ist.    @PublicPage  Zugriff auch ohne Login m\u00f6glich.    @CORS  Aufruf der API durch andere Web Applikationen von au\u00dfen m\u00f6glich.     In den Controller-Funktionen k\u00f6nnen verschiedene Inhalte zur\u00fcckgegeben werden. Hier genutzte R\u00fcckgabetypen sind in der folgenden Tabelle zusammengefasst.     Typ  Beschreibung      TemplateResponse  Zur R\u00fcckgabe eines Templates, das dem Nutzer angezeigt werden soll.    RedirectResponse  Zur Weiterleitung des Nutzers an eine andere URL.    JSONResponse  Zur R\u00fcckgabe eines JSON Strings.     Ein Beispiel f\u00fcr die R\u00fcckgabetypen  TemplateResponse  und  RedirectResponse  gibt die Funktion  authorize  im  PageController , die im folgenden Codebeispiel zu sehen ist.  /**\n * Shows a view for the user to authorize a client.\n *\n * @param string $response_type The expected response type.\n * @param string $client_id The client identifier.\n * @param string $redirect_uri The redirect URI.\n * @param string $state The state.\n * @param string $scope The scope.\n *\n * @return TemplateResponse|RedirectResponse The authorize view or a\n * redirection to the ownCloud main page.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n */\npublic function authorize($response_type, $client_id, $redirect_uri, $state = null, $scope = null) {\n    if (!is_string($response_type) || !is_string($client_id)\n        || !is_string($redirect_uri) || (isset($state)   !is_string($state))\n        || (isset($scope)   !is_string($scope))) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    try {\n        /** @var Client $client */\n        $client = $this- clientMapper- findByIdentifier($client_id);\n    } catch (DoesNotExistException $exception) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    if (strcmp($client- getRedirectUri(), urldecode($redirect_uri)) !== 0) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n    if (strcmp($response_type, 'code') !== 0) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    return new TemplateResponse('oauth2', 'authorize', ['client_name' =  $client- getName()]);\n}  Hier werden zun\u00e4chst die Parameter auf G\u00fcltigkeit \u00fcberpr\u00fcft. Sollten die Parameter nicht g\u00fcltig sein (beispielsweise deshalb, \nweil der angegebene Client nicht existiert oder dessen Redirect URI falsch angegeben wurde) wird mit einem  RedirectResponse  auf die ownCloud Startseite umgeleitet. \nAndernfalls wird ein  TemplateResponse  f\u00fcr das Template  authorize  zur\u00fcckgegeben. \nF\u00fcr das Rendern des Templates k\u00f6nnen Parameter wie hier  client_name  f\u00fcr den Namen des Clients \u00fcbergeben werden.  Der R\u00fcckgabetyp  JSONResponse  wird f\u00fcr die R\u00fcckgabe des Access Tokens in der Funktion  generateToken  im  OAuthApiController  genutzt, \nwie nachfolgendes Codebeispiel zeigt. Zudem ist das Zusammenspiel mit Entities und Mappern zu sehen.  /**\n * Implements the OAuth 2.0 Access Token Response.\n *\n * @param string $code The authorization code.\n * @return JSONResponse The Access Token or an empty JSON Object.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n * @PublicPage\n * @CORS\n */\npublic function generateToken($code) {\n    if (is_null($code) || is_null($_SERVER['PHP_AUTH_USER'])\n        || is_null($_SERVER['PHP_AUTH_PW'])) {\n        return new JSONResponse(['message' =  'Missing credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    try {\n        /** @var Client $client */\n        $client = $this- clientMapper- findByIdentifier($_SERVER['PHP_AUTH_USER']);\n    } catch (DoesNotExistException $exception) {\n        return new JSONResponse(['message' =  'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    if (strcmp($client- getSecret(), $_SERVER['PHP_AUTH_PW']) !== 0) {\n        return new JSONResponse(['message' =  'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    try {\n        /** @var AuthorizationCode $authorizationCode */\n        $authorizationCode = $this- authorizationCodeMapper- findByCode($code);\n    } catch (DoesNotExistException $exception) {\n        return new JSONResponse(['message' =  'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    if (strcmp($authorizationCode- getClientId(), $client- getId()) !== 0) {\n        return new JSONResponse(['message' =  'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    $token = Utilities::generateRandom();\n    $userId = $authorizationCode- getUserId();\n    $accessToken = new AccessToken();\n    $accessToken- setToken($token);\n    $accessToken- setClientId($authorizationCode- getClientId());\n    $accessToken- setUserId($userId);\n    $this- accessTokenMapper- insert($accessToken);\n\n    $this- authorizationCodeMapper- delete($authorizationCode);\n\n    return new JSONResponse(\n        [\n            'access_token' =  $token,\n            'token_type' =  'Bearer',\n            'user_id' =  $userId\n        ]\n    );\n}  Nach erfolgreicher \u00dcberpr\u00fcfung des Authorization Codes und der Angaben zur Client Authentication im Authorization Header wird eine neuer Access Token erstellt und in der Datenbank gespeichert. \nDer verwendete Authorization Code wird zudem gel\u00f6scht. Im JSON Response wird dann der Access Token, der Token Typ und die ID des Nutzers zur\u00fcckgegeben. \nNachfolgend ist ein Beispiel dazu angegeben.  {\n     access_token  :  1vtnuo1NkIsbndAjVnhl7y0wJha59JyaAiFIVQDvcBY2uvKmj5EPBEhss0pauzdQ ,\n     token_type  :  Bearer ,\n     user_id  :  admin \n}  F\u00fcr die Token-Generierung wurde die Hilfsklasse  Utilities  mit der statischen Funktion  generateRandom  geschrieben, \ndie mithilfe einer ownCloud-internen Funktion 64-stellige Zeichenketten erzeugt. \nFolgendes Codebeispiel zeigt diese Klasse.  ?php\nnamespace OCA\\OAuth2;\n\nclass Utilities {\n\n    /**\n     * Generates a random string with 64 characters.\n     *\n     * @return string The random string.\n     */\n    public static function generateRandom() {\n        return \\OC::$server- getSecureRandom()- generate(64,\n            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789');\n    }\n\n}  Zusammenfassend werden im folgenden UML-Klassendiagramm die Controller mit ihren Beziehungen zu den Entities und Mappern dargestellt.  \n   TODO:  Klassendiagramme zusammenf\u00fcgen bzw. vervollst\u00e4ndigen.", 
            "title": "Controller"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#templates", 
            "text": "In den  Templates  einer ownCloud App wird die f\u00fcr den Nutzer sichtbare Oberfl\u00e4che definiert. \nEs k\u00f6nnen die vom  Controller  \u00fcbergebenen Parameter genutzt werden. Dazu gibt es ein Array mit dem Namen  $_ . \nZur Vermeidung von Cross-Site-Scripting gibt es die ownCloud-interne Funktion  p() , mithilfe derer Werte ausgegeben werden k\u00f6nnen.  Folgende Templates wurden in der App definiert:   authorize : Zur Darstellung des Authroization Requests, bei dem der Nutzer um Autorisierung eines Clients gebeten wird. \nEs werden ein Text zur Erkl\u00e4rung sowie Buttons zum Akzeptieren oder Ablehnen angezeigt.  settings-admin : Stellt zur Verwaltung der Clients eine tabellarische Auflistung der Clients sowie ein Formular zum Hinzuf\u00fcgen von Clients dar.  settings-personal : Stellt eine tabellarische Auflistung der vom Nutzer autorisierten Clients dar, mit der M\u00f6glichkeit, die Autorisierung zu widerrufen.   Folgendes Codebeispiel zeigt das Template  settings-admin .  ?php div class= section  id= oauth2 \n     h2 ?php p($l- t('OAuth 2.0')); ? /h2 \n\n     h3 ?php p($l- t('Registered clients')); ? /h3 \n     ?php if (empty($_['clients'])) {\n        p($l- t('No clients registered.'));\n    }\n    else { ? \n     table class= grid \n         thead \n         tr \n             th id= headerName  scope= col ?php p($l- t('Name')); ? /th \n             th id= headerRedirectUri  scope= col ?php p($l- t('Redirect URI')); ? /th \n             th id= headerClientIdentifier  scope= col ?php p($l- t('Client Identifier')); ? /th \n             th id= headerSecret  scope= col ?php p($l- t('Secret')); ? /th \n             th id= headerRemove nbsp; /th \n         /tr \n         /thead \n         tbody \n             ?php foreach ($_['clients'] as $client) { ? \n                 tr \n                     td ?php p($client- getName()); ? /td \n                     td ?php p($client- getRedirectUri()); ? /td \n                     td ?php p($client- getIdentifier()); ? /td \n                     td ?php p($client- getSecret()); ? /td \n                     td \n                         form action= ../apps/oauth2/clients/ ?php p($client- getId()); ? /delete  method= post \n                              style='display:inline;' \n                             input type= submit  class= button icon-delete  value= \n                         /form \n                     /td \n                 /tr \n             ?php } ? \n         /tbody \n     /table \n     ?php } ? \n\n     h3 ?php p($l- t('Add client')); ? /h3 \n     form action= ../apps/oauth2/clients  method= post \n         input id= name  name= name  type= text  placeholder= ?php p($l- t('Name')); ? \n         input id= redirect_uri  name= redirect_uri  type= url  placeholder= ?php p($l- t('Redirect URI')); ? \n         input type= submit  class= button  value= ?php p($l- t('Add')); ? \n     /form  /div   In diesem Template wird eine Tabelle mit den registrierten Clients angezeigt. Durch eine  for -Schleife wird f\u00fcr jeden Client aus dem Parameter  clients  ein Tabelleneintrag angezeigt. \nSollten noch keine Clients registriert worden sein, sorgt die  if -Anweisung daf\u00fcr, dass die Meldung \u201eNo clients registered\u201c angezeigt wird. \nDurch Nutzung von  $l- t()  k\u00f6nnen die Strings auch  in andere Sprachen \u00dcbersetzt werden .  \n   TODO:  Auf die Integration mit Transifex als \u00dcbersetzungsplattform eingehen.  Des Weiteren gibt es unter der Tabelle ein Formular f\u00fcr das Hinzuf\u00fcgen von Clients. Die in dem Formular angegebene Aktion l\u00f6st die Funktion  addClient  im  SettingsController  aus. \nAnalog dazu gibt es f\u00fcr jeden Tabelleneintrag ein Formular zum L\u00f6schen des Eintrags, das die Funktion  deleteClient  im  SettingsController  ausl\u00f6st.  \n   TODO:  Einbindung eigener CSS und JavaScript Dateien erw\u00e4hnen.", 
            "title": "Templates"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#hooks", 
            "text": "Wenn ein Nutzer gel\u00f6scht wird, sollen dementsprechend auch alle seine Daten gel\u00f6scht werden, wozu auch jegliche Art von \nAuthorization Codes und Tokens aus dem OAuth 2.0 Protokollablauf geh\u00f6ren. Hooks m\u00fcssen also implementiert werden, um die \nS\u00e4uberung von Datenbankeintr\u00e4gen durchzuf\u00fchren.   In den  Hooks  einer ownCloud App wird Code gespeichert, \nder vor oder nach einem bestimmten Ereignis ausgef\u00fchrt werden soll. \nDiese Hooks sind teilweise vorgefertig, k\u00f6nnen aber auch f\u00fcr bestimmte Funktionalit\u00e4ten selbst entworfen werden. \nDiese Hooks m\u00fcssen in den  routes  registriert werden und die zugeh\u00f6rige Logik im  Container  gespeichert werden.  In der App wurden Userhooks definiert, welche vor dem endg\u00fcltigen L\u00f6schen eines Nutzers Code ausf\u00fchren. \nZuerst wird eine Konstruktorfunktion aufgerufen, welche den  userManager , den  authorizationCodeMapper , den  accessTokenMapper  und den  refreshTokenMapper  aufruft. \nDann wird der pre-delete Hook registriert und ein  callback  f\u00fcr den Hook definiert. \nDieser  callback  l\u00f6scht jegliche, dem Nutzer zugeh\u00f6rige,  authorizationCodes ,  accessTokens  und  refreshTokens . \nDazu wird in den jeweiligen Konstruktoren die Methode  deleteByUID  aufgerufen.  Folgendes Codebeispiel zeigt den genannten Fall der  UserHooks .  class UserHooks {\n\n    /**\n     * UserHooks constructor.\n     *\n     * @param IUserManager $userManager The user manager\n     * @param AuthorizationCodeMapper $authorizationCodeMapper The authorization code mapper\n     * @param AccessTokenMapper $accessTokenMapper The access token mapper\n     * @param RefreshTokenMapper $refreshTokenMapper The refresh token mapper\n     */\n    public function __construct(IUserManager $userManager,\n                                AuthorizationCodeMapper $authorizationCodeMapper,\n                                AccessTokenMapper $accessTokenMapper,\n                                RefreshTokenMapper $refreshTokenMapper) {\n        $this- userManager = $userManager;\n        $this- authorizationCodeMapper = $authorizationCodeMapper;\n        $this- accessTokenMapper = $accessTokenMapper;\n        $this- refreshTokenMapper = $refreshTokenMapper;\n    }\n    /**\n     * Registers a pre-delete hook for users to delete authorization codes,\n     * access tokens and refresh tokens that reference the user.\n     */\n    public function register() {\n        /**\n         * @param User $user\n         */\n        $callback = function ($user) {\n            if (!is_null($user- getUID())) {\n                $this- authorizationCodeMapper- deleteByUser($user- getUID());\n                $this- accessTokenMapper- deleteByUser($user- getUID());\n                $this- refreshTokenMapper- deleteByUser($user- getUID());\n            }\n        };\n        $this- userManager- listen('\\OC\\User', 'preDelete', $callback);\n    }\n}", 
            "title": "Hooks"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#authentifizierungslogik", 
            "text": "TODO:  Implementierung der Authentifizierungslogik f\u00fcr WebDAV und die OCS Share API beschreiben. Registrierung in  info.xml  ( types  und  auth-modules ) und durch Event Listener beschreiben.", 
            "title": "Authentifizierungslogik"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#background-job", 
            "text": "TODO:  Background Job, der abgelaufene Authorization Codes und Access Tokens l\u00f6scht, beschreiben.", 
            "title": "Background Job"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#logging", 
            "text": "TODO:  Logging beschreiben.", 
            "title": "Logging"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#protokollablauf", 
            "text": "Der Protokollablauf der oauth2 App ist dem regul\u00e4ren OAuth2 Protokollablauf nachempfunden.   Zun\u00e4chst wird vom Moodle Plugin die Methode  GET authorize  mit den Parametern  response_type ,  client_id  und  redirect_uri  ausgef\u00fchrt, welche die OAuth 2.0 App anspricht und f\u00fcr eine Weiterleitung an ownCloud sorgt. \nDann wird von ownCloud eine Authentifizierung erfragt, sprich der regul\u00e4re Anmeldebildschirm wird gezeigt, oder die Weiterleitung erfolgt sofort zur Autorisierungsabfrage der OAuth 2.0 App. \nNach erfolgter Autorisierung wird zur  redirectURI  aus der  GET authorize  Methode weitergeleitet, sprich zur\u00fcck zum Moodle Plugin.   Anschlie\u00dfend f\u00fchrt das Moodle Plugin die Methode  POST /api/v1/token  aus, die den Authorizationcode an die OAuth 2.0 App sendet und als Antwort einen Access Token erh\u00e4lt.  Nach erfolgter Autorisierung von Moodle mit ownCloud via OAuth 2.0 kann nun der WebDAV Zugriff folgen. Dieser erfolgt mit dem Access Code auf die OAuth WebDAV App. \nDiese kommuniziert daraufhin mit der OAuth 2.0 App \u00fcber die Methode  GET api/v1/validate  und dem Access Token und pr\u00fcft diesen. \nBei erfolgreicher \u00dcberpr\u00fcfung wird dann der WebDAV Zugriff entsprechend erm\u00f6glicht.", 
            "title": "Protokollablauf"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#tests-und-continuous-integration", 
            "text": "Zum Testen der PHP-Klassen wurde das Framework  PHPUnit  verwendet. Die aktuelle Testabdeckung ist bei Codecov einsehbar:  .  Als Continuous Integration Tool wurde Travis CI verwendet. Bei jeder \u00c4nderung im  GitHub Repository  wird ein Build angesto\u00dfen, in dem die App mithilfe eines Makefiles f\u00fcr den App Store gebaut wird und anschlie\u00dfend in verschiedenen Umgebungen installiert und getestet wird. Folgende Parameter werden variiert:   PHP Versionen : 5.6, 7.0, 7.1, nightly  Datenbanken : PostgreSQL, MySQL, SQLite  Branches des ownCloud Core :  master   Der aktuelle Build-Status ist bei Travis einsehbar:  .", 
            "title": "Tests und Continuous Integration"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/oauth2-app/#einschrankungen", 
            "text": "TODO:  Einschr\u00e4nkungen mit der  encryption  App beschreiben.", 
            "title": "Einschr\u00e4nkungen"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/core-anpassungen/", 
            "text": "Core Anpassungen\n\n\nZweck\n\n\nUm die Funktionalit\u00e4ten des OAuth 2.0 Protokolls mit Hilfe der App nutzen zu k\u00f6nnen, mussten die \n\nWebDAV Schnittstelle\n und auch die \n\nOCS Schnittstelle\n um die Authentifizierungsmethode OAuth 2.0 erweitert werden.\nDazu wurde ein \nPull Request\n gestellt, um entsprechende \u00c4nderungen durchzuf\u00fchren.\n\n\nVorgegebene Schnittstelle\n\n\nImplementierung\n\n\nTests und Continuous Integration", 
            "title": "Core Anpassungen"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/core-anpassungen/#core-anpassungen", 
            "text": "", 
            "title": "Core Anpassungen"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/core-anpassungen/#zweck", 
            "text": "Um die Funktionalit\u00e4ten des OAuth 2.0 Protokolls mit Hilfe der App nutzen zu k\u00f6nnen, mussten die  WebDAV Schnittstelle  und auch die  OCS Schnittstelle  um die Authentifizierungsmethode OAuth 2.0 erweitert werden.\nDazu wurde ein  Pull Request  gestellt, um entsprechende \u00c4nderungen durchzuf\u00fchren.", 
            "title": "Zweck"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/core-anpassungen/#vorgegebene-schnittstelle", 
            "text": "", 
            "title": "Vorgegebene Schnittstelle"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/core-anpassungen/#implementierung", 
            "text": "", 
            "title": "Implementierung"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/core-anpassungen/#tests-und-continuous-integration", 
            "text": "", 
            "title": "Tests und Continuous Integration"
        }, 
        {
            "location": "/owncloud/benutzung/", 
            "text": "Benutzung\n\n\nInstallation\n\n\nDa die Anpassungen durch den Pull Request \nowncloud/core#26742\n erst k\u00fcrzlich in den ownCloud Core aufgenommen wurden, sind sie noch in keiner Hauptversion enthalten. Es muss daher der aktuelle Stand aus dem \nRepository\n heruntergeladen werden:\n\n\n$ git clone https://github.com/owncloud/core.git\n\n\n\n\nDanach m\u00fcssen die Abh\u00e4ngigkeiten aufgel\u00f6st werden. Dazu gen\u00fcgt es, im Verzeichnis des Repositorys folgenden Befehl auszuf\u00fchren:\n\n\n$ make\n\n\n\n\nDie restlichen Installationsschritte von ownCloud unterscheiden sich nicht von denen im \nownCloud Handbuch\n.\n\n\nDie \noauth2\n App wird dadurch installiert, dass der Inhalt des \nRepositorys\n in das Verzeichnis \napps\n kopiert wird:\n\n\n$ cd apps\n$ git clone https://github.com/owncloud/oauth2.git\n\n\n\n\nDanach l\u00e4sst sie sich wie jede andere ownCloud App in der Administrator-Ansicht aktivieren.\n\n\nClientregistrierung\n\n\nZur Clientregistrierung muss in der Eingabemaske der OAuth 2 App in den Adminsettings dem Client ein Name gegeben werden und eine g\u00fcltige URL als \nredirect URI\n angegeben werden. \nEine \nredirect URI\n bezeichnet eine Adresse, zu der der jeweilige Client nach der erfolgreichen Autorisierung weitergeleitet wird. Setzt man einen Haken im Feld \nErlaube Subdomains\n, so \nk\u00f6nnen auch Subdomains der eingegebenen \nredirect URI\n angesprochen werden. So lange also der Haken gesetzt wurde und die entsprechende Adresse f\u00fcr die\n\"Hauptdomain\" angegeben wurde, funktioniert der Authentifizierungsmechanismus auch mit den Subdomains\nMit Bet\u00e4tigung des OK-Buttons wird der Client registriert, erh\u00e4lt eine \nClientID\n und ein \nClientsecret\n zugewiesen und wird nun in der Tabelle mit den entsprechenden Attributen dargestellt.\n\n\n\n    \n\n\n\n\n\nScreenshot zur Darstellung der Clients:\n\n\n\n\nAuthorization Code Flow\n\n\nDie nachfolgende Abbildung stellt den durch die \noauth2\n App implementierten \nOAuth 2.0 Authorization Code Flow\n dar.\n\n\n\n\nAnmerkung: Die Schritte 1, 2 und 3 sind zweigeteilt, da sie durch den User-Agent laufen.\n\n\nDer dargestellte Authorization Code Flow beinhaltet die folgenden Schritte:\n\n\n\n\nClient Identifier \n Redirection URI: Der Client (hier Learnweb) initiiert den Flow durch die Weiterleitung des User-Agents des Resource Owners\nzum Authorization Endpoint. Der Client f\u00fcgt seinen Client Identifier, das angefragte Scope, Status und eine \nredirection URI\n an, zu welcher der\nUser-Agent vom Authorization Server (hier sciebo) zur\u00fcckgeleitet wird, wenn der Zugriff gestattet, oder abgelehnt wurde.\n\n\nAuthentifizierung durch Benutzer: Der Authorization Server authentifiziert den Resource Owner (\u00fcber den User-Agent) und stellt fest,\nob der Resource Owner die Zugriffsanfrage des Clients zul\u00e4sst oder ablehnt.\n\n\nAuthorization Code: Vorausgesetzt der Resource Owner erlaubt den Zugriff, so leitet der Authorization Server den User-Agent zur\u00fcck zum Client,\nwozu die vorher (in der Anfrage oder w\u00e4hrend der Clientregistrierung) bereitgestellte \nredirection URI\n genutzt wird. Die \n\nredirection URI\n beinhaltet einen \nauthorization code\n und jeglichen vom Client im Vorhinein bereitgestellten Status.\n\n\nAuthorization Code \n Redirection URI: Der Client fragt ein Access Token vom Endpunkt des Authorization Servers an, indem\nder Authorization Code aus dem vorherigen Schritt angef\u00fcgt wird. Wenn die Anfrage durchgef\u00fchrt wird, authentifiziert sich der Client\nautomatisch mit dem Authorization Server. Der Client f\u00fcgt die f\u00fcr den Erhalt des \nauthorization codes\n genutzte \nredirection URI\n\nzur Verifizierung an.\n\n\nAccess Token (\n optional: Refresh Token): Der Authorization Server authentifiziert den Client, validiert den \nauthorization code\n, und\npr\u00fcft, dass die empfangene \nredirection URI\n mit der zur Weiterleitung im dritten Schritt (\"Authorization Code\") genutzte URI \u00fcbereinstimmt.\nWenn die \u00dcberpr\u00fcfung erfolgreich verl\u00e4uft, antwortet der Authorization Server mit einem \naccess token\n und optional mit einem \nrefresh token\n.\n\n\n\n\nAngepasste WebDAV und OCS Schnittstelle\n\n\n\n  \nTODO:\n Ausf\u00fchrung entsprechend dem Abschnitt in technische-umsetzung.md\n\n\n\n\nWiderrufung der Autorisierung\n\n\nZur Widerrufung der Autorisierung muss diese in den Einstellungen per Klick auf den entsprechenden Button widerrufen werden. \nDies ist f\u00fcr den Nutzer in den pers\u00f6nlichen Einstellungen m\u00f6glich, durch Klicken des M\u00fclleimer-Symbols rechts neben dem jeweiligen Eintrag.\nNachdem auf das Symbol geklickt wurde, erscheint auch hier eine Sicherheitsabfrage, in der man die L\u00f6schung best\u00e4tigen muss.\n\n\nScreenshot zur Darstellung der autorisierten Anwendungen:\n\n\n\n    \n\n\n\n\n\nScreenshot zur Sicherheitsabfrage bei L\u00f6schung einer autorisierten Anwendung:\n\n\n\n    \n\n\n\n\n\nL\u00f6schen der Clientregistrierung\n\n\nBei Bedarf kann ein Client beziehungsweise eine Clientregistrierung gel\u00f6scht werden. Dies kann notwendig sein, wenn sich\nbeim Client die \nredirect URI\n ge\u00e4ndert hat, oder man dem Client einfach nicht mehr den Zugriff gew\u00e4hren m\u00f6chte. Dadurch, dass\nein Client gel\u00f6scht wird, kann dieser nun nicht mehr auf Dateien aus der ownCloud-Instanz zugreifen und die ausgestellten Authorization\nCodes, Access und Refresh Tokens sind ung\u00fcltig. Durch irrt\u00fcmliche L\u00f6schung des Clients muss bei Wiedereintragung des Clients jeder\nNutzer des Clients erneut das Authentifizierungsverfahren durchlaufen.\nUm eine Clientregistrierung zu l\u00f6schen muss in den Adminsettings die tabellarische Ansicht der registrierten Clients ausgew\u00e4hlt werden. \nNun kann man bei dem zu l\u00f6schenden Client rechts neben den zugeordneten Attributen auf ein M\u00fclleimer-Symbol klicken, um die entsprechende Clientregistrierung zu l\u00f6schen.\nNachdem auf das Symbol geklickt wurde, erscheint noch eine Sicherheitsabfrage, in der man die L\u00f6schung best\u00e4tigen muss.\n\n\nScreenshot zur Sicherheitsabfrage bei L\u00f6schung des Clients:", 
            "title": "Benutzung"
        }, 
        {
            "location": "/owncloud/benutzung/#benutzung", 
            "text": "", 
            "title": "Benutzung"
        }, 
        {
            "location": "/owncloud/benutzung/#installation", 
            "text": "Da die Anpassungen durch den Pull Request  owncloud/core#26742  erst k\u00fcrzlich in den ownCloud Core aufgenommen wurden, sind sie noch in keiner Hauptversion enthalten. Es muss daher der aktuelle Stand aus dem  Repository  heruntergeladen werden:  $ git clone https://github.com/owncloud/core.git  Danach m\u00fcssen die Abh\u00e4ngigkeiten aufgel\u00f6st werden. Dazu gen\u00fcgt es, im Verzeichnis des Repositorys folgenden Befehl auszuf\u00fchren:  $ make  Die restlichen Installationsschritte von ownCloud unterscheiden sich nicht von denen im  ownCloud Handbuch .  Die  oauth2  App wird dadurch installiert, dass der Inhalt des  Repositorys  in das Verzeichnis  apps  kopiert wird:  $ cd apps\n$ git clone https://github.com/owncloud/oauth2.git  Danach l\u00e4sst sie sich wie jede andere ownCloud App in der Administrator-Ansicht aktivieren.", 
            "title": "Installation"
        }, 
        {
            "location": "/owncloud/benutzung/#clientregistrierung", 
            "text": "Zur Clientregistrierung muss in der Eingabemaske der OAuth 2 App in den Adminsettings dem Client ein Name gegeben werden und eine g\u00fcltige URL als  redirect URI  angegeben werden. \nEine  redirect URI  bezeichnet eine Adresse, zu der der jeweilige Client nach der erfolgreichen Autorisierung weitergeleitet wird. Setzt man einen Haken im Feld  Erlaube Subdomains , so \nk\u00f6nnen auch Subdomains der eingegebenen  redirect URI  angesprochen werden. So lange also der Haken gesetzt wurde und die entsprechende Adresse f\u00fcr die\n\"Hauptdomain\" angegeben wurde, funktioniert der Authentifizierungsmechanismus auch mit den Subdomains\nMit Bet\u00e4tigung des OK-Buttons wird der Client registriert, erh\u00e4lt eine  ClientID  und ein  Clientsecret  zugewiesen und wird nun in der Tabelle mit den entsprechenden Attributen dargestellt.  \n       Screenshot zur Darstellung der Clients:", 
            "title": "Clientregistrierung"
        }, 
        {
            "location": "/owncloud/benutzung/#authorization-code-flow", 
            "text": "Die nachfolgende Abbildung stellt den durch die  oauth2  App implementierten  OAuth 2.0 Authorization Code Flow  dar.   Anmerkung: Die Schritte 1, 2 und 3 sind zweigeteilt, da sie durch den User-Agent laufen.  Der dargestellte Authorization Code Flow beinhaltet die folgenden Schritte:   Client Identifier   Redirection URI: Der Client (hier Learnweb) initiiert den Flow durch die Weiterleitung des User-Agents des Resource Owners\nzum Authorization Endpoint. Der Client f\u00fcgt seinen Client Identifier, das angefragte Scope, Status und eine  redirection URI  an, zu welcher der\nUser-Agent vom Authorization Server (hier sciebo) zur\u00fcckgeleitet wird, wenn der Zugriff gestattet, oder abgelehnt wurde.  Authentifizierung durch Benutzer: Der Authorization Server authentifiziert den Resource Owner (\u00fcber den User-Agent) und stellt fest,\nob der Resource Owner die Zugriffsanfrage des Clients zul\u00e4sst oder ablehnt.  Authorization Code: Vorausgesetzt der Resource Owner erlaubt den Zugriff, so leitet der Authorization Server den User-Agent zur\u00fcck zum Client,\nwozu die vorher (in der Anfrage oder w\u00e4hrend der Clientregistrierung) bereitgestellte  redirection URI  genutzt wird. Die  redirection URI  beinhaltet einen  authorization code  und jeglichen vom Client im Vorhinein bereitgestellten Status.  Authorization Code   Redirection URI: Der Client fragt ein Access Token vom Endpunkt des Authorization Servers an, indem\nder Authorization Code aus dem vorherigen Schritt angef\u00fcgt wird. Wenn die Anfrage durchgef\u00fchrt wird, authentifiziert sich der Client\nautomatisch mit dem Authorization Server. Der Client f\u00fcgt die f\u00fcr den Erhalt des  authorization codes  genutzte  redirection URI \nzur Verifizierung an.  Access Token (  optional: Refresh Token): Der Authorization Server authentifiziert den Client, validiert den  authorization code , und\npr\u00fcft, dass die empfangene  redirection URI  mit der zur Weiterleitung im dritten Schritt (\"Authorization Code\") genutzte URI \u00fcbereinstimmt.\nWenn die \u00dcberpr\u00fcfung erfolgreich verl\u00e4uft, antwortet der Authorization Server mit einem  access token  und optional mit einem  refresh token .", 
            "title": "Authorization Code Flow"
        }, 
        {
            "location": "/owncloud/benutzung/#angepasste-webdav-und-ocs-schnittstelle", 
            "text": "TODO:  Ausf\u00fchrung entsprechend dem Abschnitt in technische-umsetzung.md", 
            "title": "Angepasste WebDAV und OCS Schnittstelle"
        }, 
        {
            "location": "/owncloud/benutzung/#widerrufung-der-autorisierung", 
            "text": "Zur Widerrufung der Autorisierung muss diese in den Einstellungen per Klick auf den entsprechenden Button widerrufen werden. \nDies ist f\u00fcr den Nutzer in den pers\u00f6nlichen Einstellungen m\u00f6glich, durch Klicken des M\u00fclleimer-Symbols rechts neben dem jeweiligen Eintrag.\nNachdem auf das Symbol geklickt wurde, erscheint auch hier eine Sicherheitsabfrage, in der man die L\u00f6schung best\u00e4tigen muss.  Screenshot zur Darstellung der autorisierten Anwendungen:  \n       Screenshot zur Sicherheitsabfrage bei L\u00f6schung einer autorisierten Anwendung:", 
            "title": "Widerrufung der Autorisierung"
        }, 
        {
            "location": "/owncloud/benutzung/#loschen-der-clientregistrierung", 
            "text": "Bei Bedarf kann ein Client beziehungsweise eine Clientregistrierung gel\u00f6scht werden. Dies kann notwendig sein, wenn sich\nbeim Client die  redirect URI  ge\u00e4ndert hat, oder man dem Client einfach nicht mehr den Zugriff gew\u00e4hren m\u00f6chte. Dadurch, dass\nein Client gel\u00f6scht wird, kann dieser nun nicht mehr auf Dateien aus der ownCloud-Instanz zugreifen und die ausgestellten Authorization\nCodes, Access und Refresh Tokens sind ung\u00fcltig. Durch irrt\u00fcmliche L\u00f6schung des Clients muss bei Wiedereintragung des Clients jeder\nNutzer des Clients erneut das Authentifizierungsverfahren durchlaufen.\nUm eine Clientregistrierung zu l\u00f6schen muss in den Adminsettings die tabellarische Ansicht der registrierten Clients ausgew\u00e4hlt werden. \nNun kann man bei dem zu l\u00f6schenden Client rechts neben den zugeordneten Attributen auf ein M\u00fclleimer-Symbol klicken, um die entsprechende Clientregistrierung zu l\u00f6schen.\nNachdem auf das Symbol geklickt wurde, erscheint noch eine Sicherheitsabfrage, in der man die L\u00f6schung best\u00e4tigen muss.  Screenshot zur Sicherheitsabfrage bei L\u00f6schung des Clients:", 
            "title": "L\u00f6schen der Clientregistrierung"
        }, 
        {
            "location": "/moodle/technische-umsetzung/softwarearchitektur/", 
            "text": "Softwarearchitektur\n\n\nZur Umsetzung des Projektziels, musste Moodle um n\u00f6tige Funktionalit\u00e4ten erg\u00e4nzt werden, die weder durch den \nMoodle Core\n\nbereitgestellt werden, noch mit Hilfe von externen Plugins hinzugef\u00fcgt werden konnten. Im Folgenden wird beschrieben,\nwie Moodle im Rahmen des Projektes erweitert wurde und welche Auswirkungen sich daraus ergaben.\n\n\n\u00dcbersicht \u00fcber die Plugin-Struktur\n\n\nMoodle \nPlugins\n dienen dazu um im Core angebotene Funktionalit\u00e4ten dahingehend zu erweitern, dass diese den\nindividuellen Bed\u00fcrfnissen des Nutzers entsprechen. Daher eignete sich die Implementierung solcher Plugins ideal zur Umsetzung der definierten Integrationsszenarien.\nIn Moodle wird ein Plugin einer \nKategorie\n zugeordnet, welche eine bestimmte Art von Funktionalit\u00e4t repr\u00e4sentiert.\nDa unsere Use Cases verschiedene Arten von Funktionalit\u00e4ten ben\u00f6tigen haben wir uns f\u00fcr verschiedene Plugintypen entschieden.\n\n\n\n\n\n\n\n\nPlugintyp\n\n\nBeschreibung\n\n\nZweck f\u00fcr das Projekt\n\n\n\n\n\n\n\n\n\n\nadmin tool\n oauth2sciebo\n\n\nBietet Dienste zur Site-Administration an, d.h. die Einstellungen gelten global und k\u00f6nnen nur vom Administrator der Seite get\u00e4tigt werden\n\n\nVerwaltung der Authentifizierung mittels OAuth 2.0\n\n\n\n\n\n\nrepository\n sciebo\n\n\nStellt die Verbindung zu einer externen Datenquelle her\n\n\nDatenbeschaffung aus Sciebo\n\n\n\n\n\n\nactivity\n collaborativefolders\n\n\nStellt Aktivit\u00e4ten in einem Kurs zur Verf\u00fcgung\n\n\nErstellung von Ordnern f\u00fcr kollaboratives Arbeiten\n\n\n\n\n\n\n\n\nFunktions\u00fcbersicht\n\n\nDie in den verschiedenen Plugins angebotenen Funktionalit\u00e4ten k\u00f6nnen wie folgt zusammengefasst werden:\n\n\n\n\nAdmin Tool\n:\n \noauth2sciebo\n\n\nUmfasst sowohl OAuth 2.0, als auch einen WebDAV Client.\n\n\nSteuert den Protokollablauf von OAuth 2.0 und verwaltet alle dazu n\u00f6tigen Informationen.\n\n\nglobale Speicherung des Secrets und der ClientID\n\n\n\n\n\n\nStellt das Verbindungsst\u00fcck von moodle zu Sciebo bzw. ownCloud zur Verf\u00fcgung\n\n\n\n\n\n\nRepository\n:\n \nsciebo\n\n\nBewerkstelligt die Datenbeschaffung aus Sciebo bzw. ownCloud nach Moodle.\n\n\nErm\u00f6glicht den Upload von Dateien aus einer pers\u00f6nlichen Sciebo Instanz.\n\n\nErm\u00f6glicht die Verlinkung von Dateien aus Sciebo in Moodle.\n\n\n\n\n\n\nActivity Module\n:\n \ncollaborative folders\n\n\nErm\u00f6glicht die Erstellung und Freigabe von Ordern in Sciebo f\u00fcr bestimmte Gruppen in Moodle.\n\n\n\n\n\n\n\n\nAbh\u00e4ngigkeiten\n\n\nDie aus der Aufteilung der Funktionen in verschiedene Plugins resultierenden Abh\u00e4ngigkeiten werden in folgender Abbildung\ndargestellt:\n\n\n\n\nZu beachten ist, dass eine m\u00f6glichst hohe Flexibilit\u00e4t und Modularit\u00e4t bei dem Entwurf der Softwarearchitektur erzielt\nwerden sollte. Das f\u00fchrt zwar mit sich, dass funktionale Plugins (also das \nrepository\n und das \nactivity\n Plugin) nicht\neigenst\u00e4ndig ohne das \nadmin tool\n existieren k\u00f6nnen, allerdings wird weiteren, in Zukunft entwickelten Plugins ebenfalls\nZugriff auf die OAuth 2.0 Schnittstelle in \nSciebo\n bzw. \nownCloud\n erm\u00f6glicht,\nwodurch sich das Projektergebnis zu einer guten Wiederverwendbarkeit qualifiziert.", 
            "title": "Softwarearchitektur"
        }, 
        {
            "location": "/moodle/technische-umsetzung/softwarearchitektur/#softwarearchitektur", 
            "text": "Zur Umsetzung des Projektziels, musste Moodle um n\u00f6tige Funktionalit\u00e4ten erg\u00e4nzt werden, die weder durch den  Moodle Core \nbereitgestellt werden, noch mit Hilfe von externen Plugins hinzugef\u00fcgt werden konnten. Im Folgenden wird beschrieben,\nwie Moodle im Rahmen des Projektes erweitert wurde und welche Auswirkungen sich daraus ergaben.", 
            "title": "Softwarearchitektur"
        }, 
        {
            "location": "/moodle/technische-umsetzung/softwarearchitektur/#ubersicht-uber-die-plugin-struktur", 
            "text": "Moodle  Plugins  dienen dazu um im Core angebotene Funktionalit\u00e4ten dahingehend zu erweitern, dass diese den\nindividuellen Bed\u00fcrfnissen des Nutzers entsprechen. Daher eignete sich die Implementierung solcher Plugins ideal zur Umsetzung der definierten Integrationsszenarien.\nIn Moodle wird ein Plugin einer  Kategorie  zugeordnet, welche eine bestimmte Art von Funktionalit\u00e4t repr\u00e4sentiert.\nDa unsere Use Cases verschiedene Arten von Funktionalit\u00e4ten ben\u00f6tigen haben wir uns f\u00fcr verschiedene Plugintypen entschieden.     Plugintyp  Beschreibung  Zweck f\u00fcr das Projekt      admin tool  oauth2sciebo  Bietet Dienste zur Site-Administration an, d.h. die Einstellungen gelten global und k\u00f6nnen nur vom Administrator der Seite get\u00e4tigt werden  Verwaltung der Authentifizierung mittels OAuth 2.0    repository  sciebo  Stellt die Verbindung zu einer externen Datenquelle her  Datenbeschaffung aus Sciebo    activity  collaborativefolders  Stellt Aktivit\u00e4ten in einem Kurs zur Verf\u00fcgung  Erstellung von Ordnern f\u00fcr kollaboratives Arbeiten", 
            "title": "\u00dcbersicht \u00fcber die Plugin-Struktur"
        }, 
        {
            "location": "/moodle/technische-umsetzung/softwarearchitektur/#funktionsubersicht", 
            "text": "Die in den verschiedenen Plugins angebotenen Funktionalit\u00e4ten k\u00f6nnen wie folgt zusammengefasst werden:   Admin Tool :   oauth2sciebo  Umfasst sowohl OAuth 2.0, als auch einen WebDAV Client.  Steuert den Protokollablauf von OAuth 2.0 und verwaltet alle dazu n\u00f6tigen Informationen.  globale Speicherung des Secrets und der ClientID    Stellt das Verbindungsst\u00fcck von moodle zu Sciebo bzw. ownCloud zur Verf\u00fcgung    Repository :   sciebo  Bewerkstelligt die Datenbeschaffung aus Sciebo bzw. ownCloud nach Moodle.  Erm\u00f6glicht den Upload von Dateien aus einer pers\u00f6nlichen Sciebo Instanz.  Erm\u00f6glicht die Verlinkung von Dateien aus Sciebo in Moodle.    Activity Module :   collaborative folders  Erm\u00f6glicht die Erstellung und Freigabe von Ordern in Sciebo f\u00fcr bestimmte Gruppen in Moodle.", 
            "title": "Funktions\u00fcbersicht"
        }, 
        {
            "location": "/moodle/technische-umsetzung/softwarearchitektur/#abhangigkeiten", 
            "text": "Die aus der Aufteilung der Funktionen in verschiedene Plugins resultierenden Abh\u00e4ngigkeiten werden in folgender Abbildung\ndargestellt:   Zu beachten ist, dass eine m\u00f6glichst hohe Flexibilit\u00e4t und Modularit\u00e4t bei dem Entwurf der Softwarearchitektur erzielt\nwerden sollte. Das f\u00fchrt zwar mit sich, dass funktionale Plugins (also das  repository  und das  activity  Plugin) nicht\neigenst\u00e4ndig ohne das  admin tool  existieren k\u00f6nnen, allerdings wird weiteren, in Zukunft entwickelten Plugins ebenfalls\nZugriff auf die OAuth 2.0 Schnittstelle in  Sciebo  bzw.  ownCloud  erm\u00f6glicht,\nwodurch sich das Projektergebnis zu einer guten Wiederverwendbarkeit qualifiziert.", 
            "title": "Abh\u00e4ngigkeiten"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/", 
            "text": "Admin Tool: \noauth2sciebo\n\n\nZweck\n\n\nWie bereits im Kapitel \nSoftware Architektur\n angeschnitten, ist der Hauptzweck dieses Plugins\ndie Schnittstelle zu Sciebo bzw. ownCloud bereitzustellen. Zu diesem Zweck wird die im Projekt implementierte ownCloud \nApp \nOAuth2\n mit Hilfe eines OAuth 2.0 Clients \u00fcber die WebDAV Schnittstelle angesprochen.\nGleichzeitig kann dieses Plugin auch f\u00fcr \u00e4hnliche externe Datenquellen verwendet werden, sofern diese \u00fcber die n\u00f6tigen\nOAuth 2.0 und WebDAV Schnittstellen verf\u00fcgen.\n\n\nIm Wesentlichen implementiert dieses Plugin das folgende \nIntegrationsszenario\n:\n\n\n\n\nAls \nNutzer\n m\u00f6chte ich OAuth2 benutzen k\u00f6nnen, um mich im Learnweb als ownCloud Nutzer anzumelden.\n\n\n\n\nJedoch betrifft es auch alle anderen Szenarien indirekt, da diese erst durch die Authentifizierung mittels OAuth 2.0 \nerm\u00f6glicht werden k\u00f6nnen.\n\n\nVorgegebene Schnittstelle\n\n\nF\u00fcr Admin Tools ist in moodle lediglich eine schwach definierte Schnittstelle gegeben. Wie in jedem anderen moodle Plugin \nauch, m\u00fcssen zun\u00e4chst einige Standartdateien implementiert werden: \n\n\n\n\nversion.php\n:\n Beschreibt die Versionsnummer des Plugins, die ben\u00f6tigte moodle Version und Abh\u00e4ngigkeiten des Plugins.\n\n\naccess.php\n:\n Legt die Berechtigungen f\u00fcr definierte Aktionen innerhalb des Plugins anhand von Nutzerrollen fest.\n\n\ntool_oauth2sciebo.php\n:\n Beinhaltet Sprachstrings f\u00fcr unterschiedliche Regionen und Sprachen, sodass definierte Strings,\nabh\u00e4ngig von der jeweiligen Sprache, dynamisch angezeigt werden k\u00f6nnen.\n\n\n\n\nZus\u00e4tzlich zu den allgemeinen Plugindateien, sollte unser Admin Tool auch mindestens noch eine Datei namens \nsettings.php\n\nbeinhalten. Diese umfasst alle Einstellungen, die f\u00fcr das Admin Tool geltend dem Administrator der moodle Instanz zur \nVerf\u00fcgung gestellt werden sollen. Nach der Eingabe, wird diese Konfiguration moodle-intern in dem sogenannten \nAdmin Tree\n\ngespeichert. Aus dieser Baumstruktur k\u00f6nnen anschlie\u00dfend ben\u00f6tigte Einstellungen beschafft werden.\n\n\nInsgesamt ergibt sich folgende Struktur von Ordnern und Dateien, die mindestens f\u00fcr die Implementierung des von uns gebrauchten\nAdmin Tools notwendig ist:\n\n\n\n  \nTODO:\n Grafik f\u00fcr Ordnerstruktur einf\u00fcgen.\n\n\n\n\nImplementierung\n\n\nEingabemaske\n\n\nUm die OAuth 2.0 und WebDAV Clients erfolgreich zum Zugriff auf eine entsprechende Sciebo bzw. ownCloud Instanz zu bef\u00e4higen,\nm\u00fcssen diese zun\u00e4chst mit Hilfe ben\u00f6tigter Eingabedaten konfiguriert werden. Diese sollen zentral im Admin Tool eingegeben und\ngespeichert werden k\u00f6nnen, um sie anschlie\u00dfend von anderen Plugins aus nutzen zu k\u00f6nnen. Zu diesem Zweck werden globale Optionen\nwerden, welche instanz\u00fcbergreifend gelten.\n\n\nBen\u00f6tigte Eingaben\n\n\nUm den OAuth 2.0 Protokollablauf zu erm\u00f6glichen, m\u00fcssen folgende Daten im Vorfeld erfasst werden:\n\n\n\n\nClient ID\n:\n wird in ownCloud generiert und dient der Identifizierung eines regstrierten Clients.\n\n\nSecret\n:\n wird ebenfalls in ownCloud generiert und zur Authentifizierung verwendet.\n\n\n\n\nBeide Datens\u00e4tze sind Strings bestehend aus Buchstaben und Zahlen. Daher eignet sich f\u00fcr beide ein Textfeld, welches ausschlie\u00dflich \nalphanumerische Werte erwartet zur Eingabe.\n\n\nZur Nutzung des WebDAV Clients werden dar\u00fcber hinaus folgende Daten ben\u00f6tigt:\n\n\n\n\nServer Addresse\n:\n Url \u00fcber die der ownCloud Server erreicht werden kann.\n\n\nServer Pfad\n:\n der angehangene Pfad, \u00fcber den die WebDAV Schnittstelle erreicht werden kann.\n\n\nPort\n:\n Port des WebDAV-Servers.\n\n\nSSL-Verschl\u00fcsselung\n:\n Wahl zwischen HTTP und HTTPS. \n\n\n\n\nW\u00e4hrend die Wahl des Protokolls mittels einer Auswahl aus vorhandenen Optionen abgeboten werden kann, m\u00fcssen die restlichen Werte\nin einem Textfeld erfragt werden. Auch in diesem Fall werden die Variablen nach den zu erwartenden Werten ges\u00e4ubert. Dar\u00fcber hinaus\nwerden alle Eingaben, bis auf dem Port, als notwendig angesehen.\n\n\nExternal Page\n\n\nEine somit notwendige Eingabemaske kann im Rahmen der [\nsettings.php\n] definiert werden. Da zum Zweck der individuellen Validierung und S\u00e4uberung\nder ben\u00f6tigten Parameter die in der \nadminlib.php\n definierten \nKlassen nicht ausreichen, wurde eine \nexterne Seite\n speziell zur Darstellung\ndes notwendigen Formulars erstellt. Die externe Seite, welche \u00fcber die \nindex.php\n Datei aufgerufen wird, sorgt daf\u00fcr, dass\ndie Einstellungen aus dem Formular global in den \nadmin settings\n gespeichert werden. Von dort aus k\u00f6nnen sie, sobald n\u00f6tig ausgelesen\nwerden. Um die externe Seite nun in die Navigation in der Seitenadministration einzubinden, muss diese in der \nsettings.php\n in den \nAdmin Tree eingebunden werden: \n\n\n?php\ndefined('MOODLE_INTERNAL') || die('moodle_internal not defined');\n\n$ADMIN-\nadd('authsettings', new admin_externalpage('tool_oauth2sciebo/auth',\n        'Sciebo OAuth 2.0 Configuration',\n        \n$CFG-\nwwwroot/$CFG-\nadmin/tool/oauth2sciebo/index.php\n));\n\n\n\n\nDas \nadmin_externalpage\n Objekt beschreibt eine externe Seite, die im Admin Tree eingeordnet werden soll. Dazu wird die Seite mit einem\neinzigartigen Namen versehen, einem Anzeigenamen und dem Pfad, \u00fcber den die Seite erreicht werden soll. Neben der externen Seite an\nsich, wird bei der Methode \nadd\n zus\u00e4tzlich \u00fcbergeben, an welcher Stelle die Verkn\u00fcpfung erstellt werden soll. In diesem Fall sind es die\nAuthentifizierungseinstellungen (\nauthsettings\n).\n\n\nNeben der Darstellung des Formulars, verwaltet die externe Seite auch die Speicherung der eigegebenen Daten. Diese werden, \u00e4hnlich wie die\nexterne Seite zuvor, global in den Admin Settings mit Hilfe der Methode \nset_config()\n gespeichert. Sobald also das Formular erfolgreich validiert\nworden ist, werden die Eingabedaten durch einen Aufruf dieser Methode mit der genauen Bezeichnung der Option und dem Wert, den sie im Fomular\nerhalten hat, global abgelegt. Dar\u00fcber hinaus wird \u00fcber die externe Seite auch die R\u00fccksetzung der Daten und der Abbruch der Bearbeitung geregelt.\nZuletzt ist die Seite auch daf\u00fcr zust\u00e4ndig das Formular mit zuvor gesetzten Werten zu f\u00fcllen, die aus den globalen Einstellungen wiederbeschafft werden.\n\n\nFormular\n\n\nUm ein geeignetes Formular zu definieren musste die moodle-interne Klasse \nmoodleform\n erweitert und innerhalb der Funktion \ndefinition()\n\nalle ben\u00f6tigten Eingabefelder definiert werden. Folgende Funktionen wurden dabei verwedet um die Elemente so genau wie m\u00f6glich zu umrei\u00dfen:\n\n\n\n\n\n\n\n\nFunktion\n\n\nBeschreibung\n\n\nBeispiel\n\n\n\n\n\n\n\n\n\n\naddElement\n\n\nF\u00fcgt ein Element zum Formular hinzu\n\n\nTextfeld, Dropdown Men\u00fc, Checkbox\n\n\n\n\n\n\naddRule\n\n\nVersieht ein Element mit einer Regel zur Validierung\n\n\nerforderlich f\u00fcr die Abgabe, nur alphanumerisch\n\n\n\n\n\n\nsetDefault\n\n\nSetzt den Standartwert f\u00fcr ein Element\n\n\n-\n\n\n\n\n\n\nsetType\n\n\nLegt den Parametertypen der Eingabe fest\n\n\nInteger, String, Pfad, roh\n\n\n\n\n\n\n\n\nIm Folgenden wird anhand von zwei Beispielen die Anwendung dieser Funktionen dargestellt:\n\n\n?php\nclass tool_oauth2sciebo_client_form extends moodleform {\n\n    public function definition() {\n        global $CFG;\n\n        $mform = $this-\n_form;\n        // Client ID.\n        $mform-\naddElement('text', 'clientid', get_string('clientid', 'tool_oauth2sciebo'), \n            array('size' =\n '64'));\n        $mform-\naddRule('clientid', get_string('required'), 'required', null, 'client');\n        $mform-\naddRule('clientid', get_string('err_alphanumeric'), 'alphanumeric', null, 'client');\n        $mform-\nsetDefault('clientid', $this-\n_customdata['clientid']);\n        $mform-\nsetType('clientid', PARAM_ALPHANUM);\n\n\n\n\nZun\u00e4chst wird das Client ID Eingabefeld definiert. Hierzu wird zum Formular ein Textfeld hinzugef\u00fcgt, welches den eindeutigen Namen\n\nclientid\n tr\u00e4gt und 64 Felder breit ist. Der Anzeigename des Elements wird \u00fcber ein die Sprachstring-Methode \nget_string\n beschafft.\nDaraufhin wird das Feld als f\u00fcr die Abgabe ben\u00f6tigt markiert und auf alphanumerische Werte beschr\u00e4nkt. Zuletzt wird der Standartwert\nf\u00fcr das Textfeld gesetzt, welcher zuvor durch die externe Seite bei Aufruf \u00fcbergeben wird und zur S\u00e4uberung der Eingabe der Typ des\nElements auf alphanumerisch gestellt.\n\n\n        // Type of server.\n        $mform-\naddElement('select', 'type', get_string('type', 'tool_oauth2sciebo'), \n            array('http' =\n 'HTTP', 'https' =\n 'HTTPS'));\n        $mform-\naddRule('type', get_string('required'), 'required', null, 'client');\n        $mform-\nsetDefault('type', $this-\n_customdata['type']);\n    }\n}\n\n\n\n\nIm zweiten Beispiel wird ein \nselect\n Element zum Formular hinzugef\u00fcgt. Der Unterschied zum Textfeld ist, dass bei einem Dropdown\nMen\u00fc auch verf\u00fcgbare Optionen angegeben werden m\u00fcssen. Au\u00dferdem wird auch dieses Element als ben\u00f6tigt markiert und sein Standartwert\nAus den Aufrufparametern beschafft und gesetzt.\n\n\nAm Ende des Formulares werden zu guter Letzt noch Buttons zur Abgabe des Formulars definiert. Damit ist die Eingabemaske vollst\u00e4ndig. \n\n\nOAuth 2.0 Client\n\n\nDen funktionalen Kern des Plugins stellt der OAuth 2.0 Client dar. Dieser befindet sich in Form der Klasse \nsciebo\n in der\nDatei \nsciebo.php\n in dem \nclasses\n Ordner des Plugins. Diese Klasse steuert sowohl den moodle-seitigen Protokollablauf\nvon OAuth 2.0, als auch den Verbindungsaufbau zu ownCloud mittels WebDAV. Dadurch, dass \nsciebo\n von der im moodle Core\nenthaltenen Klasse \noauth2_client\n erbt, ist ein Gro\u00dfteil des Protokollablaufs bereits abgedeckt.\nDer Konstruktor der Klasse \noauth2_client\n muss mit den \nClient ID\n und \nSecret\n Daten aufgerufen werden. \nDiese werden aus den zuvor angewandten Einstellungen beschafft:\n\n\n?php\n\nnamespace tool_oauth2sciebo;\n\ndefined('MOODLE_INTERNAL') || die();\n\nrequire_once($CFG-\nlibdir . '/oauthlib.php');\n\nuse tool_oauth2sciebo\\sciebo_client;\n\nclass sciebo extends \\oauth2_client {\n\n    /**\n     * Create the DropBox API Client.\n     *\n     * @param   string      $key        The API key\n     * @param   string      $secret     The API secret\n     * @param   string      $callback   The callback URL\n     */\n    public function __construct($callback) {\n        parent::__construct(get_config('tool_oauth2sciebo', 'clientid'),\n            get_config('tool_oauth2sciebo', 'secret'), $callback, '');\n\n\n\n\nZu diesem Zweck wird die Methode \nget_config\n verwendet. Sie gibt den f\u00fcr ein Plugin und einen zuvor einzigartig definierten\nNamen aus dem Admin Tree heraus die dazu gespeicherte Einstellung.\nDar\u00fcber hinaus muss eine \ncallback URL\n angef\u00fcgt werden, die den Pfad angibt, an den nach der Authentifizierung und Authorisierung\nweitergeleitet werden soll. Dieser wird allerdings wird extern in den Plugins erzeugt, die die \nsciebo\n Klasse benutzen.\n\n\nZu beachten ist, dass f\u00fcr die Klasse \nsciebo\n ein namespace definiert wird, womit diese effizient in externen Plugins verwendet werden\nkann, die einen OAuth 2.0 Client ben\u00f6tigen.\n\n\nWeiterhin m\u00fcssen die Methoden \nauth_url\n und \ntoken_url\n der Elternklasse zwingend implementiert werden, um bei der Authentifizierung\nauf die richtigen Pfade zu verweisen:\n\n\n    /**\n    * Returns the auth url for OAuth 2.0 request\n    * @return string the auth url\n    */\n    protected function auth_url() {\n    // Dynamically generated from the admin tool settings.\n        $path = str_replace('remote.php/webdav/', '', get_config('tool_oauth2sciebo', 'path'));\n        return get_config('tool_oauth2sciebo', 'type') . '://' . get_config('tool_oauth2sciebo', 'server') . '/' . $path\n            . 'index.php/apps/oauth2/authorize';\n    }\n\n    /**\n    * Returns the token url for OAuth 2.0 request\n    * @return string the token url\n    */\n    protected function token_url() {\n        $path = str_replace('remote.php/webdav/', '', get_config('tool_oauth2sciebo', 'path'));\n        return get_config('tool_oauth2sciebo', 'type') . '://' . get_config('tool_oauth2sciebo', 'server')  . '/' . $path\n            . 'index.php/apps/oauth2/api/v1/token';\n    }\n\n\n\n\nHierf\u00fcr werden die beiden Pfade aus der Serveraddresse und dem Serverpfad berechnet, da der Endpunkt f\u00fcr die oauth2 App in\nownCloud gleich bleibt.\n\n\n\u00c4nderungen an Core Bibliotheken\n\n\nDu zur Umsetzung des Verfahrens Die vorgegebenen Schnittstellen nicht ausreichten, mussten in Anpassungen in moodles Core \nBibliotheken vorgenommen werden. Im Folgenden werden diese \u00c4nderungen beschrieben.\n\n\nAnpassung der \npost\n Methode\n\n\nDie moodle-interne Klasse \noauth2client\n erbt von einer weiteren Klasse aus dem moodle Core mit dem Namen \ncurl\n, welche mittels\n\nCurl\n HTTP Requests erstellen und verschicken kann. Dadurch ist die Klasse f\u00e4hig eigenst\u00e4ndig einen Access Token mit einem \nAuthorization Code mittels der HTTP POST Methode \u00fcber die \ntoken\n Schnittstelle in ownCloud zu beschaffen. Allerdings\nbietet die daf\u00fcr zust\u00e4ndige Methode \npost\n nicht die M\u00f6glichkeit einen Basic Authorization Header zur Anfrage hinzuzuf\u00fcgen,\nwelcher Client ID und Secret zur Autorisierung in der \noauth2\n ownCloud App mit verschickt. Daher musste die \npost\n Methode\nin der \nsciebo\n Klasse so \u00fcberschrieben werden, dass der Header vor dem Aufruf der geerbten Methode gesetzt wird.\nIn dem zugeh\u00f6rigen Skipt wurde folende Methode erg\u00e4nzt:\n\n\npublic function post($url, $params = '', $options = array()) {\n\n    $this-\nsetHeader(array(\n        'Authorization: Basic ' . base64_encode($this-\nget_clientid() . ':' . $this-\nget_clientsecret())\n        ));\n\n    return parent::post($url, $params, $options);\n}\n\n\n\n\nAnpassung des WebDAV Clients\n\n\nWeiterleitungen\n\n\nTests und Continuous Integration", 
            "title": "Admin Tool"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#admin-tool-oauth2sciebo", 
            "text": "", 
            "title": "Admin Tool: oauth2sciebo"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#zweck", 
            "text": "Wie bereits im Kapitel  Software Architektur  angeschnitten, ist der Hauptzweck dieses Plugins\ndie Schnittstelle zu Sciebo bzw. ownCloud bereitzustellen. Zu diesem Zweck wird die im Projekt implementierte ownCloud \nApp  OAuth2  mit Hilfe eines OAuth 2.0 Clients \u00fcber die WebDAV Schnittstelle angesprochen.\nGleichzeitig kann dieses Plugin auch f\u00fcr \u00e4hnliche externe Datenquellen verwendet werden, sofern diese \u00fcber die n\u00f6tigen\nOAuth 2.0 und WebDAV Schnittstellen verf\u00fcgen.  Im Wesentlichen implementiert dieses Plugin das folgende  Integrationsszenario :   Als  Nutzer  m\u00f6chte ich OAuth2 benutzen k\u00f6nnen, um mich im Learnweb als ownCloud Nutzer anzumelden.   Jedoch betrifft es auch alle anderen Szenarien indirekt, da diese erst durch die Authentifizierung mittels OAuth 2.0 \nerm\u00f6glicht werden k\u00f6nnen.", 
            "title": "Zweck"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#vorgegebene-schnittstelle", 
            "text": "F\u00fcr Admin Tools ist in moodle lediglich eine schwach definierte Schnittstelle gegeben. Wie in jedem anderen moodle Plugin \nauch, m\u00fcssen zun\u00e4chst einige Standartdateien implementiert werden:    version.php :  Beschreibt die Versionsnummer des Plugins, die ben\u00f6tigte moodle Version und Abh\u00e4ngigkeiten des Plugins.  access.php :  Legt die Berechtigungen f\u00fcr definierte Aktionen innerhalb des Plugins anhand von Nutzerrollen fest.  tool_oauth2sciebo.php :  Beinhaltet Sprachstrings f\u00fcr unterschiedliche Regionen und Sprachen, sodass definierte Strings,\nabh\u00e4ngig von der jeweiligen Sprache, dynamisch angezeigt werden k\u00f6nnen.   Zus\u00e4tzlich zu den allgemeinen Plugindateien, sollte unser Admin Tool auch mindestens noch eine Datei namens  settings.php \nbeinhalten. Diese umfasst alle Einstellungen, die f\u00fcr das Admin Tool geltend dem Administrator der moodle Instanz zur \nVerf\u00fcgung gestellt werden sollen. Nach der Eingabe, wird diese Konfiguration moodle-intern in dem sogenannten  Admin Tree \ngespeichert. Aus dieser Baumstruktur k\u00f6nnen anschlie\u00dfend ben\u00f6tigte Einstellungen beschafft werden.  Insgesamt ergibt sich folgende Struktur von Ordnern und Dateien, die mindestens f\u00fcr die Implementierung des von uns gebrauchten\nAdmin Tools notwendig ist:  \n   TODO:  Grafik f\u00fcr Ordnerstruktur einf\u00fcgen.", 
            "title": "Vorgegebene Schnittstelle"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#implementierung", 
            "text": "", 
            "title": "Implementierung"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#eingabemaske", 
            "text": "Um die OAuth 2.0 und WebDAV Clients erfolgreich zum Zugriff auf eine entsprechende Sciebo bzw. ownCloud Instanz zu bef\u00e4higen,\nm\u00fcssen diese zun\u00e4chst mit Hilfe ben\u00f6tigter Eingabedaten konfiguriert werden. Diese sollen zentral im Admin Tool eingegeben und\ngespeichert werden k\u00f6nnen, um sie anschlie\u00dfend von anderen Plugins aus nutzen zu k\u00f6nnen. Zu diesem Zweck werden globale Optionen\nwerden, welche instanz\u00fcbergreifend gelten.", 
            "title": "Eingabemaske"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#benotigte-eingaben", 
            "text": "Um den OAuth 2.0 Protokollablauf zu erm\u00f6glichen, m\u00fcssen folgende Daten im Vorfeld erfasst werden:   Client ID :  wird in ownCloud generiert und dient der Identifizierung eines regstrierten Clients.  Secret :  wird ebenfalls in ownCloud generiert und zur Authentifizierung verwendet.   Beide Datens\u00e4tze sind Strings bestehend aus Buchstaben und Zahlen. Daher eignet sich f\u00fcr beide ein Textfeld, welches ausschlie\u00dflich \nalphanumerische Werte erwartet zur Eingabe.  Zur Nutzung des WebDAV Clients werden dar\u00fcber hinaus folgende Daten ben\u00f6tigt:   Server Addresse :  Url \u00fcber die der ownCloud Server erreicht werden kann.  Server Pfad :  der angehangene Pfad, \u00fcber den die WebDAV Schnittstelle erreicht werden kann.  Port :  Port des WebDAV-Servers.  SSL-Verschl\u00fcsselung :  Wahl zwischen HTTP und HTTPS.    W\u00e4hrend die Wahl des Protokolls mittels einer Auswahl aus vorhandenen Optionen abgeboten werden kann, m\u00fcssen die restlichen Werte\nin einem Textfeld erfragt werden. Auch in diesem Fall werden die Variablen nach den zu erwartenden Werten ges\u00e4ubert. Dar\u00fcber hinaus\nwerden alle Eingaben, bis auf dem Port, als notwendig angesehen.", 
            "title": "Ben\u00f6tigte Eingaben"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#external-page", 
            "text": "Eine somit notwendige Eingabemaske kann im Rahmen der [ settings.php ] definiert werden. Da zum Zweck der individuellen Validierung und S\u00e4uberung\nder ben\u00f6tigten Parameter die in der  adminlib.php  definierten \nKlassen nicht ausreichen, wurde eine  externe Seite  speziell zur Darstellung\ndes notwendigen Formulars erstellt. Die externe Seite, welche \u00fcber die  index.php  Datei aufgerufen wird, sorgt daf\u00fcr, dass\ndie Einstellungen aus dem Formular global in den  admin settings  gespeichert werden. Von dort aus k\u00f6nnen sie, sobald n\u00f6tig ausgelesen\nwerden. Um die externe Seite nun in die Navigation in der Seitenadministration einzubinden, muss diese in der  settings.php  in den \nAdmin Tree eingebunden werden:   ?php\ndefined('MOODLE_INTERNAL') || die('moodle_internal not defined');\n\n$ADMIN- add('authsettings', new admin_externalpage('tool_oauth2sciebo/auth',\n        'Sciebo OAuth 2.0 Configuration',\n         $CFG- wwwroot/$CFG- admin/tool/oauth2sciebo/index.php ));  Das  admin_externalpage  Objekt beschreibt eine externe Seite, die im Admin Tree eingeordnet werden soll. Dazu wird die Seite mit einem\neinzigartigen Namen versehen, einem Anzeigenamen und dem Pfad, \u00fcber den die Seite erreicht werden soll. Neben der externen Seite an\nsich, wird bei der Methode  add  zus\u00e4tzlich \u00fcbergeben, an welcher Stelle die Verkn\u00fcpfung erstellt werden soll. In diesem Fall sind es die\nAuthentifizierungseinstellungen ( authsettings ).  Neben der Darstellung des Formulars, verwaltet die externe Seite auch die Speicherung der eigegebenen Daten. Diese werden, \u00e4hnlich wie die\nexterne Seite zuvor, global in den Admin Settings mit Hilfe der Methode  set_config()  gespeichert. Sobald also das Formular erfolgreich validiert\nworden ist, werden die Eingabedaten durch einen Aufruf dieser Methode mit der genauen Bezeichnung der Option und dem Wert, den sie im Fomular\nerhalten hat, global abgelegt. Dar\u00fcber hinaus wird \u00fcber die externe Seite auch die R\u00fccksetzung der Daten und der Abbruch der Bearbeitung geregelt.\nZuletzt ist die Seite auch daf\u00fcr zust\u00e4ndig das Formular mit zuvor gesetzten Werten zu f\u00fcllen, die aus den globalen Einstellungen wiederbeschafft werden.", 
            "title": "External Page"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#formular", 
            "text": "Um ein geeignetes Formular zu definieren musste die moodle-interne Klasse  moodleform  erweitert und innerhalb der Funktion  definition() \nalle ben\u00f6tigten Eingabefelder definiert werden. Folgende Funktionen wurden dabei verwedet um die Elemente so genau wie m\u00f6glich zu umrei\u00dfen:     Funktion  Beschreibung  Beispiel      addElement  F\u00fcgt ein Element zum Formular hinzu  Textfeld, Dropdown Men\u00fc, Checkbox    addRule  Versieht ein Element mit einer Regel zur Validierung  erforderlich f\u00fcr die Abgabe, nur alphanumerisch    setDefault  Setzt den Standartwert f\u00fcr ein Element  -    setType  Legt den Parametertypen der Eingabe fest  Integer, String, Pfad, roh     Im Folgenden wird anhand von zwei Beispielen die Anwendung dieser Funktionen dargestellt:  ?php\nclass tool_oauth2sciebo_client_form extends moodleform {\n\n    public function definition() {\n        global $CFG;\n\n        $mform = $this- _form;\n        // Client ID.\n        $mform- addElement('text', 'clientid', get_string('clientid', 'tool_oauth2sciebo'), \n            array('size' =  '64'));\n        $mform- addRule('clientid', get_string('required'), 'required', null, 'client');\n        $mform- addRule('clientid', get_string('err_alphanumeric'), 'alphanumeric', null, 'client');\n        $mform- setDefault('clientid', $this- _customdata['clientid']);\n        $mform- setType('clientid', PARAM_ALPHANUM);  Zun\u00e4chst wird das Client ID Eingabefeld definiert. Hierzu wird zum Formular ein Textfeld hinzugef\u00fcgt, welches den eindeutigen Namen clientid  tr\u00e4gt und 64 Felder breit ist. Der Anzeigename des Elements wird \u00fcber ein die Sprachstring-Methode  get_string  beschafft.\nDaraufhin wird das Feld als f\u00fcr die Abgabe ben\u00f6tigt markiert und auf alphanumerische Werte beschr\u00e4nkt. Zuletzt wird der Standartwert\nf\u00fcr das Textfeld gesetzt, welcher zuvor durch die externe Seite bei Aufruf \u00fcbergeben wird und zur S\u00e4uberung der Eingabe der Typ des\nElements auf alphanumerisch gestellt.          // Type of server.\n        $mform- addElement('select', 'type', get_string('type', 'tool_oauth2sciebo'), \n            array('http' =  'HTTP', 'https' =  'HTTPS'));\n        $mform- addRule('type', get_string('required'), 'required', null, 'client');\n        $mform- setDefault('type', $this- _customdata['type']);\n    }\n}  Im zweiten Beispiel wird ein  select  Element zum Formular hinzugef\u00fcgt. Der Unterschied zum Textfeld ist, dass bei einem Dropdown\nMen\u00fc auch verf\u00fcgbare Optionen angegeben werden m\u00fcssen. Au\u00dferdem wird auch dieses Element als ben\u00f6tigt markiert und sein Standartwert\nAus den Aufrufparametern beschafft und gesetzt.  Am Ende des Formulares werden zu guter Letzt noch Buttons zur Abgabe des Formulars definiert. Damit ist die Eingabemaske vollst\u00e4ndig.", 
            "title": "Formular"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#oauth-20-client", 
            "text": "Den funktionalen Kern des Plugins stellt der OAuth 2.0 Client dar. Dieser befindet sich in Form der Klasse  sciebo  in der\nDatei  sciebo.php  in dem  classes  Ordner des Plugins. Diese Klasse steuert sowohl den moodle-seitigen Protokollablauf\nvon OAuth 2.0, als auch den Verbindungsaufbau zu ownCloud mittels WebDAV. Dadurch, dass  sciebo  von der im moodle Core\nenthaltenen Klasse  oauth2_client  erbt, ist ein Gro\u00dfteil des Protokollablaufs bereits abgedeckt.\nDer Konstruktor der Klasse  oauth2_client  muss mit den  Client ID  und  Secret  Daten aufgerufen werden. \nDiese werden aus den zuvor angewandten Einstellungen beschafft:  ?php\n\nnamespace tool_oauth2sciebo;\n\ndefined('MOODLE_INTERNAL') || die();\n\nrequire_once($CFG- libdir . '/oauthlib.php');\n\nuse tool_oauth2sciebo\\sciebo_client;\n\nclass sciebo extends \\oauth2_client {\n\n    /**\n     * Create the DropBox API Client.\n     *\n     * @param   string      $key        The API key\n     * @param   string      $secret     The API secret\n     * @param   string      $callback   The callback URL\n     */\n    public function __construct($callback) {\n        parent::__construct(get_config('tool_oauth2sciebo', 'clientid'),\n            get_config('tool_oauth2sciebo', 'secret'), $callback, '');  Zu diesem Zweck wird die Methode  get_config  verwendet. Sie gibt den f\u00fcr ein Plugin und einen zuvor einzigartig definierten\nNamen aus dem Admin Tree heraus die dazu gespeicherte Einstellung.\nDar\u00fcber hinaus muss eine  callback URL  angef\u00fcgt werden, die den Pfad angibt, an den nach der Authentifizierung und Authorisierung\nweitergeleitet werden soll. Dieser wird allerdings wird extern in den Plugins erzeugt, die die  sciebo  Klasse benutzen.  Zu beachten ist, dass f\u00fcr die Klasse  sciebo  ein namespace definiert wird, womit diese effizient in externen Plugins verwendet werden\nkann, die einen OAuth 2.0 Client ben\u00f6tigen.  Weiterhin m\u00fcssen die Methoden  auth_url  und  token_url  der Elternklasse zwingend implementiert werden, um bei der Authentifizierung\nauf die richtigen Pfade zu verweisen:      /**\n    * Returns the auth url for OAuth 2.0 request\n    * @return string the auth url\n    */\n    protected function auth_url() {\n    // Dynamically generated from the admin tool settings.\n        $path = str_replace('remote.php/webdav/', '', get_config('tool_oauth2sciebo', 'path'));\n        return get_config('tool_oauth2sciebo', 'type') . '://' . get_config('tool_oauth2sciebo', 'server') . '/' . $path\n            . 'index.php/apps/oauth2/authorize';\n    }\n\n    /**\n    * Returns the token url for OAuth 2.0 request\n    * @return string the token url\n    */\n    protected function token_url() {\n        $path = str_replace('remote.php/webdav/', '', get_config('tool_oauth2sciebo', 'path'));\n        return get_config('tool_oauth2sciebo', 'type') . '://' . get_config('tool_oauth2sciebo', 'server')  . '/' . $path\n            . 'index.php/apps/oauth2/api/v1/token';\n    }  Hierf\u00fcr werden die beiden Pfade aus der Serveraddresse und dem Serverpfad berechnet, da der Endpunkt f\u00fcr die oauth2 App in\nownCloud gleich bleibt.", 
            "title": "OAuth 2.0 Client"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#anderungen-an-core-bibliotheken", 
            "text": "Du zur Umsetzung des Verfahrens Die vorgegebenen Schnittstellen nicht ausreichten, mussten in Anpassungen in moodles Core \nBibliotheken vorgenommen werden. Im Folgenden werden diese \u00c4nderungen beschrieben.", 
            "title": "\u00c4nderungen an Core Bibliotheken"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#anpassung-der-post-methode", 
            "text": "Die moodle-interne Klasse  oauth2client  erbt von einer weiteren Klasse aus dem moodle Core mit dem Namen  curl , welche mittels Curl  HTTP Requests erstellen und verschicken kann. Dadurch ist die Klasse f\u00e4hig eigenst\u00e4ndig einen Access Token mit einem \nAuthorization Code mittels der HTTP POST Methode \u00fcber die  token  Schnittstelle in ownCloud zu beschaffen. Allerdings\nbietet die daf\u00fcr zust\u00e4ndige Methode  post  nicht die M\u00f6glichkeit einen Basic Authorization Header zur Anfrage hinzuzuf\u00fcgen,\nwelcher Client ID und Secret zur Autorisierung in der  oauth2  ownCloud App mit verschickt. Daher musste die  post  Methode\nin der  sciebo  Klasse so \u00fcberschrieben werden, dass der Header vor dem Aufruf der geerbten Methode gesetzt wird.\nIn dem zugeh\u00f6rigen Skipt wurde folende Methode erg\u00e4nzt:  public function post($url, $params = '', $options = array()) {\n\n    $this- setHeader(array(\n        'Authorization: Basic ' . base64_encode($this- get_clientid() . ':' . $this- get_clientsecret())\n        ));\n\n    return parent::post($url, $params, $options);\n}", 
            "title": "Anpassung der post Methode"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#anpassung-des-webdav-clients", 
            "text": "", 
            "title": "Anpassung des WebDAV Clients"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#weiterleitungen", 
            "text": "", 
            "title": "Weiterleitungen"
        }, 
        {
            "location": "/moodle/technische-umsetzung/admin-tool/#tests-und-continuous-integration", 
            "text": "", 
            "title": "Tests und Continuous Integration"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/", 
            "text": "Repository: \nsciebo\n\n\nZweck\n\n\nDer Plugin Typ \nRepository\n wird in Moodle unter anderem verwendet um Nutzer die M\u00f6glichkeit zu schaffen Zugang zu\nDateien aus externen Quellen zu bekommen. Das Repository Plugin Sciebo kann somit die User Stories \nZwei\n und \nDrei\n realisieren. Sobald der Admin das Plugin unter \nSite administration\nPlugins \nRepositories\nManage repositories\n aktiviert hat, sieht der Nutzer im File Picker folgende Optionen:\n\n\n(Mehr Informationen zum File Picker finden sie in der \nMoodle Dokumentation\n)\n\n\n\n  \nTODO:\n BILD nach richtiger Benennung.\n\n\n\n\nWenn der Nutzer auf den anmelde Button klickt, wird er zu einem Pop-up Window weitergeleitet, dass ihn auffordert sich in der zugeh\u00f6rigen ownCloud Istanz zu authentifizieren. Sobald der Nutzer sich hier einmalig authentifiziert hat, werden ihm im File Picker seine Dateien angezeigt. Das Plugin bietet dem Benutzer zus\u00e4tzliche Vorteile\ndadurch, dass die Authentifizierung nur einmalig erfolgt. Durch den OAuth2 Protokollablauf werden danach Refresh Tokens angefordert ohne dass der Nutzer dies im Front-End zu sehen bekommt. Somit kann der Nutzer angemeldet bleiben w\u00e4hrend verschiedenen Sessions.\n\n\nVorgegebene Schnittstelle\n\n\nWie auch im \nAdmin Tool\n m\u00fcssen zun\u00e4chst einige Standartschnittstellen implementiert werden:\n\n\n\n\nversion.php\n:\n Beschreibt die Versionsnummer des Plugins, die ben\u00f6tigte moodle Version und Abh\u00e4ngigkeiten des Plugins.\n\n\ndb/access.php\n:\n Legt die Berechtigungen f\u00fcr definierte Aktionen innerhalb des Plugins anhand von Nutzerrollen fest.\n\n\nlang/en/repository__sciebo.php\n:\n Beinhaltet Sprachstrings f\u00fcr unterschiedliche Regionen und Sprachen, sodass definierte Strings,\nabh\u00e4ngig von der jeweiligen Sprache, dynamisch angezeigt werden k\u00f6nnen. Als Standard wird eine englische Sprachdatei erwartet.\n\n\n\n\nF\u00fcr Repository-Plugins m\u00fcssen au\u00dferdem folgende Dateien implementiert werden:\n\n\n\n\npix/icon.png\n:\n Hier wird ein 16x16 icon platziert, welches f\u00fcr das Plugin genutzt wird.\n\n\nlib.php\n:\n Hier wird eine Klasse \nrepository_sciebo extends repository\n deklariert, die als Hauptaufgabe die Integration in den File Picker verwaltet.\n\n\n\n\nImplementierung\n\n\nImplementierung der \nlib.php\n\n\nIn der lib.php wird eine Klasse definiert die von der abstrakten Klasse \nrepository\n erbt. Im Folgenden wird darauf eingegangen wie die vorgegebenen Funktionen implementiert wurden.\n\n\n__construct()\n\n\nDiese Funktion wird jedes mal aufgerufen, wenn eine Instanz des Plugins erstellt wird. Hier wird ein Objekt der sciebo Klasse des Admin tools erzeugt, das als Parameter eine returnurl \u00fcbergeben bekommt.\n\n\n$returnurl = new moodle_url('/repository/repository_callback.php', [\n    'callback'  =\n 'yes',\n    'repo_id'   =\n $repositoryid,\n    'sesskey'   =\n sesskey(),\n]);\n$this-\nsciebo = new sciebo($returnurl);\n\n\n\n\nDer \ncallback url\n werden als Parameter noch zus\u00e4tzlich die id und der sesskey \u00fcbergeben, damit die Sitzung nach der Authentifizierung in ownCloud wieder hergestellt werden kann.\n\n\nDes weiteren wird die Parent Methode aufgerufen, die die n\u00f6tigen Datenbankeintr\u00e4ge t\u00e4tigt.\n\n\nget_file()\n\n\nDiese Funktion stellt eine Schnittstelle zum oauht2 Objekt des Admin tools bereit. Die Funktion \u00fcberpr\u00fcft ob schon eine offene Verbindung besteht mit Hilfe der Methode \nsciebo-\ndav-\nopen()\n. Falls keine Verbindung besteht wird die Funktion \n$this-\nsciebo-\nget_file();\n aufgerufen. Die Funktion \u00e4hnelt sehr der Funktion des \nWebDAV Repository\n, statt Basic Authentication wird jedoch das OAuth2 Protokoll benutzt. Danach wird der Nutzer  mit Hilfe der \nlogout()\n Funktion ausgeloggt. Dies erfolgt auch \u00fcber das Admin tool.\n\n\nget_listing()\n\n\nDiese Funktion wird aufgerufen um im File Picker die verf\u00fcgbaren Dateien anzuzeigen. Als R\u00fcckgabe wird ein Array aller verf\u00fcgbaren Dateien mit spezifischen Informationen \u00fcber diese Dateien erwartet. Bis auf die Authentifizierung funktioniert diese Methode genauso wie die Methode des WebDAV Repository. Am Anfang werden noch grundlegende Einstellungen f\u00fcr die Ansicht definiert:\n\n\n$ret['dynload'] = true;\n\n\n\n\nDies best\u00e4tigt dem File Picker, dass Inhalte dynamisch geladen werden. Das hei\u00dft das wenn z.B. ein Ordner angeklickt wird der File Picker einen Ajax-Request versendet um den Inhalt des Ordners anzeigen zu k\u00f6nnen.\n\n\n$ret['nosearch'] = true;\n\n\n\n\nDieser Parameter verbietet die Suche in den Dateien.\n\n\n$ret['nologin'] = false;\n\n\n\n\nDieser Parameter sorgt daf\u00fcr, dass der Login f\u00fcr jede Instanz notwendig ist. Zus\u00e4tzlich wird dadurch automatisch ein Logout-Button im File Picker generiert.\n\n\nMit Hilfe der sciebo Klasse wird \u00fcberpr\u00fcft ob es sich um eine Datei oder einen Ordner handelt.\n\n\nif (!empty($v['resourcetype']) \n $v['resourcetype'] == 'collection') {\n    // A folder.\n    if ($path != $v['href']) {\n        $folders[strtoupper($title)] = array(\n            'title' =\n rtrim($title, '/'),\n            'thumbnail' =\n $OUTPUT-\npix_url(file_folder_icon(90))-\nout(false),\n            'children' =\n array(),\n            'datemodified' =\n $v['lastmodified'],\n            'path' =\n $v['href']\n        );\n    }\n\n\n\n\nFalls es sich um einen Ordner handelt wird der Titel, ein Ordner als Bild, der Pfad zum Ordner und der Zeitpunkt des letzten Zugriffs gespeichert.\n\n\n} else {\n    // A file.\n    $size = !empty($v['getcontentlength']) ? $v['getcontentlength'] : '';\n    $files[strtoupper($title)] = array(\n        'title' =\n $title,\n        'thumbnail' =\n $OUTPUT-\npix_url(file_extension_icon($title, 90))-\nout(false),\n        'size' =\n $size,\n        'datemodified' =\n $v['lastmodified'],\n        'source' =\n $v['href']\n    );\n}\n\n\n\n\nFalls es sich um eine Datei handelt wird zus\u00e4tzlich zu den oben genannten Informationen noch die Datei Gr\u00f6\u00dfe gespeichert.\n\n\nMit Hilfe einer \nforeach()\n Schleife wird dies f\u00fcr jede Datei durchgef\u00fchrt. Anschlie\u00dfend werden zuerst Ordner und danach alphabetisch sortiert die Dateien in einem Array gespeichert. Diese Array wird von der Funktion wiedergegeben, Moodle platziert nun die entsprechenden Eintr\u00e4ge im File Picker.\n\n\nget_link()\n\n\nAnstelle einer Datei soll es auch m\u00f6glich sein, einen Downloadlink zu einer existierenden Datei bereitzustellen. Diese wird von dem Modul URL genutzt. Zus\u00e4tzlich besteht die M\u00f6glichkeit im File Picker Dateien zu verlinken. Die zweite Option erlauben wir in unserem Plugin nicht, da uns die Zeit fehlte die zus\u00e4tzliche Funktionalit\u00e4t zu implementieren. Dies haben wir in der Methode \nsupported_returntypes()\n ausgeschlossen.\nDie Implementierung der \nget_link()\n Methode ist nicht trivial da sich der Link abh\u00e4ngig von den Einstellungen im Admin Tool \u00e4ndert.\nMit Hilfe der Funktion \nget_config()\nk\u00f6nnen in Moodle Einstellungen spezifischer Plugins ausgelesen werden. In der Methode wird wiederum die Methode \nget_link()\n des Objektes \nsciebo\n aufgerufen. Um den funktionierenden Downloadlink zur\u00fcck zu geben muss nun noch der Pr\u00e4fix und die Serveraddresse vor den zur\u00fcckgegebenen Pfad gesetzt werden. Desweiteren wird hinter den Pfad noch \n'public.php?service=files\nt=' . $fileid . '\ndownload'\n angef\u00fcgt. Dies ist eine ownCloud spezifische Implementation einen Downloadlink zu generieren. Hier finden sie genauere Informationen zur \nownCloud external API\n.\n\n\npublic function get_link($url) {\n\n    $pref = get_config('tool_oauth2sciebo', 'type') . '://';\n\n    $output = $this-\nsciebo-\nget_link($url);\n    $xml = simplexml_load_string($output);\n    $fields = explode(\n/s/\n, $xml-\ndata[0]-\nurl[0]);\n    $fileid = $fields[1];\n\n    $path = str_replace('remote.php/dav/', '', get_config('tool_oauth2sciebo', 'path'));\n\n    return $pref . get_config('tool_oauth2sciebo', 'server'). '/' . $path .\n            'public.php?service=files\nt=' . $fileid . '\ndownload';\n}\n\n\n\n\nprint_login()\n\n\nUm einen Benutzer zum ersten mal mit dem OAuth 2.0 Protokoll anmelden zu k\u00f6nnen, muss er einmalig seinen Benutzer Namen und sein Passwort angeben. Sobald der Nutzer auf den Login Button klickt erscheint ein Pop-up Window oder es \u00f6ffnet sich ein neuer Tab im Browser, indem der Nutzer aufgefordert wird seinen Namen und sein Passwort anzugeben.\n\n\n    $url = $this-\nsciebo-\nget_login_url();\n    if ($this-\noptions['ajax']) {\n        $ret = array();\n        $btn = new \\stdClass();\n        $btn-\ntype = 'popup';\n        $btn-\nurl = $url-\nout(false);\n        $ret['login'] = array($btn);\n        return $ret;\n    } else {\n        echo html_writer::link($url, get_string('login', 'repository'), array('target' =\n '_blank'));\n    }\n\n\n\n\nAls N\u00e4chstes muss der Benutzer die App autorisieren. Nun wird er zu Moodle zur\u00fcckgeleitet. Die Funktion wird nur aufgerufen, falls der Nutzer weder mit seinem token noch mit einem refreshtoken authentifiziert werden kann.\n\n\nRepository spezifische Einstellungen\n\n\nF\u00fcr Repository Plugins gibt es einige Einstellungen die hart kodiert sind und sich nicht auf der Website anpassen lassen. Hierzu geh\u00f6ren folgende Funktionen:\n\n\n\n\nsupported_returntypes()\n  m\u00f6gliche R\u00fcckgabetypen sind:\n\n\nFILE_INTERNAL\n: Dateien d\u00fcrfen im Moodle Dateien System hoch und runtergeladen werden.\n\n\nFILE_EXTERNAL\n: Dateien bleiben im externen Repository und werden von dort bezogen.\n\n\nFILE_REFERENCE\n: Dateien werden lokal erstellt, aber werden extern synchronisiert wenn notwendig.\n\n\n\n\n\n\n\n\nWir haben \nFILE_INTERNAL\n und \nFILE_EXTERNAL\n erlaubt, da die Synchronisation von Dateien einen zu gro\u00dfen Implementationsaufwand f\u00fcr unser Projektseminar darstellte.\n\n\n\n\nsupported_filetypes()\n  hier wird spezifiziert welche Arten von Dateitypen unterst\u00fctzt werden. Wir haben alle Dateitypen erlaubt.\n\n\n\n\nImplementierung der \ndb/access.php\n\n\nStandardm\u00e4\u00dfig muss nur eine \ncapability\n in einem Repository-Plugin definiert werden. Diese hei\u00dft \nview capability\n und beschreibt wer das Repository sehen darf, sobald es vom Site Admin freigegeben und aktiviert wurde.\n\n\n$capabilities = array(\n    'repository/sciebo:view' =\n array(\n        'captype' =\n 'read',\n        'contextlevel' =\n CONTEXT_MODULE,\n        'archetypes' =\n array(\n            'user' =\n CAP_ALLOW\n        )\n    )\n);\n\n\n\n\nIn unserem Fall darf jeder Nutzer das Repository sehen.\n\n\nBesonderheiten der \nversion.php\n\n\nUm sicherzustellen, dass die Authentifizierung korrekt abl\u00e4uft muss das admin-tool oauth2sciebo installiert sein. Dies wird sichergestellt indem in der \nversion.php\n eine Abh\u00e4ngigkeit gesetzt wird:\n\n\n$plugin-\ndependencies = array(\n    'tool_oauth2sciebo' =\n ANY_VERSION);\n\n\n\n\nF\u00fcr genauere Informationen zu der version.php in Moodle sehen sie sich hier die offizielle Dokumentation der \nversion.php\n an.\n\n\nTests und Continuous Integration", 
            "title": "Repository"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#repository-sciebo", 
            "text": "", 
            "title": "Repository: sciebo"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#zweck", 
            "text": "Der Plugin Typ  Repository  wird in Moodle unter anderem verwendet um Nutzer die M\u00f6glichkeit zu schaffen Zugang zu\nDateien aus externen Quellen zu bekommen. Das Repository Plugin Sciebo kann somit die User Stories  Zwei  und  Drei  realisieren. Sobald der Admin das Plugin unter  Site administration Plugins  Repositories Manage repositories  aktiviert hat, sieht der Nutzer im File Picker folgende Optionen:  (Mehr Informationen zum File Picker finden sie in der  Moodle Dokumentation )  \n   TODO:  BILD nach richtiger Benennung.  Wenn der Nutzer auf den anmelde Button klickt, wird er zu einem Pop-up Window weitergeleitet, dass ihn auffordert sich in der zugeh\u00f6rigen ownCloud Istanz zu authentifizieren. Sobald der Nutzer sich hier einmalig authentifiziert hat, werden ihm im File Picker seine Dateien angezeigt. Das Plugin bietet dem Benutzer zus\u00e4tzliche Vorteile\ndadurch, dass die Authentifizierung nur einmalig erfolgt. Durch den OAuth2 Protokollablauf werden danach Refresh Tokens angefordert ohne dass der Nutzer dies im Front-End zu sehen bekommt. Somit kann der Nutzer angemeldet bleiben w\u00e4hrend verschiedenen Sessions.", 
            "title": "Zweck"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#vorgegebene-schnittstelle", 
            "text": "Wie auch im  Admin Tool  m\u00fcssen zun\u00e4chst einige Standartschnittstellen implementiert werden:   version.php :  Beschreibt die Versionsnummer des Plugins, die ben\u00f6tigte moodle Version und Abh\u00e4ngigkeiten des Plugins.  db/access.php :  Legt die Berechtigungen f\u00fcr definierte Aktionen innerhalb des Plugins anhand von Nutzerrollen fest.  lang/en/repository__sciebo.php :  Beinhaltet Sprachstrings f\u00fcr unterschiedliche Regionen und Sprachen, sodass definierte Strings,\nabh\u00e4ngig von der jeweiligen Sprache, dynamisch angezeigt werden k\u00f6nnen. Als Standard wird eine englische Sprachdatei erwartet.   F\u00fcr Repository-Plugins m\u00fcssen au\u00dferdem folgende Dateien implementiert werden:   pix/icon.png :  Hier wird ein 16x16 icon platziert, welches f\u00fcr das Plugin genutzt wird.  lib.php :  Hier wird eine Klasse  repository_sciebo extends repository  deklariert, die als Hauptaufgabe die Integration in den File Picker verwaltet.", 
            "title": "Vorgegebene Schnittstelle"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#implementierung", 
            "text": "", 
            "title": "Implementierung"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#implementierung-der-libphp", 
            "text": "In der lib.php wird eine Klasse definiert die von der abstrakten Klasse  repository  erbt. Im Folgenden wird darauf eingegangen wie die vorgegebenen Funktionen implementiert wurden.", 
            "title": "Implementierung der lib.php"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#__construct", 
            "text": "Diese Funktion wird jedes mal aufgerufen, wenn eine Instanz des Plugins erstellt wird. Hier wird ein Objekt der sciebo Klasse des Admin tools erzeugt, das als Parameter eine returnurl \u00fcbergeben bekommt.  $returnurl = new moodle_url('/repository/repository_callback.php', [\n    'callback'  =  'yes',\n    'repo_id'   =  $repositoryid,\n    'sesskey'   =  sesskey(),\n]);\n$this- sciebo = new sciebo($returnurl);  Der  callback url  werden als Parameter noch zus\u00e4tzlich die id und der sesskey \u00fcbergeben, damit die Sitzung nach der Authentifizierung in ownCloud wieder hergestellt werden kann.  Des weiteren wird die Parent Methode aufgerufen, die die n\u00f6tigen Datenbankeintr\u00e4ge t\u00e4tigt.", 
            "title": "__construct()"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#get_file", 
            "text": "Diese Funktion stellt eine Schnittstelle zum oauht2 Objekt des Admin tools bereit. Die Funktion \u00fcberpr\u00fcft ob schon eine offene Verbindung besteht mit Hilfe der Methode  sciebo- dav- open() . Falls keine Verbindung besteht wird die Funktion  $this- sciebo- get_file();  aufgerufen. Die Funktion \u00e4hnelt sehr der Funktion des  WebDAV Repository , statt Basic Authentication wird jedoch das OAuth2 Protokoll benutzt. Danach wird der Nutzer  mit Hilfe der  logout()  Funktion ausgeloggt. Dies erfolgt auch \u00fcber das Admin tool.", 
            "title": "get_file()"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#get_listing", 
            "text": "Diese Funktion wird aufgerufen um im File Picker die verf\u00fcgbaren Dateien anzuzeigen. Als R\u00fcckgabe wird ein Array aller verf\u00fcgbaren Dateien mit spezifischen Informationen \u00fcber diese Dateien erwartet. Bis auf die Authentifizierung funktioniert diese Methode genauso wie die Methode des WebDAV Repository. Am Anfang werden noch grundlegende Einstellungen f\u00fcr die Ansicht definiert:  $ret['dynload'] = true;  Dies best\u00e4tigt dem File Picker, dass Inhalte dynamisch geladen werden. Das hei\u00dft das wenn z.B. ein Ordner angeklickt wird der File Picker einen Ajax-Request versendet um den Inhalt des Ordners anzeigen zu k\u00f6nnen.  $ret['nosearch'] = true;  Dieser Parameter verbietet die Suche in den Dateien.  $ret['nologin'] = false;  Dieser Parameter sorgt daf\u00fcr, dass der Login f\u00fcr jede Instanz notwendig ist. Zus\u00e4tzlich wird dadurch automatisch ein Logout-Button im File Picker generiert.  Mit Hilfe der sciebo Klasse wird \u00fcberpr\u00fcft ob es sich um eine Datei oder einen Ordner handelt.  if (!empty($v['resourcetype'])   $v['resourcetype'] == 'collection') {\n    // A folder.\n    if ($path != $v['href']) {\n        $folders[strtoupper($title)] = array(\n            'title' =  rtrim($title, '/'),\n            'thumbnail' =  $OUTPUT- pix_url(file_folder_icon(90))- out(false),\n            'children' =  array(),\n            'datemodified' =  $v['lastmodified'],\n            'path' =  $v['href']\n        );\n    }  Falls es sich um einen Ordner handelt wird der Titel, ein Ordner als Bild, der Pfad zum Ordner und der Zeitpunkt des letzten Zugriffs gespeichert.  } else {\n    // A file.\n    $size = !empty($v['getcontentlength']) ? $v['getcontentlength'] : '';\n    $files[strtoupper($title)] = array(\n        'title' =  $title,\n        'thumbnail' =  $OUTPUT- pix_url(file_extension_icon($title, 90))- out(false),\n        'size' =  $size,\n        'datemodified' =  $v['lastmodified'],\n        'source' =  $v['href']\n    );\n}  Falls es sich um eine Datei handelt wird zus\u00e4tzlich zu den oben genannten Informationen noch die Datei Gr\u00f6\u00dfe gespeichert.  Mit Hilfe einer  foreach()  Schleife wird dies f\u00fcr jede Datei durchgef\u00fchrt. Anschlie\u00dfend werden zuerst Ordner und danach alphabetisch sortiert die Dateien in einem Array gespeichert. Diese Array wird von der Funktion wiedergegeben, Moodle platziert nun die entsprechenden Eintr\u00e4ge im File Picker.", 
            "title": "get_listing()"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#get_link", 
            "text": "Anstelle einer Datei soll es auch m\u00f6glich sein, einen Downloadlink zu einer existierenden Datei bereitzustellen. Diese wird von dem Modul URL genutzt. Zus\u00e4tzlich besteht die M\u00f6glichkeit im File Picker Dateien zu verlinken. Die zweite Option erlauben wir in unserem Plugin nicht, da uns die Zeit fehlte die zus\u00e4tzliche Funktionalit\u00e4t zu implementieren. Dies haben wir in der Methode  supported_returntypes()  ausgeschlossen.\nDie Implementierung der  get_link()  Methode ist nicht trivial da sich der Link abh\u00e4ngig von den Einstellungen im Admin Tool \u00e4ndert.\nMit Hilfe der Funktion  get_config() k\u00f6nnen in Moodle Einstellungen spezifischer Plugins ausgelesen werden. In der Methode wird wiederum die Methode  get_link()  des Objektes  sciebo  aufgerufen. Um den funktionierenden Downloadlink zur\u00fcck zu geben muss nun noch der Pr\u00e4fix und die Serveraddresse vor den zur\u00fcckgegebenen Pfad gesetzt werden. Desweiteren wird hinter den Pfad noch  'public.php?service=files t=' . $fileid . ' download'  angef\u00fcgt. Dies ist eine ownCloud spezifische Implementation einen Downloadlink zu generieren. Hier finden sie genauere Informationen zur  ownCloud external API .  public function get_link($url) {\n\n    $pref = get_config('tool_oauth2sciebo', 'type') . '://';\n\n    $output = $this- sciebo- get_link($url);\n    $xml = simplexml_load_string($output);\n    $fields = explode( /s/ , $xml- data[0]- url[0]);\n    $fileid = $fields[1];\n\n    $path = str_replace('remote.php/dav/', '', get_config('tool_oauth2sciebo', 'path'));\n\n    return $pref . get_config('tool_oauth2sciebo', 'server'). '/' . $path .\n            'public.php?service=files t=' . $fileid . ' download';\n}", 
            "title": "get_link()"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#print_login", 
            "text": "Um einen Benutzer zum ersten mal mit dem OAuth 2.0 Protokoll anmelden zu k\u00f6nnen, muss er einmalig seinen Benutzer Namen und sein Passwort angeben. Sobald der Nutzer auf den Login Button klickt erscheint ein Pop-up Window oder es \u00f6ffnet sich ein neuer Tab im Browser, indem der Nutzer aufgefordert wird seinen Namen und sein Passwort anzugeben.      $url = $this- sciebo- get_login_url();\n    if ($this- options['ajax']) {\n        $ret = array();\n        $btn = new \\stdClass();\n        $btn- type = 'popup';\n        $btn- url = $url- out(false);\n        $ret['login'] = array($btn);\n        return $ret;\n    } else {\n        echo html_writer::link($url, get_string('login', 'repository'), array('target' =  '_blank'));\n    }  Als N\u00e4chstes muss der Benutzer die App autorisieren. Nun wird er zu Moodle zur\u00fcckgeleitet. Die Funktion wird nur aufgerufen, falls der Nutzer weder mit seinem token noch mit einem refreshtoken authentifiziert werden kann.", 
            "title": "print_login()"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#repository-spezifische-einstellungen", 
            "text": "F\u00fcr Repository Plugins gibt es einige Einstellungen die hart kodiert sind und sich nicht auf der Website anpassen lassen. Hierzu geh\u00f6ren folgende Funktionen:   supported_returntypes()   m\u00f6gliche R\u00fcckgabetypen sind:  FILE_INTERNAL : Dateien d\u00fcrfen im Moodle Dateien System hoch und runtergeladen werden.  FILE_EXTERNAL : Dateien bleiben im externen Repository und werden von dort bezogen.  FILE_REFERENCE : Dateien werden lokal erstellt, aber werden extern synchronisiert wenn notwendig.     Wir haben  FILE_INTERNAL  und  FILE_EXTERNAL  erlaubt, da die Synchronisation von Dateien einen zu gro\u00dfen Implementationsaufwand f\u00fcr unser Projektseminar darstellte.   supported_filetypes()   hier wird spezifiziert welche Arten von Dateitypen unterst\u00fctzt werden. Wir haben alle Dateitypen erlaubt.", 
            "title": "Repository spezifische Einstellungen"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#implementierung-der-dbaccessphp", 
            "text": "Standardm\u00e4\u00dfig muss nur eine  capability  in einem Repository-Plugin definiert werden. Diese hei\u00dft  view capability  und beschreibt wer das Repository sehen darf, sobald es vom Site Admin freigegeben und aktiviert wurde.  $capabilities = array(\n    'repository/sciebo:view' =  array(\n        'captype' =  'read',\n        'contextlevel' =  CONTEXT_MODULE,\n        'archetypes' =  array(\n            'user' =  CAP_ALLOW\n        )\n    )\n);  In unserem Fall darf jeder Nutzer das Repository sehen.", 
            "title": "Implementierung der db/access.php"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#besonderheiten-der-versionphp", 
            "text": "Um sicherzustellen, dass die Authentifizierung korrekt abl\u00e4uft muss das admin-tool oauth2sciebo installiert sein. Dies wird sichergestellt indem in der  version.php  eine Abh\u00e4ngigkeit gesetzt wird:  $plugin- dependencies = array(\n    'tool_oauth2sciebo' =  ANY_VERSION);  F\u00fcr genauere Informationen zu der version.php in Moodle sehen sie sich hier die offizielle Dokumentation der  version.php  an.", 
            "title": "Besonderheiten der version.php"
        }, 
        {
            "location": "/moodle/technische-umsetzung/repository/#tests-und-continuous-integration", 
            "text": "", 
            "title": "Tests und Continuous Integration"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/", 
            "text": "Aktivit\u00e4t: \ncollaborative folders\n\n\nZweck\n\n\nDas Aktivit\u00e4ts Modul \nCollaborative Folders\n soll Lehrenden die M\u00f6glichkeit geben, f\u00fcr Studierende oder Gruppen von Studierenden Ordner f\u00fcr kollaboratives Arbeiten zu erstellen.\nDie Autorisierung und Authentifizierung erfolgt \u00fcber das \noauth2sciebo admin_tool\n. Diese Aktivit\u00e4t \ncollaborativefolders\n implementiert die User Story 4:\n\n\n\n  \nAls \nLehrender\n m\u00f6chte ich Studierenden oder Gruppen von Studierenden Ordner f\u00fcr kollaboratives Arbeiten bereitstellen.\n\n\n\n\n\nIm Folgenden wird erkl\u00e4rt wozu einzelne Beteiligte des Integrationszenarioin der Lage sein m\u00fcssen.\nDaf\u00fcr ist es erforderlich einen neutralen Speicherort f\u00fcr die geteilten Ordner bereitzustellen. Falls der Lehrende keinen Zugriff auf die Ordner haben soll, d\u00fcrfen sie nicht in seiner Instanz gespeichert sein. Um die Privatsph\u00e4re der Kursteilnehmer zu sichern darf ein Lehrender nicht unter ihrem Namen Ordner erstellen. Aus diesem Grund haben wir unsere L\u00f6sung so implementiert, dass der Moodle Administrator einen technischen Nutzer festlegen kann. In dessen Namen werden alle Ordner erstellt.\nDer Lehrende wird in der Lage sein einem Kurs beliebig viele Instanzen der Aktivit\u00e4t \nCollaborative Folders\n hinzuf\u00fcgen. In den Einstellungen kann der Lehrende\nnun festlegen wie der Ordner im Moodle Kurs benannt werden soll und wie der Ordner in der ownCloud Instanz benannt werden soll. Mit dieser Aktivit\u00e4t kann er Kursteilnehmer ermutigen kollaborativ zu arbeiten. Zus\u00e4tzlich hat die Option die laufende Arbeit zu betreuen, indem er sich selbst Zugriff auf die Ordner gew\u00e4hrt. In diesem Fall werden die Kursteilnehmer dar\u00fcber in Kenntniss gesetzt, dass der Ordner Lehrenden zug\u00e4nglich ist.\nKursteilnehmer haben weniger Organisationsaufwand und werden bei ihrer Gruppenarbeit unterst\u00fctzt. Zus\u00e4tzlich muss kein Kursteilnehmer eigenen Speicherplatz zur Verf\u00fcgung stellen.\n\n\nVorgegebene Schnittstelle\n\n\nUm die User Story zu realisieren haben wir ein Aktivity Plugin f\u00fcr Moodle entwickelt. Instanzen von Aktivity Plugins k\u00f6nnen Kursen beliebig oft hinzugef\u00fcgt werden.\nF\u00fcr genauere Informationen besuchen sie die Moodle Dokumentation von \nAktivity modules\n\nIn der \ncollaborativefolders/mod_form.php\n fragen wir alle Einstellungen ab, die vor dem Erstellen der Ordner bekannt sein m\u00fcssen. Dies beeinhaltet Name des Ordners in Moodle, Zugriff des Lehrenden auf die erstellten Ordner und ob f\u00fcr Gruppen seperate Ordner erzeugt werden sollen.\nIn der \ncollaborativefolders/settings.php\n kann der Administrator den technischen Nutzer des Plugins festlegen. Dieser gilt f\u00fcr alle Instanzen, also global f\u00fcr das gesammte Plugin.\nDie \ncollaborativefolders/lib.php\n bietet eine Schnittstelle um auf das Hinzuf\u00fcgen, \u00c4ndern und L\u00f6schen von Instanzen zu reagieren.\n\n\n  \nTODO:\n nicht zu genau beschreiben die moodle Dokumentationist sehr gut lieber auf die Implementation mehr eingehen.\n\n\n\nImplementierung\n\n\nAnmelden des technischen Nutzers\n\n\nDer Admin der Moodle Seite kann in der Seiten Administration einen technischen Nutzer hinzuf\u00fcgen. \u00dcber \nSite administration \u25ba Plugins \u25ba Activity modules \u25ba collaborativefolders\n kommt er zu den passenden Einstellungen. Dort wird er durch einen Login-Button auf die ownCloud Seite zum autorisieren der App weitergeleitet. Sp\u00e4tere \u00c4nderungen des technischen Nutzers sind durch ein Logout Button m\u00f6glich. Dies ist nicht empfohlen und mit einer Warnmeldung versehen, da Kompilierungs-Problemen mit bestehenden Instanzen entstehen w\u00fcrden. Wir haben uns daf\u00fcr entschieden den Logout trotzdem bereitzustellen, f\u00fcr den Fall das ein falscher Account authentifiziert wird. Hierbei sind wir insbesondere \u00fcber folgendes Szenario gesto\u00dfen:\n\n\nDer Seiten Administrator will den technischen Nutzer einloggen, ist aber noch mit seinem eigenen ownCloud Account oder dem Administrator account der ownCloud authentifiziert. Er bemerkt nicht, dass er mit dem falschen Account eingeloggt ist autorisiert das Plugin. Als er seinen Fehler bemerkt, m\u00f6chte er den technischen Nutzer so schnell wie m\u00f6glich \u00e4ndern, obwohl bestehende Instanzen neu erstellt werden m\u00fcssen.\n\n\nErstellen von Ordnern\n\n\nZum Erstellen von Ordnern haben einen Observer implementiert, der aufgerufen wird wenn eine Instanz der Aktivit\u00e4t \ncollaborativefolders\n erstellt wird.\nIn \ncollaborativefolders/db/events.php\n k\u00f6nnen in einem array alle Observer registriert werden und werden von Moodle verwaltet.\n\n\n$observers = array(\n        array(\n                // Zuerst wird das Event, dass beobachtet werden soll festgelegt.\n                'eventname'   =\n '\\core\\event\\course_module_created',\n                // Als n\u00e4chstes wird der Observer festgelegt.\n                'callback'    =\n 'mod_collaborativefolders\\observer::collaborativefolders_created',\n                'internal'  =\n false,\n                'priority'  =\n 1000\n        )\n\n);\n\n\n\n\nSomit wird sobald das Event \ncourse_module_created\n erzeugt wird, der Observer aufgerufen. Es gibt zwei Hauptgr\u00fcnde warum dies erforderlich war. Zun\u00e4chst brauchten wir f\u00fcr das Erstellen der Ordner die \ncourse_module_id\n. Diese ist nur verf\u00fcgbar wenn die Instanz schon erstellt wurde, somit kann nicht die Schnittstelle der \ncollaborativefolders/lib.php\n \nadd_instance()\n genutzt werden. Desweiteren ruft unser Observer einen CronJob auf. Dieser sorgt daf\u00fcr, dass Ordner zeitlich verz\u00f6gert erstellt werden, somit wird der Server nicht \u00fcberlastet. Falls Ordner f\u00fcr gro\u00dfe Kurse mit \u00fcber 50 Gruppen erstellt werden sollen k\u00f6nnte es hier sonst zu Schwierigkeiten kommen.\nBeim Erstellen m\u00fcssen zwei unterschiedliche Szenarien betrachtet werden:\n\n\nIm ersten Szenario wird ein Ordner f\u00fcr alle Studierenden eines Kurses erstellt.\nDie Anforderung an das Modul ist also einen Ordner in dem gespeicherten Account zu erstellender der eindeutig Identifizierbar ist. Dies ist gesichert indem wir die Ordner nach der \ncourse_module_id\n benennen. Diese ist einzigartig f\u00fcr jede Aktivit\u00e4t, die in Moodle erzeugt wird. So kann es, soweit manuell\nkeine Ordner erstellt werden, zu keinen Synchronisationskonflikten kommen.\n\n\n$paths = array();\n            $paths['cmid'] = $cmid;\n\n            list ($course, $cm) = get_course_and_cm_from_cmid($cmid, 'collaborativefolders');\n\n\n\n\nIm zweiten Szenario sollen Ordner f\u00fcr Gruppen innerhalb eines Kurses erstellt werden.\nAuch hier m\u00fcssen eindeutig identifizierbare Ordner erstellt werden. Deswegen wird ein \u00dcberordner erstellt mit der \ncourse_module_id\n. In diesem Ordner wird nun zu jeder Gruppe ein Unterordner erstellt.\n\n\nif (groups_get_activity_groupmode($cm) != 0) {\n    $grid = $cm-\ngroupingid;\n    $groups = groups_get_all_groups($course-\nid, 0, $grid);\n\n    foreach ($groups as $group) {\n        $path = $cmid . '/' . $group-\nid;\n        $paths[$group-\nid] = $path;\n    }\n}\n\n\n\n\nZu diesem Zweck wird in der Variable \n$path\n die einem Cronjob \u00fcbergeben wird nicht nur die \ncourse_module_id\n gespeichert, sondern auch f\u00fcr jede \n$groupid\n ein Feld.\nDer Cronjob, der nun die Ordner erstellt, kann anhand der Eintr\u00e4ge im Array erkennen wie viele und welche Ordner er erstellen muss.\n\n\nDer Cronjob findet sich in \ncollaborativefolders/classes/task/collaborativefolders_create.php\n. Er erbt von der abstrakten Klasse \n\\core\\task\\adhoc_task\n.\nDieser lie\u00dft aus den Daten die er \u00fcbergeben bekommt alle Ordner aus die erstellt werden m\u00fcssen.\n\n\nforeach ($data as $key =\n $value) {\n            $code = $oc-\nhandle_folder('make', $value);\n            if ($code == false) {\n                throw new \\coding_exception('Folder ' . $value . ' not created.');\n            } else {\n                mtrace('Folder: ' . $value . ', Code: ' . $code);\n                if (($code != 201) \n ($code != 405)) {\n                    throw new \\coding_exception('Folder ' . $value . ' not created.');\n                }\n            }\n        }\n\n\n\n\nTests und Continuous Integration", 
            "title": "Collaborative Folders"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/#aktivitat-collaborative-folders", 
            "text": "", 
            "title": "Aktivit\u00e4t: collaborative folders"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/#zweck", 
            "text": "Das Aktivit\u00e4ts Modul  Collaborative Folders  soll Lehrenden die M\u00f6glichkeit geben, f\u00fcr Studierende oder Gruppen von Studierenden Ordner f\u00fcr kollaboratives Arbeiten zu erstellen.\nDie Autorisierung und Authentifizierung erfolgt \u00fcber das  oauth2sciebo admin_tool . Diese Aktivit\u00e4t  collaborativefolders  implementiert die User Story 4:  \n   Als  Lehrender  m\u00f6chte ich Studierenden oder Gruppen von Studierenden Ordner f\u00fcr kollaboratives Arbeiten bereitstellen.   Im Folgenden wird erkl\u00e4rt wozu einzelne Beteiligte des Integrationszenarioin der Lage sein m\u00fcssen.\nDaf\u00fcr ist es erforderlich einen neutralen Speicherort f\u00fcr die geteilten Ordner bereitzustellen. Falls der Lehrende keinen Zugriff auf die Ordner haben soll, d\u00fcrfen sie nicht in seiner Instanz gespeichert sein. Um die Privatsph\u00e4re der Kursteilnehmer zu sichern darf ein Lehrender nicht unter ihrem Namen Ordner erstellen. Aus diesem Grund haben wir unsere L\u00f6sung so implementiert, dass der Moodle Administrator einen technischen Nutzer festlegen kann. In dessen Namen werden alle Ordner erstellt.\nDer Lehrende wird in der Lage sein einem Kurs beliebig viele Instanzen der Aktivit\u00e4t  Collaborative Folders  hinzuf\u00fcgen. In den Einstellungen kann der Lehrende\nnun festlegen wie der Ordner im Moodle Kurs benannt werden soll und wie der Ordner in der ownCloud Instanz benannt werden soll. Mit dieser Aktivit\u00e4t kann er Kursteilnehmer ermutigen kollaborativ zu arbeiten. Zus\u00e4tzlich hat die Option die laufende Arbeit zu betreuen, indem er sich selbst Zugriff auf die Ordner gew\u00e4hrt. In diesem Fall werden die Kursteilnehmer dar\u00fcber in Kenntniss gesetzt, dass der Ordner Lehrenden zug\u00e4nglich ist.\nKursteilnehmer haben weniger Organisationsaufwand und werden bei ihrer Gruppenarbeit unterst\u00fctzt. Zus\u00e4tzlich muss kein Kursteilnehmer eigenen Speicherplatz zur Verf\u00fcgung stellen.", 
            "title": "Zweck"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/#vorgegebene-schnittstelle", 
            "text": "Um die User Story zu realisieren haben wir ein Aktivity Plugin f\u00fcr Moodle entwickelt. Instanzen von Aktivity Plugins k\u00f6nnen Kursen beliebig oft hinzugef\u00fcgt werden.\nF\u00fcr genauere Informationen besuchen sie die Moodle Dokumentation von  Aktivity modules \nIn der  collaborativefolders/mod_form.php  fragen wir alle Einstellungen ab, die vor dem Erstellen der Ordner bekannt sein m\u00fcssen. Dies beeinhaltet Name des Ordners in Moodle, Zugriff des Lehrenden auf die erstellten Ordner und ob f\u00fcr Gruppen seperate Ordner erzeugt werden sollen.\nIn der  collaborativefolders/settings.php  kann der Administrator den technischen Nutzer des Plugins festlegen. Dieser gilt f\u00fcr alle Instanzen, also global f\u00fcr das gesammte Plugin.\nDie  collaborativefolders/lib.php  bietet eine Schnittstelle um auf das Hinzuf\u00fcgen, \u00c4ndern und L\u00f6schen von Instanzen zu reagieren. \n   TODO:  nicht zu genau beschreiben die moodle Dokumentationist sehr gut lieber auf die Implementation mehr eingehen.", 
            "title": "Vorgegebene Schnittstelle"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/#implementierung", 
            "text": "", 
            "title": "Implementierung"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/#anmelden-des-technischen-nutzers", 
            "text": "Der Admin der Moodle Seite kann in der Seiten Administration einen technischen Nutzer hinzuf\u00fcgen. \u00dcber  Site administration \u25ba Plugins \u25ba Activity modules \u25ba collaborativefolders  kommt er zu den passenden Einstellungen. Dort wird er durch einen Login-Button auf die ownCloud Seite zum autorisieren der App weitergeleitet. Sp\u00e4tere \u00c4nderungen des technischen Nutzers sind durch ein Logout Button m\u00f6glich. Dies ist nicht empfohlen und mit einer Warnmeldung versehen, da Kompilierungs-Problemen mit bestehenden Instanzen entstehen w\u00fcrden. Wir haben uns daf\u00fcr entschieden den Logout trotzdem bereitzustellen, f\u00fcr den Fall das ein falscher Account authentifiziert wird. Hierbei sind wir insbesondere \u00fcber folgendes Szenario gesto\u00dfen:  Der Seiten Administrator will den technischen Nutzer einloggen, ist aber noch mit seinem eigenen ownCloud Account oder dem Administrator account der ownCloud authentifiziert. Er bemerkt nicht, dass er mit dem falschen Account eingeloggt ist autorisiert das Plugin. Als er seinen Fehler bemerkt, m\u00f6chte er den technischen Nutzer so schnell wie m\u00f6glich \u00e4ndern, obwohl bestehende Instanzen neu erstellt werden m\u00fcssen.", 
            "title": "Anmelden des technischen Nutzers"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/#erstellen-von-ordnern", 
            "text": "Zum Erstellen von Ordnern haben einen Observer implementiert, der aufgerufen wird wenn eine Instanz der Aktivit\u00e4t  collaborativefolders  erstellt wird.\nIn  collaborativefolders/db/events.php  k\u00f6nnen in einem array alle Observer registriert werden und werden von Moodle verwaltet.  $observers = array(\n        array(\n                // Zuerst wird das Event, dass beobachtet werden soll festgelegt.\n                'eventname'   =  '\\core\\event\\course_module_created',\n                // Als n\u00e4chstes wird der Observer festgelegt.\n                'callback'    =  'mod_collaborativefolders\\observer::collaborativefolders_created',\n                'internal'  =  false,\n                'priority'  =  1000\n        )\n\n);  Somit wird sobald das Event  course_module_created  erzeugt wird, der Observer aufgerufen. Es gibt zwei Hauptgr\u00fcnde warum dies erforderlich war. Zun\u00e4chst brauchten wir f\u00fcr das Erstellen der Ordner die  course_module_id . Diese ist nur verf\u00fcgbar wenn die Instanz schon erstellt wurde, somit kann nicht die Schnittstelle der  collaborativefolders/lib.php   add_instance()  genutzt werden. Desweiteren ruft unser Observer einen CronJob auf. Dieser sorgt daf\u00fcr, dass Ordner zeitlich verz\u00f6gert erstellt werden, somit wird der Server nicht \u00fcberlastet. Falls Ordner f\u00fcr gro\u00dfe Kurse mit \u00fcber 50 Gruppen erstellt werden sollen k\u00f6nnte es hier sonst zu Schwierigkeiten kommen.\nBeim Erstellen m\u00fcssen zwei unterschiedliche Szenarien betrachtet werden:  Im ersten Szenario wird ein Ordner f\u00fcr alle Studierenden eines Kurses erstellt.\nDie Anforderung an das Modul ist also einen Ordner in dem gespeicherten Account zu erstellender der eindeutig Identifizierbar ist. Dies ist gesichert indem wir die Ordner nach der  course_module_id  benennen. Diese ist einzigartig f\u00fcr jede Aktivit\u00e4t, die in Moodle erzeugt wird. So kann es, soweit manuell\nkeine Ordner erstellt werden, zu keinen Synchronisationskonflikten kommen.  $paths = array();\n            $paths['cmid'] = $cmid;\n\n            list ($course, $cm) = get_course_and_cm_from_cmid($cmid, 'collaborativefolders');  Im zweiten Szenario sollen Ordner f\u00fcr Gruppen innerhalb eines Kurses erstellt werden.\nAuch hier m\u00fcssen eindeutig identifizierbare Ordner erstellt werden. Deswegen wird ein \u00dcberordner erstellt mit der  course_module_id . In diesem Ordner wird nun zu jeder Gruppe ein Unterordner erstellt.  if (groups_get_activity_groupmode($cm) != 0) {\n    $grid = $cm- groupingid;\n    $groups = groups_get_all_groups($course- id, 0, $grid);\n\n    foreach ($groups as $group) {\n        $path = $cmid . '/' . $group- id;\n        $paths[$group- id] = $path;\n    }\n}  Zu diesem Zweck wird in der Variable  $path  die einem Cronjob \u00fcbergeben wird nicht nur die  course_module_id  gespeichert, sondern auch f\u00fcr jede  $groupid  ein Feld.\nDer Cronjob, der nun die Ordner erstellt, kann anhand der Eintr\u00e4ge im Array erkennen wie viele und welche Ordner er erstellen muss.  Der Cronjob findet sich in  collaborativefolders/classes/task/collaborativefolders_create.php . Er erbt von der abstrakten Klasse  \\core\\task\\adhoc_task .\nDieser lie\u00dft aus den Daten die er \u00fcbergeben bekommt alle Ordner aus die erstellt werden m\u00fcssen.  foreach ($data as $key =  $value) {\n            $code = $oc- handle_folder('make', $value);\n            if ($code == false) {\n                throw new \\coding_exception('Folder ' . $value . ' not created.');\n            } else {\n                mtrace('Folder: ' . $value . ', Code: ' . $code);\n                if (($code != 201)   ($code != 405)) {\n                    throw new \\coding_exception('Folder ' . $value . ' not created.');\n                }\n            }\n        }", 
            "title": "Erstellen von Ordnern"
        }, 
        {
            "location": "/moodle/technische-umsetzung/activity/#tests-und-continuous-integration", 
            "text": "", 
            "title": "Tests und Continuous Integration"
        }, 
        {
            "location": "/moodle/benutzung/", 
            "text": "Benutzung\n\n\nPlugins k\u00f6nnen in Moodle zus\u00e4tzlich installiert werden. Auf der \noffiziellen Seite\n\nvon Moodle k\u00f6nnen alle zurzeit angebotenen Plugins gefunden werden. F\u00fcr mehr Informationen zur allgemeinen Installation von Moodle Plugins\nbenutzen sie die Dokumentation der \nMoodle Seite\n.\n\n\nInstallation\n\n\nWenn sie die Plugins heruntergeladen haben und richtig platziert haben zeigt der Moodle Plugin Manager Ihnen die verf\u00fcgbaren Plugins an.\nSie ben\u00f6tigen in jedem Fall das oauth2_admin_tool, alle anderen Plugins sind von diesem abh\u00e4ngig.\n\n\nAdmin Tool oauth2sciebo\n\n\nAdmin Einstellungen\n\n\nDamit das OAuth 2 Protokoll reibungslos ablaufen kann, muss zuerst der Client in den Einstellungen registriert werden.\n\n\nHierf\u00fcr muss der Administrator das Formular des Plugins, das unter \nWebsite-Administration\nPlugins\nAuthentifizierung\nSciebo OAuth 2.0 Configuration\n zu finden ist, ausf\u00fcllen.\n\n\n\n\nAls erstes Feld muss die Client ID eingegeben werden. Diese findet man in ownCloud, sobald ein neuer Client registriert wurde. Dasselbe gilt f\u00fcr das n\u00e4chste Feld, hier wird das Secret angegeben, dass sich auch aus der ownCloud App kopieren l\u00e4sst.\n\n\n\n\nNun werden die Einstellungen f\u00fcr den WebDAV Zugriff festgelegt.\nAls erstes wird die Adresse des ownCloud Servers angegeben.\nIm n\u00e4chsten Feld wird der Pfad zur WebDAV Schnittstelle angegeben in ownCloud endet diese typischerweise mit \nremote.php/webdav/\n.\nAls Protokolltyp kann http oder https angegeben werden. Wenn keine Angabe gemacht wird, wird von https ausgegangen.\nAls letztes kann der Port angegeben werden.\n\n\nRepository sciebo\n\n\nAdmin Einstellungen\n\n\nSobald das Admin tool installiert wurde, kann das Repository installiert werden. Bitte beachten Sie, dass die oben genannten Eintr\u00e4ge get\u00e4tigt wurden, ansonsten funktioniert die Authentifizierung des Repositorys nicht. Repositorys Plugins m\u00fcssen in Moodle von einem Administrator unter dem Men\u00fcpunkt \nWebsite-Administration\nPluginsRepositories\n\u00dcbersicht\n aktiviert werden. Der Administrator kann dem Repository zus\u00e4tzlich unter \nEinstellungen\n einen globalen Namen geben.\n\n\nNutzer Sicht\n\n\nDas Repository ist sowohl in den Kursen als auch f\u00fcr private Instanzen verf\u00fcgbar und muss nicht mehr hinzugef\u00fcgt werden. Kurs Administratoren k\u00f6nnen das Repository jedoch unter \nSpeicherorte\n l\u00f6schen. Die Nutzung l\u00e4sst sich nicht auf bestimmte Nutzer oder Aktivit\u00e4ten im Kurs einschr\u00e4nken. Im File Picker muss man sich zun\u00e4chst anmelden.\nDanach sieht man nach der Anmeldung eine tabellarische Auflistung der vorhandenen Dateien:\n\n\n\n\nIm roten Kasten sehen sie Buttons um den Inhalt neu zu laden, sich auszuloggen und nur als Admin sieht man den letzten Button in dem man die Einstellungen des OAuth2 admin_tool bearbeiten kann.\n\n\ncollaborative_folders\n\n\nEinstellungen\n\n\nAdmin Einstellungen\n\n\nF\u00fcr die Aktivit\u00e4t collaborative_folders wird ein technischer Nutzer der ownCloud Instanz ben\u00f6tigt. Bei diesem Nutzer werden alle Ordner die erstellt werden gespeichert. Um den Nutzer festzulegen muss in \nWebsite-Administration\nPlugins\nAktivit\u00e4ten\ncollaborativefolders\n ein technischer Nutzer mit Hilfe des OAuth2 Protokolls authentifizieren. \u00dcber einen Login Button werden Sie aufgefordert sich in ownCloud zu authentifizieren. Falls Sie nicht richtig weitergeleitet werden, sind die Einstellungen im Admin tool oauth2sciebo fehlerhaft, bitte \u00fcberpr\u00fcfen Sie diese. Achten Sie darauf, dass Sie sich nicht mit Ihrem normalen Account sondern mit dem technischen Nutzer anmelden.\n\n\nSicht des Lehrenden\n\n\nDie Aktivit\u00e4t ist in jedem Moodle Kurs verf\u00fcgbar. Wenn ein Lehrender die Aktivit\u00e4t dem Kurs hinzuf\u00fcgt muss er dem Ordner einen Namen f\u00fcr die Moodle Instanz und einen f\u00fcr die ownCloud Instanz geben. Danach kann festlegt werden ob Lehrende des Kurses Zugriff auf alle erstellten Ordner haben. Eins der wichtigsten Integrationsszenarien ist, dass nur f\u00fcr Gruppen  von Studierenden ein Ordner erstellt wird. Dies ist m\u00f6glich, wenn der Lehrende den Zugriff auf bestimmte Gruppen beschr\u00e4nkt. In diesem Fall werden nur f\u00fcr die gew\u00e4hlten Gruppen einzelne Ordner erstellt.\n\n\nSicht der Studierenden\n\n\nWenn ein Ordner f\u00fcr einen Studierenden freigegeben wurde, sieht dieser die Aktivit\u00e4t in dem Kurs. W\u00e4hlt er diese aus, kann er sich den Ordner herunterladen, oder sich den Ordner in seine Instanz duplizieren. Hat der Studierende keinen Account in der ownCloud Instanz kann er den Ordner herunterladen jedoch nichts in den Ordner laden.", 
            "title": "Benutzung"
        }, 
        {
            "location": "/moodle/benutzung/#benutzung", 
            "text": "Plugins k\u00f6nnen in Moodle zus\u00e4tzlich installiert werden. Auf der  offiziellen Seite \nvon Moodle k\u00f6nnen alle zurzeit angebotenen Plugins gefunden werden. F\u00fcr mehr Informationen zur allgemeinen Installation von Moodle Plugins\nbenutzen sie die Dokumentation der  Moodle Seite .", 
            "title": "Benutzung"
        }, 
        {
            "location": "/moodle/benutzung/#installation", 
            "text": "Wenn sie die Plugins heruntergeladen haben und richtig platziert haben zeigt der Moodle Plugin Manager Ihnen die verf\u00fcgbaren Plugins an.\nSie ben\u00f6tigen in jedem Fall das oauth2_admin_tool, alle anderen Plugins sind von diesem abh\u00e4ngig.", 
            "title": "Installation"
        }, 
        {
            "location": "/moodle/benutzung/#admin-tool-oauth2sciebo", 
            "text": "", 
            "title": "Admin Tool oauth2sciebo"
        }, 
        {
            "location": "/moodle/benutzung/#admin-einstellungen", 
            "text": "Damit das OAuth 2 Protokoll reibungslos ablaufen kann, muss zuerst der Client in den Einstellungen registriert werden.  Hierf\u00fcr muss der Administrator das Formular des Plugins, das unter  Website-Administration Plugins Authentifizierung Sciebo OAuth 2.0 Configuration  zu finden ist, ausf\u00fcllen.   Als erstes Feld muss die Client ID eingegeben werden. Diese findet man in ownCloud, sobald ein neuer Client registriert wurde. Dasselbe gilt f\u00fcr das n\u00e4chste Feld, hier wird das Secret angegeben, dass sich auch aus der ownCloud App kopieren l\u00e4sst.   Nun werden die Einstellungen f\u00fcr den WebDAV Zugriff festgelegt.\nAls erstes wird die Adresse des ownCloud Servers angegeben.\nIm n\u00e4chsten Feld wird der Pfad zur WebDAV Schnittstelle angegeben in ownCloud endet diese typischerweise mit  remote.php/webdav/ .\nAls Protokolltyp kann http oder https angegeben werden. Wenn keine Angabe gemacht wird, wird von https ausgegangen.\nAls letztes kann der Port angegeben werden.", 
            "title": "Admin Einstellungen"
        }, 
        {
            "location": "/moodle/benutzung/#repository-sciebo", 
            "text": "", 
            "title": "Repository sciebo"
        }, 
        {
            "location": "/moodle/benutzung/#admin-einstellungen_1", 
            "text": "Sobald das Admin tool installiert wurde, kann das Repository installiert werden. Bitte beachten Sie, dass die oben genannten Eintr\u00e4ge get\u00e4tigt wurden, ansonsten funktioniert die Authentifizierung des Repositorys nicht. Repositorys Plugins m\u00fcssen in Moodle von einem Administrator unter dem Men\u00fcpunkt  Website-Administration PluginsRepositories \u00dcbersicht  aktiviert werden. Der Administrator kann dem Repository zus\u00e4tzlich unter  Einstellungen  einen globalen Namen geben.", 
            "title": "Admin Einstellungen"
        }, 
        {
            "location": "/moodle/benutzung/#nutzer-sicht", 
            "text": "Das Repository ist sowohl in den Kursen als auch f\u00fcr private Instanzen verf\u00fcgbar und muss nicht mehr hinzugef\u00fcgt werden. Kurs Administratoren k\u00f6nnen das Repository jedoch unter  Speicherorte  l\u00f6schen. Die Nutzung l\u00e4sst sich nicht auf bestimmte Nutzer oder Aktivit\u00e4ten im Kurs einschr\u00e4nken. Im File Picker muss man sich zun\u00e4chst anmelden.\nDanach sieht man nach der Anmeldung eine tabellarische Auflistung der vorhandenen Dateien:   Im roten Kasten sehen sie Buttons um den Inhalt neu zu laden, sich auszuloggen und nur als Admin sieht man den letzten Button in dem man die Einstellungen des OAuth2 admin_tool bearbeiten kann.", 
            "title": "Nutzer Sicht"
        }, 
        {
            "location": "/moodle/benutzung/#collaborative_folders", 
            "text": "", 
            "title": "collaborative_folders"
        }, 
        {
            "location": "/moodle/benutzung/#einstellungen", 
            "text": "", 
            "title": "Einstellungen"
        }, 
        {
            "location": "/moodle/benutzung/#admin-einstellungen_2", 
            "text": "F\u00fcr die Aktivit\u00e4t collaborative_folders wird ein technischer Nutzer der ownCloud Instanz ben\u00f6tigt. Bei diesem Nutzer werden alle Ordner die erstellt werden gespeichert. Um den Nutzer festzulegen muss in  Website-Administration Plugins Aktivit\u00e4ten collaborativefolders  ein technischer Nutzer mit Hilfe des OAuth2 Protokolls authentifizieren. \u00dcber einen Login Button werden Sie aufgefordert sich in ownCloud zu authentifizieren. Falls Sie nicht richtig weitergeleitet werden, sind die Einstellungen im Admin tool oauth2sciebo fehlerhaft, bitte \u00fcberpr\u00fcfen Sie diese. Achten Sie darauf, dass Sie sich nicht mit Ihrem normalen Account sondern mit dem technischen Nutzer anmelden.", 
            "title": "Admin Einstellungen"
        }, 
        {
            "location": "/moodle/benutzung/#sicht-des-lehrenden", 
            "text": "Die Aktivit\u00e4t ist in jedem Moodle Kurs verf\u00fcgbar. Wenn ein Lehrender die Aktivit\u00e4t dem Kurs hinzuf\u00fcgt muss er dem Ordner einen Namen f\u00fcr die Moodle Instanz und einen f\u00fcr die ownCloud Instanz geben. Danach kann festlegt werden ob Lehrende des Kurses Zugriff auf alle erstellten Ordner haben. Eins der wichtigsten Integrationsszenarien ist, dass nur f\u00fcr Gruppen  von Studierenden ein Ordner erstellt wird. Dies ist m\u00f6glich, wenn der Lehrende den Zugriff auf bestimmte Gruppen beschr\u00e4nkt. In diesem Fall werden nur f\u00fcr die gew\u00e4hlten Gruppen einzelne Ordner erstellt.", 
            "title": "Sicht des Lehrenden"
        }, 
        {
            "location": "/moodle/benutzung/#sicht-der-studierenden", 
            "text": "Wenn ein Ordner f\u00fcr einen Studierenden freigegeben wurde, sieht dieser die Aktivit\u00e4t in dem Kurs. W\u00e4hlt er diese aus, kann er sich den Ordner herunterladen, oder sich den Ordner in seine Instanz duplizieren. Hat der Studierende keinen Account in der ownCloud Instanz kann er den Ordner herunterladen jedoch nichts in den Ordner laden.", 
            "title": "Sicht der Studierenden"
        }
    ]
}