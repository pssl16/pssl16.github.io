{
    "docs": [
        {
            "location": "/", 
            "text": "sciebo@Learnweb\n\n\nDiese Website dokumentiert die Integration von \nsciebo\n in das \nLearnweb\n\nvon dem Projektseminar \nsciebo@Learnweb\n, das im Wintersemester 2016/17 an der \nWestf\u00e4lischen Wilhelms-Universit\u00e4t M\u00fcnster\n stattgefunden hat.\n\n\nSciebo ist ein Cloud-Dienst, der gemeinsam von 26 Hochschulen und Forschungseinrichtungen in NRW angeboten wird. Als Grundlage dient die Enterprise-Edition von \nownCloud\n.\nDas Learnweb ist ein auf der Open-Source-L\u00f6sung \nMoodle\n basierendes E-Learning System der Westf\u00e4lischen Wilhelms-Universit\u00e4t M\u00fcnster.\n\n\nEine m\u00f6gliche L\u00f6sung sollte dabei m\u00f6glichst allgemein einsetzbar sein, da die Kombination von Moodle und ownCloud an zahlreichen Universit\u00e4ten genutzt wird.\n\n\nAllgemeine Motivation f\u00fcr die Arbeit\n\n\nDie grunds\u00e4tzliche Motivation f\u00fcr das Projektseminar war es, die beiden Systeme \nsciebo\n und \nLearnweb\n passwortlos miteinander kommunizieren zu lassen. \nBedeutet, dass einmalig ein Passwort eingegeben werden muss, welches aber nicht im Klartext auf dem jeweils anderen System gespeichert wird. Der Zugriff sollte also \u00fcber ein tokenbasiertes Authentifizierungsverfahren wie zum Beispiel OAuth 2.0 ablaufen. \nDadurch sollte es unter Anderem erm\u00f6glicht werden, dass Dateien aus Sciebo im Learnweb abgerufen werden k\u00f6nnen und kollaborative Ordner in sciebo vom Learnweb aus erstellt werden k\u00f6nnen.\n\n\nIntegrationsszenarien (User Stories)\n\n\nAls Integrationsszenarien der Systeme wurden verschiedene User Stories entwickelt.\nDiese haben wir nach Schwierigkeit, Interesse, Benutzbarkeit und Implementationsaufwand priorisiert.\nAls Integrationsrichtung konzentrierte wir uns auf die Richtung Learnweb \n sciebo.\n\n\nRealisierte Szenarien\n\n\n1. Als \nNutzer\n m\u00f6chte ich OAuth2 benutzen k\u00f6nnen, um mich im Learnweb als Sciebo Nutzer anzumelden.\n\n\nDieser Use Case implementiert die grundlegende Authentifizierung mit dem \nOAuth 2.0\n Verfahren.\nIm Rahmen unserer Vorbereiungsphase auf das Projektseminar haben wir verschiedene Authentifizierungsmethoden evaluiert. Im Abschnitt\n \nAuthentifizierung und Autorisierung\n finden sie hierf\u00fcr genauere Informationen. Hierf\u00fcr ist in Moodle das\n \nAdmin Tool\n implementiert worden. Es \u00fcbernimmt s\u00e4mtliche Aufgaben der Authentifizierung. Alle anderen Plugins nutzen dieses Tool.\n In OwnCloud wurde hierf\u00fcr eine \nApp\n entwickelt.\n\n\n2. Als \nNutzer\n m\u00f6chte ich in der Dateiauswahl im Learnweb eine Datei aus meiner sciebo Instanz hochladen.\n\n\nDer vorherige Use Case war f\u00fcr den Benutzer der Moodle Instanz noch nicht sichtbar. Das wichtigste Anwendungsszenario ist das Nutzer im Learnweb Dateien aus ihrer\nSciebo Account hochladen k\u00f6nnen. Hierf\u00fcr haben wir in Moodle ein \nRepository-Plugins\n entwickelt. Sobald das Reposiotory einer Moodle\nInstanz hinzugef\u00fcgt wurde kann der Nutzer \u00fcber einen anmelde Button Moodle autorisieren Dateien aus dem privaten sciebo account anzuzeigen\nund mit Hilfe des File Pickers k\u00f6nnen nun Dateien ausgew\u00e4hlt werden.\n\n\n  \nTODO:\n BILDER! (Wenn get_listing wieder funktioniert)\n\n\n\n3. Als \nNutzer\n m\u00f6chte ich in der Dateiauswahl im Learnweb eine Datei aus meiner sciebo Instanz verlinken.\n\n\nEine Erweiterung des vorherigen Szenarios ist die Verlinkung von Dateien. Hier wird zu der bestehenden Datei ein public-link erstellt.\nDieser kann nun von Nutzern angeklickt werden. Diese Funktionalit\u00e4t ist auch Teil des \nRepository-Plugins\n. Das Verlinken ist\njedoch nur in der Aktivit\u00e4t URL verf\u00fcgbar.\n\n\n4. Als \nLehrender\n m\u00f6chte ich Studierenden oder Gruppen von Studierenden Ordner f\u00fcr kollaboratives Arbeiten bereitstellen.\n\n\nDie letzte User Story die wir implementiert haben, wurde vermehrt von Lehrenden der Universit\u00e4t M\u00fcnster nachgefragt. Ein Lehrender kann mir Hilfe der\nAktivit\u00e4t \ncollaborativefolders\n in einem Kurs Ordner erstellen auf den Studierende Zugriff haben und den sie ihrem sciebo account hinzuf\u00fcgen k\u00f6nnen.\n\n\nWeitere User Storys die jedoch nicht im Rahmen diese Projektseminars implementiert werden konnten finden sie unter dem Abschnitt\n\nWeitere Anwendungsszenarien\n.\n\n\nAuthentifizierung und Autorisierung\n\n\nGrundlegend f\u00fcr die Integration beider Systeme ist die Authentifizierung und Autorisierung. Unter den g\u00e4ngigen Verfahren, die untersucht wurden, befinden sich:\n\n\n\n\nOAuth 2.0\n\n\nJSON Web Tokens\n\n\nFederated Single Sign-on mit beispielsweise \nShibboleth\n\n\n\n\nF\u00fcr das Projekt wurde das OAuth 2.0 Verfahren ausgew\u00e4hlt, da mit ihm ein standardisiertes Verfahren zur tokenbasierten Authentifizierung und\nAutorisierung vorliegt, das sich gut in bestehende Applikationen auf Basis vieler verschiedener Programmiersprachen einf\u00fcgen l\u00e4sst und damit keine weiteren Anforderungen an die Infrastruktur stellt.\n\n\nOAuth 2.0\n\n\nDer allgemeine \nOAuth 2.0 Protokollablauf\n ist in der nachfolgenden Abbildung dargestellt.\n\n\n\n\nZun\u00e4chst muss sich der Client (Learnweb), der im Namen des Resource Owners (sciebo Nutzer) auf eine gesch\u00fctzte Ressource auf dem Resource Server (sciebo) zugreifen m\u00f6chte,\nbei dem Authorization Server (sciebo) registrieren. Danach werden nach dem Protokoll folgende Schritte durchlaufen:\n\n\n\n\nAuthorization Request: Der Client fordert eine Autorisierung vom Resource Owner an.\n\n\nAuthorization Response: Der Client erh\u00e4lt eine Autorisierungsgenehmigung vom Resource Owner. Die Autorisierung kann \u00fcber eine\nder vier Autorisierungsgenehmigungen (authorization grant type) erfolgen, oder es wird ein erweiterer Genehmigungsprozess verwendet.\n\n\nAccess Token Request: Der Client fordert ein Access Token vom Authorization Server an. Hierf\u00fcr nutzt er die Autorisierungsgenehmigung vom Resource Owner.\n\n\nAccess Token Response: Der Authorization Server authentifiziert den Client und pr\u00fcft die Autorisierungsgenehmigung. Ist die Pr\u00fcfung erfolgreich, wird ein Access Token ausgestellt.\n\n\nAnfrage mittels Access Token: Der Client fragt die gesch\u00fctzten Daten beim Resource Server an. Zur Authentifizierung benutzt er den Access Token.\n\n\nZugriff auf gesch\u00fctzte Ressourcen: Der Resource Server pr\u00fcft den Access Token und stellt, wenn g\u00fcltig, die gew\u00fcnschten Daten zur Verf\u00fcgung.\n\n\n\n\nKomponenten\n\n\n\n  \nTODO:\n W\u00fcrde ich nicht in die Index packen, sondern einzelne Komponenten nur in dem Moodle und ownCloud Unterpunkt beschreiben.\n\n\n\nownCloud\n\n\nDie Komponenten, die wir ben\u00f6tigen um eine L\u00f6sung anzubieten, sind die von uns implementierte oauth2 App und der ownCloud Core mit \u00c4nderungen aus unserem Pull request, \ndamit die oauth2 App die volle Funktionalit\u00e4t bereitstellen kann. Die oauth2 App implementiert den OAuth 2.0 Prozessfluss. Sie agiert als Endpunkt f\u00fcr die Authorisierung und die Bereitstellung von Access Tokens und Refresh Tokens. \nDie App ist also das Mittel zur Verbindung von Resource Owner, Authorization Server und auch Resource Server mit dem Client.\n\n\nMoodle\n\n\n\n  \nTODO:\n Bestandteile der L\u00f6sung in moodle auflisten und kurz die Funktion anschneiden.\n\n\n\n\nZusammenspiel\n\n\n\n  \nTODO:\n Wie arbeiten die einzelnen Komponenten zusammen, um das Problem zu l\u00f6sen? (WebDAV: Wie wird der\n  komplette OAuth Protokollablauf erf\u00fcllt?).\n\n\n\n\nWeitere Anwendungsszenarien\n\n\nIm Rahmen unseres Projektseminars haben wir uns auf die f\u00fcr uns wichtigsten UseCases konzentriert. Im Folgenden werden weitere Use Cases erl\u00e4utert\n\u00fcber deren Implementierung wir nachgedacht haben und die eine Erweiterung zu den bestehenden Use Cases bilden k\u00f6nnten.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich auf einen Button klicken, um hochgeladene Dateien zu aktualisieren.\n\n\n\n\n\n\nAls \nStudierender\n m\u00f6chte ich Dateien aus dem Learnweb direkt in meiner sciebo Instanz speichern k\u00f6nnen.\n\n\n\n\n\n\nAls \nStudierender\n m\u00f6chte ich anderen Studierenden Schreib- und Lese-Rechte geben um kollaborativ zu arbeiten.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich Nutzern auf Modul-Basis das Recht entziehen eine Datei zu verlinken.\n\n\n\n\n\n\nAls \nNutzer\n m\u00f6chte ich in der Dateiauswahl im Learnweb einen Ordner aus meiner sciebo Instanz hochladen.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich in der Dateiauswahl im Learnweb einen Ordner aus meiner sciebo Instanz verlinken.\n\n\n\n\n\n\nAls \nStudierender\n m\u00f6chte ich Lehrenden Schreib- oder Lese-Rechte auf mein Dokument geben k\u00f6nnen um Feedback zu erhalten.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich die M\u00f6glichkeit haben, einen Zielordner in Sciebo zur Speicherung auszuw\u00e4hlen, um Abgaben herunterzuladen.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich sciebo als prim\u00e4ren Speicher f\u00fcr alle Dateien im Kurs verwenden k\u00f6nnen.\n\n\n\n\n\n\nAls \nLehrender\n m\u00f6chte ich in Sciebo die Teilen-Funktion nutzen, um Dateien oder Dokumente f\u00fcr Kursteilnehmer freigeben zu k\u00f6nnen.\n\n\n\n\n\n\nZusammenfassung\n\n\n\n  \nTODO:\n Ausf\u00fchrung.\n\n\nErf\u00fcllungsgrad der User Stories, Geschaffene Funktionalit\u00e4ten, (bekannte, ggf. bewusst gew\u00e4hlte) Einschr\u00e4nkungen, Ausblick auf weitere Entwicklungsm\u00f6glichkeiten. Einschr\u00e4nkungen festhalten; den Rest ganz zum Schluss des PS beschreiben", 
            "title": "Home"
        }, 
        {
            "location": "/#sciebolearnweb", 
            "text": "Diese Website dokumentiert die Integration von  sciebo  in das  Learnweb \nvon dem Projektseminar  sciebo@Learnweb , das im Wintersemester 2016/17 an der  Westf\u00e4lischen Wilhelms-Universit\u00e4t M\u00fcnster  stattgefunden hat.  Sciebo ist ein Cloud-Dienst, der gemeinsam von 26 Hochschulen und Forschungseinrichtungen in NRW angeboten wird. Als Grundlage dient die Enterprise-Edition von  ownCloud .\nDas Learnweb ist ein auf der Open-Source-L\u00f6sung  Moodle  basierendes E-Learning System der Westf\u00e4lischen Wilhelms-Universit\u00e4t M\u00fcnster.  Eine m\u00f6gliche L\u00f6sung sollte dabei m\u00f6glichst allgemein einsetzbar sein, da die Kombination von Moodle und ownCloud an zahlreichen Universit\u00e4ten genutzt wird.", 
            "title": "sciebo@Learnweb"
        }, 
        {
            "location": "/#allgemeine-motivation-fur-die-arbeit", 
            "text": "Die grunds\u00e4tzliche Motivation f\u00fcr das Projektseminar war es, die beiden Systeme  sciebo  und  Learnweb  passwortlos miteinander kommunizieren zu lassen. \nBedeutet, dass einmalig ein Passwort eingegeben werden muss, welches aber nicht im Klartext auf dem jeweils anderen System gespeichert wird. Der Zugriff sollte also \u00fcber ein tokenbasiertes Authentifizierungsverfahren wie zum Beispiel OAuth 2.0 ablaufen. \nDadurch sollte es unter Anderem erm\u00f6glicht werden, dass Dateien aus Sciebo im Learnweb abgerufen werden k\u00f6nnen und kollaborative Ordner in sciebo vom Learnweb aus erstellt werden k\u00f6nnen.", 
            "title": "Allgemeine Motivation f\u00fcr die Arbeit"
        }, 
        {
            "location": "/#integrationsszenarien-user-stories", 
            "text": "Als Integrationsszenarien der Systeme wurden verschiedene User Stories entwickelt.\nDiese haben wir nach Schwierigkeit, Interesse, Benutzbarkeit und Implementationsaufwand priorisiert.\nAls Integrationsrichtung konzentrierte wir uns auf die Richtung Learnweb   sciebo.", 
            "title": "Integrationsszenarien (User Stories)"
        }, 
        {
            "location": "/#realisierte-szenarien", 
            "text": "", 
            "title": "Realisierte Szenarien"
        }, 
        {
            "location": "/#1-als-nutzer-mochte-ich-oauth2-benutzen-konnen-um-mich-im-learnweb-als-sciebo-nutzer-anzumelden", 
            "text": "Dieser Use Case implementiert die grundlegende Authentifizierung mit dem  OAuth 2.0  Verfahren.\nIm Rahmen unserer Vorbereiungsphase auf das Projektseminar haben wir verschiedene Authentifizierungsmethoden evaluiert. Im Abschnitt\n  Authentifizierung und Autorisierung  finden sie hierf\u00fcr genauere Informationen. Hierf\u00fcr ist in Moodle das\n  Admin Tool  implementiert worden. Es \u00fcbernimmt s\u00e4mtliche Aufgaben der Authentifizierung. Alle anderen Plugins nutzen dieses Tool.\n In OwnCloud wurde hierf\u00fcr eine  App  entwickelt.", 
            "title": "1. Als Nutzer m\u00f6chte ich OAuth2 benutzen k\u00f6nnen, um mich im Learnweb als Sciebo Nutzer anzumelden."
        }, 
        {
            "location": "/#2-als-nutzer-mochte-ich-in-der-dateiauswahl-im-learnweb-eine-datei-aus-meiner-sciebo-instanz-hochladen", 
            "text": "Der vorherige Use Case war f\u00fcr den Benutzer der Moodle Instanz noch nicht sichtbar. Das wichtigste Anwendungsszenario ist das Nutzer im Learnweb Dateien aus ihrer\nSciebo Account hochladen k\u00f6nnen. Hierf\u00fcr haben wir in Moodle ein  Repository-Plugins  entwickelt. Sobald das Reposiotory einer Moodle\nInstanz hinzugef\u00fcgt wurde kann der Nutzer \u00fcber einen anmelde Button Moodle autorisieren Dateien aus dem privaten sciebo account anzuzeigen\nund mit Hilfe des File Pickers k\u00f6nnen nun Dateien ausgew\u00e4hlt werden. \n   TODO:  BILDER! (Wenn get_listing wieder funktioniert)", 
            "title": "2. Als Nutzer m\u00f6chte ich in der Dateiauswahl im Learnweb eine Datei aus meiner sciebo Instanz hochladen."
        }, 
        {
            "location": "/#3-als-nutzer-mochte-ich-in-der-dateiauswahl-im-learnweb-eine-datei-aus-meiner-sciebo-instanz-verlinken", 
            "text": "Eine Erweiterung des vorherigen Szenarios ist die Verlinkung von Dateien. Hier wird zu der bestehenden Datei ein public-link erstellt.\nDieser kann nun von Nutzern angeklickt werden. Diese Funktionalit\u00e4t ist auch Teil des  Repository-Plugins . Das Verlinken ist\njedoch nur in der Aktivit\u00e4t URL verf\u00fcgbar.", 
            "title": "3. Als Nutzer m\u00f6chte ich in der Dateiauswahl im Learnweb eine Datei aus meiner sciebo Instanz verlinken."
        }, 
        {
            "location": "/#4-als-lehrender-mochte-ich-studierenden-oder-gruppen-von-studierenden-ordner-fur-kollaboratives-arbeiten-bereitstellen", 
            "text": "Die letzte User Story die wir implementiert haben, wurde vermehrt von Lehrenden der Universit\u00e4t M\u00fcnster nachgefragt. Ein Lehrender kann mir Hilfe der\nAktivit\u00e4t  collaborativefolders  in einem Kurs Ordner erstellen auf den Studierende Zugriff haben und den sie ihrem sciebo account hinzuf\u00fcgen k\u00f6nnen.  Weitere User Storys die jedoch nicht im Rahmen diese Projektseminars implementiert werden konnten finden sie unter dem Abschnitt Weitere Anwendungsszenarien .", 
            "title": "4. Als Lehrender m\u00f6chte ich Studierenden oder Gruppen von Studierenden Ordner f\u00fcr kollaboratives Arbeiten bereitstellen."
        }, 
        {
            "location": "/#authentifizierung-und-autorisierung", 
            "text": "Grundlegend f\u00fcr die Integration beider Systeme ist die Authentifizierung und Autorisierung. Unter den g\u00e4ngigen Verfahren, die untersucht wurden, befinden sich:   OAuth 2.0  JSON Web Tokens  Federated Single Sign-on mit beispielsweise  Shibboleth   F\u00fcr das Projekt wurde das OAuth 2.0 Verfahren ausgew\u00e4hlt, da mit ihm ein standardisiertes Verfahren zur tokenbasierten Authentifizierung und\nAutorisierung vorliegt, das sich gut in bestehende Applikationen auf Basis vieler verschiedener Programmiersprachen einf\u00fcgen l\u00e4sst und damit keine weiteren Anforderungen an die Infrastruktur stellt.", 
            "title": "Authentifizierung und Autorisierung"
        }, 
        {
            "location": "/#oauth-20", 
            "text": "Der allgemeine  OAuth 2.0 Protokollablauf  ist in der nachfolgenden Abbildung dargestellt.   Zun\u00e4chst muss sich der Client (Learnweb), der im Namen des Resource Owners (sciebo Nutzer) auf eine gesch\u00fctzte Ressource auf dem Resource Server (sciebo) zugreifen m\u00f6chte,\nbei dem Authorization Server (sciebo) registrieren. Danach werden nach dem Protokoll folgende Schritte durchlaufen:   Authorization Request: Der Client fordert eine Autorisierung vom Resource Owner an.  Authorization Response: Der Client erh\u00e4lt eine Autorisierungsgenehmigung vom Resource Owner. Die Autorisierung kann \u00fcber eine\nder vier Autorisierungsgenehmigungen (authorization grant type) erfolgen, oder es wird ein erweiterer Genehmigungsprozess verwendet.  Access Token Request: Der Client fordert ein Access Token vom Authorization Server an. Hierf\u00fcr nutzt er die Autorisierungsgenehmigung vom Resource Owner.  Access Token Response: Der Authorization Server authentifiziert den Client und pr\u00fcft die Autorisierungsgenehmigung. Ist die Pr\u00fcfung erfolgreich, wird ein Access Token ausgestellt.  Anfrage mittels Access Token: Der Client fragt die gesch\u00fctzten Daten beim Resource Server an. Zur Authentifizierung benutzt er den Access Token.  Zugriff auf gesch\u00fctzte Ressourcen: Der Resource Server pr\u00fcft den Access Token und stellt, wenn g\u00fcltig, die gew\u00fcnschten Daten zur Verf\u00fcgung.", 
            "title": "OAuth 2.0"
        }, 
        {
            "location": "/#komponenten", 
            "text": "TODO:  W\u00fcrde ich nicht in die Index packen, sondern einzelne Komponenten nur in dem Moodle und ownCloud Unterpunkt beschreiben.", 
            "title": "Komponenten"
        }, 
        {
            "location": "/#owncloud", 
            "text": "Die Komponenten, die wir ben\u00f6tigen um eine L\u00f6sung anzubieten, sind die von uns implementierte oauth2 App und der ownCloud Core mit \u00c4nderungen aus unserem Pull request, \ndamit die oauth2 App die volle Funktionalit\u00e4t bereitstellen kann. Die oauth2 App implementiert den OAuth 2.0 Prozessfluss. Sie agiert als Endpunkt f\u00fcr die Authorisierung und die Bereitstellung von Access Tokens und Refresh Tokens. \nDie App ist also das Mittel zur Verbindung von Resource Owner, Authorization Server und auch Resource Server mit dem Client.", 
            "title": "ownCloud"
        }, 
        {
            "location": "/#moodle", 
            "text": "TODO:  Bestandteile der L\u00f6sung in moodle auflisten und kurz die Funktion anschneiden.", 
            "title": "Moodle"
        }, 
        {
            "location": "/#zusammenspiel", 
            "text": "TODO:  Wie arbeiten die einzelnen Komponenten zusammen, um das Problem zu l\u00f6sen? (WebDAV: Wie wird der\n  komplette OAuth Protokollablauf erf\u00fcllt?).", 
            "title": "Zusammenspiel"
        }, 
        {
            "location": "/#weitere-anwendungsszenarien", 
            "text": "Im Rahmen unseres Projektseminars haben wir uns auf die f\u00fcr uns wichtigsten UseCases konzentriert. Im Folgenden werden weitere Use Cases erl\u00e4utert\n\u00fcber deren Implementierung wir nachgedacht haben und die eine Erweiterung zu den bestehenden Use Cases bilden k\u00f6nnten.    Als  Lehrender  m\u00f6chte ich auf einen Button klicken, um hochgeladene Dateien zu aktualisieren.    Als  Studierender  m\u00f6chte ich Dateien aus dem Learnweb direkt in meiner sciebo Instanz speichern k\u00f6nnen.    Als  Studierender  m\u00f6chte ich anderen Studierenden Schreib- und Lese-Rechte geben um kollaborativ zu arbeiten.    Als  Lehrender  m\u00f6chte ich Nutzern auf Modul-Basis das Recht entziehen eine Datei zu verlinken.    Als  Nutzer  m\u00f6chte ich in der Dateiauswahl im Learnweb einen Ordner aus meiner sciebo Instanz hochladen.    Als  Lehrender  m\u00f6chte ich in der Dateiauswahl im Learnweb einen Ordner aus meiner sciebo Instanz verlinken.    Als  Studierender  m\u00f6chte ich Lehrenden Schreib- oder Lese-Rechte auf mein Dokument geben k\u00f6nnen um Feedback zu erhalten.    Als  Lehrender  m\u00f6chte ich die M\u00f6glichkeit haben, einen Zielordner in Sciebo zur Speicherung auszuw\u00e4hlen, um Abgaben herunterzuladen.    Als  Lehrender  m\u00f6chte ich sciebo als prim\u00e4ren Speicher f\u00fcr alle Dateien im Kurs verwenden k\u00f6nnen.    Als  Lehrender  m\u00f6chte ich in Sciebo die Teilen-Funktion nutzen, um Dateien oder Dokumente f\u00fcr Kursteilnehmer freigeben zu k\u00f6nnen.", 
            "title": "Weitere Anwendungsszenarien"
        }, 
        {
            "location": "/#zusammenfassung", 
            "text": "TODO:  Ausf\u00fchrung. \nErf\u00fcllungsgrad der User Stories, Geschaffene Funktionalit\u00e4ten, (bekannte, ggf. bewusst gew\u00e4hlte) Einschr\u00e4nkungen, Ausblick auf weitere Entwicklungsm\u00f6glichkeiten. Einschr\u00e4nkungen festhalten; den Rest ganz zum Schluss des PS beschreiben", 
            "title": "Zusammenfassung"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/", 
            "text": "Technische Umsetzung\n\n\nMotivation\n\n\nDa man m\u00f6glichst keine neue Schnittstelle implementieren wollte, war es das Ziel, die bestehende WebDAV Schnittstelle um OAuth 2.0 zu erweitern. Die WebDAV Schnittstelle ist als \nownCloud App\n realisiert worden. Auf der anderen Seite musste das OAuth 2.0 Protokoll mit seinen Schnittstellen bereitgestellt werden, um die Authentifizierung in der WebDAV App um OAuth 2.0 zu erweitern zu k\u00f6nnen. Daf\u00fcr wurde eine weitere ownCloud App implementiert.\n\n\nImplementierung der \noauth2\n App\n\n\nIn der App sollte der h\u00e4ufig f\u00fcr Webapplikationen eingesetzte \nAuthorization Code Flow\n implementiert werden. Dazu mussten folgende User Stories umgesetzt werden:\n\n\n\n\nClientregistrierung:\n Als ownCloud-Administrator m\u00f6chte ich Clients in den Administrator-Einstellungen hinzuf\u00fcgen und l\u00f6schen k\u00f6nnen, um die Kontrolle \u00fcber erlaubte Clients zu haben.\n\n\nAuthorization URL:\n Als Client-Entwickler m\u00f6chte ich eine Authorization URL zur Verf\u00fcgung haben, um Authorization Codes anfordern zu k\u00f6nnen.\n\n\nAccess Token URL:\n Als Client-Entwickler m\u00f6chte ich eine Access Token URL zur Verf\u00fcgung haben, um Access Tokens anfordern zu k\u00f6nnen.\n\n\nVerwaltung autorisierter Applikationen\n: Als ownCloud-Nutzer m\u00f6chte ich in den pers\u00f6nlichen Einstellungen autorisierte Applikationen verwalten k\u00f6nnen, um einen \u00dcberblick zu haben und Autorisierungen widerrufen zu k\u00f6nnen.\n\n\n\n\nDatenmodell\n\n\nZun\u00e4chst musste ein Datenmodell zur Speicherung der ben\u00f6tigten Daten aufgestellt werden. Gem\u00e4\u00df dem Authorization Code Flow wurden folgende Entit\u00e4ten mit Attributen definiert:\n\n\n\n\nclient\n:\n Die Applikation, die f\u00fcr den Zugriff auf die WebDAV Schnittstelle autorisiert werden soll.\n\n\nidentifier\n: Zeichenkette, die einen Client eindeutig identifiziert.\n\n\nsecret\n: Zeichenkette, mit der ein Client sich beim Anfordern eines Access Tokens authentifizieren kann.\n\n\nredirect_uri\n: URI, an die nach erfolgter Autorisierung des Nutzers weitergeleitet wird.\n\n\n\n\n\n\nauthorization_code\n:\n Ein \nAuthorization Grant\n, mit dem der Client die Autorisierung des Nutzers darlegen und somit ein Access Token anfordern kann.\n\n\ncode\n: Zeichenkette, die als Authorization Code dient.\n\n\nclient_id\n: Client Identifier des Clients, f\u00fcr den der Authorization Code ausgegeben wird.\n\n\nuser_id\n: User ID des ownCloud-Nutzers, der den Client autorisiert hat.\n\n\nexpires\n: Zeitpunkt, zu dem der Authorization Code ung\u00fcltig wird (optional).\n\n\n\n\n\n\naccess_token\n:\n Eine Zeichenkette, die den Zugriff auf die WebDAV Schnittstelle erlaubt.\n\n\ncode\n: Zeichenkette, die als Access Token dient.\n\n\nclient_id\n: Client Identifier des Clients, f\u00fcr den der Access Token ausgegeben wird.\n\n\nuser_id\n: User ID des ownCloud-Nutzers, der den Client autorisiert hat.\n\n\nexpires\n: Zeitpunkt, zu dem der Access Token ung\u00fcltig wird (optional).\n\n\n\n\n\n\nrefresh_token\n:\n Eine Zeichenkette, mit der ein abgelaufener Access Token gegen einen neuen ausgetauscht werden kann.\n\n\ncode\n: Zeichenkette, die als Refresh Token dient.\n\n\nclient_id\n: Client Identifier des Clients, f\u00fcr den der Access Token ausgegeben wird.\n\n\nuser_id\n: User ID des ownCloud-Nutzers, der den Client autorisiert hat.\n\n\nexpires\n: Zeitpunkt, zu dem der Refresh Token ung\u00fcltig wird (optional).\n\n\n\n\n\n\n\n\nFolgendes Entity-Relationship-Modell fasst das Datenmodell nochmal grafisch zusammen.\n\n\n\n\nMapper und Entities\n\n\nF\u00fcr den Datenbank-Zugriff im PHP-Code ist es in ownCloud m\u00f6glich, \nMapper\n und \nEntities\n zu schreiben. Dadurch werden Tupel in einer Datenbank-Tabelle automatisch in ein Objekt umgewandelt.\n\n\nFolgendes Codebeispiel zeigt am Beispiel des Entitys \nClient\n, wie eine PHP-Klasse dazu aussehen muss.\n\n\n?php\nnamespace OCA\\OAuth2\\Db;\n\nuse OCP\\AppFramework\\Db\\Entity;\n\n/**\n * Class Client\n *\n * @method string getIdentifier()\n * @method void setIdentifier(string $identifier)\n * @method string getSecret()\n * @method void setSecret(string $secret)\n * @method string getRedirectUri()\n * @method void setRedirectUri(string $redirectUri)\n * @method string getName()\n * @method void setName(string $name)\n */\nclass Client extends Entity {\n\n    protected $identifier;\n    protected $secret;\n    protected $redirectUri;\n    protected $name;\n\n    public function __construct() {\n        $this-\naddType('id', 'int');\n        $this-\naddType('identifier', 'string');\n        $this-\naddType('secret', 'string');\n        $this-\naddType('redirect_uri', 'string');\n        $this-\naddType('name', 'string');\n    }\n\n}\n\n\n\n\nWichtig ist, dass die Klasse von \nEntity\n erbt und sowohl der Klassenname als auch die Attribute mit denen der Tabelle \u00fcbereinstimmen. Pascal bzw. Camel case im PHP-Code wird automatisch zu Snake case f\u00fcr die Datenbank umgewandelt. Getter und Setter werden ebenfalls automatisch generiert. Die PHPDoc Kommentare dienen lediglich dazu, in der Entwicklungsumgebung eine automatische Vervollst\u00e4ndigung zu haben. Die Angabe von \nTypen\n im Konstruktor dienen dazu, beim Lesen aus der Datenbank die richtige Umwandlung zu erhalten.\n\n\nDas folgende Codebeispiel zeigt einen Ausschnitt aus dem zur \nClient\n Entity geh\u00f6renden Mapper.\n\n\n?php\nnamespace OCA\\OAuth2\\Db;\n\nuse InvalidArgumentException;\nuse OCP\\AppFramework\\Db\\Entity;\nuse OCP\\IDb;\nuse OCP\\AppFramework\\Db\\Mapper;\n\nclass ClientMapper extends Mapper {\n\n    /**\n     * ClientMapper constructor.\n     *\n     * @param IDb $db Database Connection.\n     */\n    public function __construct(IDb $db) {\n        parent::__construct($db, 'oauth2_clients');\n    }\n\n    /**\n     * Selects a client by its ID.\n     *\n     * @param int $id The client's ID.\n     *\n     * @return Entity The client entity.\n     *\n     * @throws \\OCP\\AppFramework\\Db\\DoesNotExistException if not found.\n     * @throws \\OCP\\AppFramework\\Db\\MultipleObjectsReturnedException if more than one result.\n     */\n    public function find($id) {\n        if (!is_int($id)) {\n            throw new InvalidArgumentException('id must not be null');\n        }\n\n        $sql = 'SELECT * FROM `' . $this-\ntableName . '` WHERE `id` = ?';\n        return $this-\nfindEntity($sql, array($id), null, null);\n    }\n\n    /**\n     * Selects clients by the given user ID.\n     *\n     * @param string $userId The user ID.\n     *\n     * @return array The client entities.\n     */\n    public function findByUser($userId) {\n        if (!is_string($userId)) {\n            throw new InvalidArgumentException('userId must not be null');\n        }\n\n        $sql = 'SELECT * FROM `' . $this-\ntableName . '` '\n            . 'WHERE `id` IN ( '\n                . 'SELECT `client_id` FROM `oc_oauth2_authorization_codes` WHERE `user_id` = ? '\n                . 'UNION '\n                . 'SELECT `client_id` FROM `oc_oauth2_access_tokens` WHERE `user_id` = ? '\n            .')';\n        return $this-\nfindEntities($sql, array($userId, $userId), null, null);\n    }\n\n}\n\n\n\n\nBeim Mapper ist es wichtig, dass die Klasse von \nMapper\n erbt und eine Entity-Klasse zu ihm existiert. Dazu wird das Wort vor \u201eMapper\u201c als Entityname verwendet. Im Konstruktur wird der Tabellenname angegeben. Die beiden Funktionen \nfind\n und \nfindByUser\n demonstrieren \nSELECT\n-Anweisungen. Dazu wird die SQL-Anweisungen zusammen mit ben\u00f6tigten Parametern an \nfindEntity\n bzw. \nfindEntities\n \u00fcbergeben, abh\u00e4ngig davon, ob mehrere Entities im Ergebnis enthalten sein sollten. Funktionen zum l\u00f6schen, einf\u00fcgen und updaten werden von der Oberklasse bereits implementiert und mussten nicht angepasst werden.\n\n\nSchnittstellen und Routes\n\n\nUm in einer ownCloud App Schnittstellen anzubieten, m\u00fcssen \nRoutes\n registriert werden. Zur Umsetzung der erw\u00e4hnten User Stories waren folgende Routes notwendig:\n\n\n\n\n\n\n\n\nMethode\n\n\nEndpunkt\n\n\nBeschreibung\n\n\n\n\n\n\n\n\n\n\nGET\n\n\nauthorize\n\n\nEndpunkt, zu dem der Client den Nutzer weiterleitet, um die Autorisierung anzufragen (Authorization URL).\n\n\n\n\n\n\nPOST\n\n\nauthorize\n\n\nEndpunkt, der aufgerufen wird, sobald der Nutzer den Client autorisiert hat.\n\n\n\n\n\n\nPOST\n\n\napi/v1/token\n\n\nEndpunkt, an dem ein Access Token angefordert wird (Access Token URL).\n\n\n\n\n\n\nPOST\n\n\nclients\n\n\nEndpunkt, durch den der Administrator einen Client hinzuf\u00fcgen kann.\n\n\n\n\n\n\nPOST\n\n\nclients/{id}/delete\n\n\nEndpunkt, durch den der Administrator den Client mit der ID \nid\n l\u00f6schen kann.\n\n\n\n\n\n\nPOST\n\n\nclients/{id}/revoke\n\n\nEndpunkt, durch den der Nutzer die Autorisierung des Clients mit der ID \nid\n widerrufen kann.\n\n\n\n\n\n\n\n\nRegistriert werden die Routes in der Datei \nroutes.php\n, indem ein Array mit den Routes zur\u00fcckgegeben wird. Nachfolgendes Codebeispiel zeigt einige der obigen Routes:\n\n\n?php\nreturn [\n    'routes' =\n [\n        ['name' =\n 'page#authorize', 'url' =\n '/authorize', 'verb' =\n 'GET'],\n        ['name' =\n 'o_auth_api#generate_token', 'url' =\n '/api/v1/token', 'verb' =\n 'POST'],\n        ['name' =\n 'settings#deleteClient', 'url' =\n '/clients/{id}/delete', 'verb' =\n 'POST']\n    ]\n];\n\n\n\n\n\nDurch \nname\n wird f\u00fcr jede Route der Name des dazugeh\u00f6rigen \nControllers\n sowie die aufzurufende Funktion angegeben. Vor dem \n#\n-Zeichen steht der Controllername in Snake case und hinter dem \n#\n-Zeichen steht der Funktionsname (ebenfalls in Snake case). Mithilfe von \nurl\n wird der Endpunkt festgelegt und \nverb\n definiert die HTTP-Methode.\n\n\nController\n\n\nWenn an einem Endpunkt eine HTTP-Anfrage ankommt, so wird der in den Routes definierte \nController\n aufgerufen. Wichtig ist hierbei, dass von der Klasse \nController\n oder einer Unterklasse wie \nApiController\n geerbt wird.\n\n\nF\u00fcr den Controller notwendige Parameter wie \nMapper\n k\u00f6nnen im Konstruktor als Parameter angegeben und so durch \nDependency Injection\n erhalten werden. Nachfolgendes Codebeispiel zeigt den Konstruktor vom \nPageController\n.\n\n\n/**\n * PageController constructor.\n * \n * @param string $AppName The name of the app.\n * @param IRequest $request The request.\n * @param ClientMapper $clientMapper The client mapper.\n * @param AuthorizationCodeMapper $authorizationCodeMapper The authorization code mapper.\n * @param string $UserId The user ID.\n */\npublic function __construct($AppName, IRequest $request, ClientMapper $clientMapper,\n    AuthorizationCodeMapper $authorizationCodeMapper, $UserId) {\n    parent::__construct($AppName, $request);\n\n    $this-\nclientMapper = $clientMapper;\n    $this-\nauthorizationCodeMapper = $authorizationCodeMapper;\n    $this-\nuserId = $UserId;\n}\n\n\n\n\nDie hier notwendigen Parameter sind der Name der App, eine \nClientMapper\n Instanz, eine \nAuthorizationCodeMapper\n Instanz und die ID des Nutzers, um bei der Autorisierung des Clients speichern zu k\u00f6nnen, welcher Nutzers dies veranlasst hat.\n\n\nDie mit den Routes verkn\u00fcpften Funktionen k\u00f6nnen zur Zugriffskontrolle mit \nPHPDoc Annotationen\n versehen werden. Folgendes Codebeispiel zeigt die Annotationen f\u00fcr die Funktion \ngenerateToken\n im \nOAuthApiController\n.\n\n\n/**\n * Implements the OAuth 2.0 Access Token Response.\n *\n * @param string $code The authorization code.\n * @return JSONResponse The Access Token or an empty JSON Object.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n * @PublicPage\n * @CORS\n */\npublic function generateToken($code) { }\n\n\n\n\nDie Annotationen haben dabei folgende Bedeutungen.\n\n\n\n\n\n\n\n\nAnnotation\n\n\nBedeutung\n\n\n\n\n\n\n\n\n\n\n@NoAdminRequired\n\n\nAufruf auch von normalen Nutzern m\u00f6glich.\n\n\n\n\n\n\n@NoCSRFRequired\n\n\nZeigt an, dass die \u00dcberpr\u00fcfung des CSRF Tokens nicht gewollt ist.\n\n\n\n\n\n\n@PublicPage\n\n\nZugriff auch ohne Login m\u00f6glich.\n\n\n\n\n\n\n@CORS\n\n\nAufruf der API durch andere Web Applikationen von au\u00dfen m\u00f6glich.\n\n\n\n\n\n\n\n\nIn den Controller-Funktionen k\u00f6nnen verschiedene Inhalte zur\u00fcckgegeben werden. Hier genutzte R\u00fcckgabetypen sind in der folgenden Tabelle zusammengefasst.\n\n\n\n\n\n\n\n\nTyp\n\n\nBeschreibung\n\n\n\n\n\n\n\n\n\n\nTemplateResponse\n\n\nZur R\u00fcckgabe eines Templates, das dem Nutzer angezeigt werden soll.\n\n\n\n\n\n\nRedirectResponse\n\n\nZur Weiterleitung des Nutzers an eine andere URL.\n\n\n\n\n\n\nJSONResponse\n\n\nZur R\u00fcckgabe eines JSON Strings.\n\n\n\n\n\n\n\n\nEin Beispiel f\u00fcr die R\u00fcckgabetypen \nTemplateResponse\n und \nRedirectResponse\n gibt die Funktion \nauthorize\n im \nPageController\n, die im folgenden Codebeispiel zu sehen ist.\n\n\n/**\n * Shows a view for the user to authorize a client.\n *\n * @param string $response_type The expected response type.\n * @param string $client_id The client identifier.\n * @param string $redirect_uri The redirect URI.\n * @param string $state The state.\n * @param string $scope The scope.\n *\n * @return TemplateResponse|RedirectResponse The authorize view or a\n * redirection to the ownCloud main page.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n */\npublic function authorize($response_type, $client_id, $redirect_uri, $state = null, $scope = null) {\n    if (!is_string($response_type) || !is_string($client_id)\n        || !is_string($redirect_uri) || (isset($state) \n !is_string($state))\n        || (isset($scope) \n !is_string($scope))) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    try {\n        /** @var Client $client */\n        $client = $this-\nclientMapper-\nfindByIdentifier($client_id);\n    } catch (DoesNotExistException $exception) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    if (strcmp($client-\ngetRedirectUri(), urldecode($redirect_uri)) !== 0) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n    if (strcmp($response_type, 'code') !== 0) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    return new TemplateResponse('oauth2', 'authorize', ['client_name' =\n $client-\ngetName()]);\n}\n\n\n\n\nHier werden zun\u00e4chst die Parameter auf G\u00fcltigkeit \u00fcberpr\u00fcft. Sollten die Parameter nicht g\u00fcltig sein (beispielsweise deshalb, weil der angegebene Client nicht existiert oder dessen Redirect URI falsch angegeben wurde) wird mit einem \nRedirectResponse\n auf die ownCloud Startseite umgeleitet. Andernfalls wird ein \nTemplateResponse\n f\u00fcr das Template \nauthorize\n zur\u00fcckgegeben. F\u00fcr das Rendern des Templates k\u00f6nnen Parameter wie hier \nclient_name\n f\u00fcr den Namen des Clients \u00fcbergeben werden.\n\n\nDer R\u00fcckgabetyp \nJSONResponse\n wird f\u00fcr die R\u00fcckgabe des Access Tokens in der Funktion \ngenerateToken\n im \nOAuthApiController\n genutzt, wie nachfolgendes Codebeispiel zeigt. Zudem ist das Zusammenspiel mit Entities und Mappern zu sehen.\n\n\n/**\n * Implements the OAuth 2.0 Access Token Response.\n *\n * @param string $code The authorization code.\n * @return JSONResponse The Access Token or an empty JSON Object.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n * @PublicPage\n * @CORS\n */\npublic function generateToken($code) {\n    if (is_null($code) || is_null($_SERVER['PHP_AUTH_USER'])\n        || is_null($_SERVER['PHP_AUTH_PW'])) {\n        return new JSONResponse(['message' =\n 'Missing credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    try {\n        /** @var Client $client */\n        $client = $this-\nclientMapper-\nfindByIdentifier($_SERVER['PHP_AUTH_USER']);\n    } catch (DoesNotExistException $exception) {\n        return new JSONResponse(['message' =\n 'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    if (strcmp($client-\ngetSecret(), $_SERVER['PHP_AUTH_PW']) !== 0) {\n        return new JSONResponse(['message' =\n 'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    try {\n        /** @var AuthorizationCode $authorizationCode */\n        $authorizationCode = $this-\nauthorizationCodeMapper-\nfindByCode($code);\n    } catch (DoesNotExistException $exception) {\n        return new JSONResponse(['message' =\n 'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    if (strcmp($authorizationCode-\ngetClientId(), $client-\ngetId()) !== 0) {\n        return new JSONResponse(['message' =\n 'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    $token = Utilities::generateRandom();\n    $userId = $authorizationCode-\ngetUserId();\n    $accessToken = new AccessToken();\n    $accessToken-\nsetToken($token);\n    $accessToken-\nsetClientId($authorizationCode-\ngetClientId());\n    $accessToken-\nsetUserId($userId);\n    $this-\naccessTokenMapper-\ninsert($accessToken);\n\n    $this-\nauthorizationCodeMapper-\ndelete($authorizationCode);\n\n    return new JSONResponse(\n        [\n            'access_token' =\n $token,\n            'token_type' =\n 'Bearer',\n            'user_id' =\n $userId\n        ]\n    );\n}\n\n\n\n\nNach erfolgreicher \u00dcberpr\u00fcfung des Authorization Codes und der Angaben zur Client Authentication im Authorization Header wird eine neuer Access Token erstellt und in der Datenbank gespeichert. Der verwendete Authorization Code wird zudem gel\u00f6scht. Im JSON Response wird dann der Access Token, der Token Typ und die ID des Nutzers zur\u00fcckgegeben. Nachfolgend ist ein Beispiel dazu angegeben.\n\n\n{\n    \naccess_token\n : \n1vtnuo1NkIsbndAjVnhl7y0wJha59JyaAiFIVQDvcBY2uvKmj5EPBEhss0pauzdQ\n,\n    \ntoken_type\n : \nBearer\n,\n    \nuser_id\n : \nadmin\n\n}\n\n\n\n\nF\u00fcr die Token-Generierung wurde die Hilfsklasse \nUtilities\n mit der statischen Funktion \ngenerateRandom\n geschrieben, die mithilfe einer ownCloud-internen Funktion 64-stellige Zeichenketten erzeugt. Folgendes Codebeispiel zeigt diese Klasse.\n\n\n?php\nnamespace OCA\\OAuth2;\n\nclass Utilities {\n\n    /**\n     * Generates a random string with 64 characters.\n     *\n     * @return string The random string.\n     */\n    public static function generateRandom() {\n        return \\OC::$server-\ngetSecureRandom()-\ngenerate(64,\n            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789');\n    }\n\n}\n\n\n\n\nZusammenfassend werden im folgenden UML-Klassendiagramm die Controller mit ihren Beziehungen zu den Entities und Mappern dargestellt.\n\n\n\n  \nTODO:\n Klassendiagramm einf\u00fcgen.\n\n\n\n\nHooks\n\n\nIn den \nHooks\n einer ownCloud App wird Code gespeichert, der vor oder nach einem bestimmten Ereignis ausgef\u00fchrt werden soll. \nDiese Hooks sind teilweise vorgefertig, k\u00f6nnen aber auch f\u00fcr bestimmte Funktionalit\u00e4ten selbst entworfen werden. Diese Hooks m\u00fcssen in den \nroutes\n registriert werden und die zugeh\u00f6rige Logik im \nContainer\n gespeichert werden.\n\n\nIn der App wurden Userhooks definiert, welche vor dem endg\u00fcltigen L\u00f6schen eines Nutzers Code ausf\u00fchren. Zuerst wird eine Konstruktorfunktion aufgerufen, welche den \nuserManager\n, den \nauthorizationCodeMApper\n, den \naccessTokenMapper\n und den \nrefreshTokenMapper\n aufruft. \nDann wird der pre-delete Hook registriert und ein \ncallback\n f\u00fcr den Hook definiert. Dieser \ncallback\n l\u00f6scht jegliche, dem Nutzer zugeh\u00f6rige, \nauthorizationCodes\n, \naccessTokens\n und \nrefreshTokens.\n Dazu wird in den jeweiligen Konstruktoren die Methode \ndeleteByUID\n aufgerufen.\n\n\nFolgendes Codebeispiel zeigt den genannten Fall der \nUserHooks\n.\n\n\nclass UserHooks {\n\n    /**\n     * UserHooks constructor.\n     *\n     * @param IUserManager $userManager The user manager\n     * @param AuthorizationCodeMapper $authorizationCodeMapper The authorization code mapper\n     * @param AccessTokenMapper $accessTokenMapper The access token mapper\n     * @param RefreshTokenMapper $refreshTokenMapper The refresh token mapper\n     */\n    public function __construct(IUserManager $userManager,\n                                AuthorizationCodeMapper $authorizationCodeMapper,\n                                AccessTokenMapper $accessTokenMapper,\n                                RefreshTokenMapper $refreshTokenMapper) {\n        $this-\nuserManager = $userManager;\n        $this-\nauthorizationCodeMapper = $authorizationCodeMapper;\n        $this-\naccessTokenMapper = $accessTokenMapper;\n        $this-\nrefreshTokenMapper = $refreshTokenMapper;\n    }\n    /**\n     * Registers a pre-delete hook for users to delete authorization codes,\n     * access tokens and refresh tokens that reference the user.\n     */\n    public function register() {\n        /**\n         * @param User $user\n         */\n        $callback = function ($user) {\n            if (!is_null($user-\ngetUID())) {\n                $this-\nauthorizationCodeMapper-\ndeleteByUser($user-\ngetUID());\n                $this-\naccessTokenMapper-\ndeleteByUser($user-\ngetUID());\n                $this-\nrefreshTokenMapper-\ndeleteByUser($user-\ngetUID());\n            }\n        };\n        $this-\nuserManager-\nlisten('\\OC\\User', 'preDelete', $callback);\n    }\n}\n\n\n\n\nTemplates\n\n\nIn den \nTemplates\n einer ownCloud App wird die f\u00fcr den Nutzer sichtbare Oberfl\u00e4che definiert. Es k\u00f6nnen die vom \nController\n \u00fcbergebenen Parameter genutzt werden. Dazu gibt es ein Array mit dem Namen \n$_\n. \nZur Vermeidung von Cross-Site-Scripting gibt es die ownCloud-interne Funktion \np()\n, mithilfe derer Werte ausgegeben werden k\u00f6nnen.\n\n\nFolgende Templates wurden in der App definiert:\n\n\n\n\nauthorize\n: Zur Darstellung des Authroization Requests, bei dem der Nutzer um Autorisierung eines Clients gebeten wird. Es werden ein Text zur Erkl\u00e4rung sowie Buttons zum Akzeptieren oder Ablehnen angezeigt.\n\n\nsettings-admin\n: Stellt zur Verwaltung der Clients eine tabellarische Auflistung der Clients sowie ein Formular zum Hinzuf\u00fcgen von Clients dar.\n\n\nsettings-personal\n: Stellt eine tabellarische Auflistung der vom Nutzer autorisierten Clients dar, mit der M\u00f6glichkeit, die Autorisierung zu widerrufen.\n\n\n\n\nFolgendes Codebeispiel zeigt das Template \nsettings-admin\n.\n\n\n?php\n\ndiv class=\nsection\n id=\noauth2\n\n    \nh2\n?php p($l-\nt('OAuth 2.0')); ?\n/h2\n\n\n    \nh3\n?php p($l-\nt('Registered clients')); ?\n/h3\n\n    \n?php if (empty($_['clients'])) {\n        p($l-\nt('No clients registered.'));\n    }\n    else { ?\n\n    \ntable class=\ngrid\n\n        \nthead\n\n        \ntr\n\n            \nth id=\nheaderName\n scope=\ncol\n?php p($l-\nt('Name')); ?\n/th\n\n            \nth id=\nheaderRedirectUri\n scope=\ncol\n?php p($l-\nt('Redirect URI')); ?\n/th\n\n            \nth id=\nheaderClientIdentifier\n scope=\ncol\n?php p($l-\nt('Client Identifier')); ?\n/th\n\n            \nth id=\nheaderSecret\n scope=\ncol\n?php p($l-\nt('Secret')); ?\n/th\n\n            \nth id=\nheaderRemove\nnbsp;\n/th\n\n        \n/tr\n\n        \n/thead\n\n        \ntbody\n\n            \n?php foreach ($_['clients'] as $client) { ?\n\n                \ntr\n\n                    \ntd\n?php p($client-\ngetName()); ?\n/td\n\n                    \ntd\n?php p($client-\ngetRedirectUri()); ?\n/td\n\n                    \ntd\n?php p($client-\ngetIdentifier()); ?\n/td\n\n                    \ntd\n?php p($client-\ngetSecret()); ?\n/td\n\n                    \ntd\n\n                        \nform action=\n../apps/oauth2/clients/\n?php p($client-\ngetId()); ?\n/delete\n method=\npost\n\n                              style='display:inline;'\n\n                            \ninput type=\nsubmit\n class=\nbutton icon-delete\n value=\n\n                        \n/form\n\n                    \n/td\n\n                \n/tr\n\n            \n?php } ?\n\n        \n/tbody\n\n    \n/table\n\n    \n?php } ?\n\n\n    \nh3\n?php p($l-\nt('Add client')); ?\n/h3\n\n    \nform action=\n../apps/oauth2/clients\n method=\npost\n\n        \ninput id=\nname\n name=\nname\n type=\ntext\n placeholder=\n?php p($l-\nt('Name')); ?\n\n        \ninput id=\nredirect_uri\n name=\nredirect_uri\n type=\nurl\n placeholder=\n?php p($l-\nt('Redirect URI')); ?\n\n        \ninput type=\nsubmit\n class=\nbutton\n value=\n?php p($l-\nt('Add')); ?\n\n    \n/form\n\n\n/div\n\n\n\n\n\nIn diesem Template wird eine Tabelle mit den registrierten Clients angezeigt. Durch eine \nfor\n-Schleife wird f\u00fcr jeden Client aus dem Parameter \nclients\n ein Tabelleneintrag angezeigt. Sollten noch keine Clients registriert worden sein, sorgt die \nif\n-Anweisung daf\u00fcr, dass die Meldung \u201eNo clients registered\u201c angezeigt wird. Durch Nutzung von \n$l-\nt()\n k\u00f6nnen die Strings auch \nin andere Sprachen \u00dcbersetzt werden\n.\n\n\nDes Weiteren gibt es unter der Tabelle ein Formular f\u00fcr das Hinzuf\u00fcgen von Clients. Die in dem Formular angegebene Aktion l\u00f6st die Funktion \naddClient\n im \nSettingsController\n aus. Analog dazu gibt es f\u00fcr jeden Tabelleneintrag ein Formular zum L\u00f6schen des Eintrags, das die Funktion \ndeleteClient\n im \nSettingsController\n ausl\u00f6st.\n\n\nProtokollablauf\n\n\nDer Protokollablauf der oauth2 App ist dem regul\u00e4ren OAuth2 Protokollablauf nachempfunden. \n\n\nZun\u00e4chst wird vom Moodle Plugin die Methode \nGET authorize\n mit den Parametern \nresponse_type\n, \nclient_id\n und \nredirect_uri\n ausgef\u00fchrt, welche die OAuth 2.0 App anspricht und f\u00fcr eine Weiterleitung an ownCloud sorgt. Dann wird von ownCloud eine Authentifizierung erfragt, sprich der regul\u00e4re Anmeldebildschirm wird gezeigt, oder die Weiterleitung erfolgt sofort zur Autorisierungsabfrage der OAuth 2.0 App. Nach erfolgter Autorisierung wird zur \nredirectURI\n aus der \nGET authorize\n Methode weitergeleitet, sprich zur\u00fcck zum Moodle Plugin. \n\n\nAnschlie\u00dfend f\u00fchrt das Moodle Plugin die Methode \nPOST /api/v1/token\n aus, die den Authorizationcode an die OAuth 2.0 App sendet und als Antwort einen Access Token erh\u00e4lt.\n\n\nNach erfolgter Autorisierung von Moodle mit ownCloud via OAuth 2.0 kann nun der WebDAV Zugriff folgen. Dieser erfolgt mit dem Access Code auf die OAuth WebDAV App. Diese kommuniziert daraufhin mit der OAuth 2.0 App \u00fcber die Methode \nGET api/v1/validate\n und dem Access Token und pr\u00fcft diesen. Bei erfolgreicher \u00dcberpr\u00fcfung wird dann der WebDAV Zugriff entsprechend erm\u00f6glicht.\n\n\n\n  \nTODO:\n Sequenzdiagramm einf\u00fcgen.\n\n\n\n\nTests\n\n\nZum Testen der PHP-Klassen wurde das Framework \nPHPUnit\n verwendet. Die aktuelle Testabdeckung ist bei Codecov einsehbar: \n.\n\n\nContinuous Integration\n\n\nAls Continuous Integration Integration Tool wurde Travis CI verwendet. Bei jeder \u00c4nderung im \nGitHub Repository\n wird ein Build angesto\u00dfen, in dem die App mithilfe eines Makefiles f\u00fcr den App Store gebaut wird und anschlie\u00dfend in verschiedenen Umgebungen installiert und getestet wird. Folgende Parameter werden variiert:\n\n\n\n\nPHP Versionen\n: 5.6, 7.0, 7.1, nightly\n\n\nDatenbanken\n: PostgreSQL, MySQL, SQLite\n\n\nBranches des ownCloud Core\n: \nmaster\n\n\n\n\nDer aktuelle Build-Status ist bei Travis einsehbar: \n.\n\n\nAnpassung der \ndav\n App\n\n\n\n  \nTODO:\n Aktualisieren, \u00fcberf\u00fchren in \"Anpassung des ownCloud Cores\" (s.u.).\n\n\nNachdem das OAuth 2.0 Protokoll durch die \noauth2\n App bereitgestellt wurde, musste die \nWebDAV Schnittstelle\n in ownCloud um diese Authentifizierungsmethode erweitert werden. Erreichbar ist diese unter dem Endpunkt \nremote.php/webdav\n.\n\n\nAuthentication Backend\n\n\nEine Anfrage am Endpunkt \nremote.php/webdav\n wird durch die Datei \nappinfo/v1/webdav.php\n entgegengenommen. Hier wird mithilfe der \nsabre/dav\n Bibliothek ein WebDAV-Server gestartet. Nachfolgendes Codebeispiel zeigt die f\u00fcr die Authentifizierung wichtige Stelle.\n\n\n$authBackend = new \\OCA\\DAV\\Connector\\Sabre\\Auth(\n    \\OC::$server-\ngetSession(),\n    \\OC::$server-\ngetUserSession(),\n    \\OC::$server-\ngetRequest(),\n    \\OC::$server-\ngetTwoFactorAuthManager(),\n    'principals/'\n);\n\n\n\n\nDie Authentifizierung ist in sabre/dav modularisiert, sodass die n\u00f6tigen Anpassungen leicht durchzuf\u00fchren waren. Das im Codebeispiel gezeigte Authentication Backend ist eine von ownCloud implementierte Unterklasse von \nAbstractBasic\n, einer abstrakten Klasse, die bei der Implementierung von Basic Authentication behilflich ist. Gl\u00fccklicherweise existiert in sabre/dav mit der Klasse \nAbstractBearer\n auch ein entsprechendes Gegenst\u00fcck f\u00fcr Bearer Authentication. Da beide Klassen das \nBackendInterface\n implementieren, kann ein WebDAV Server mit beiden Authentication Backends gestartet werden.\n\n\nDie Implementierung von OAuth 2.0 erwies sich damit als ziemlich kurz, wie nachfolgendes Codebeispiel zeigt.\n\n\n?php\nnamespace OCA\\DAV\\Connector\\Sabre;\n\nuse Sabre\\DAV\\Auth\\Backend\\AbstractBearer;\nuse OCA\\OAuth2\\Db\\AccessToken;\nuse OCA\\OAuth2\\Db\\AccessTokenMapper;\nuse OCP\\AppFramework\\App;\nuse OCP\\AppFramework\\Db\\DoesNotExistException;\n\n/**\n * OAuth 2.0 authentication backend class.\n */\nclass OAuth2 extends AbstractBearer {\n\n    /**\n     * This is the prefix that will be used to generate principal urls.\n     *\n     * @var string\n     */\n    protected $principalPrefix;\n\n    /**\n     * OAuth2 constructor.\n     *\n     * @param string $principalPrefix\n     */\n    public function __construct($principalPrefix = 'principals/users/') {\n        $this-\nprincipalPrefix = $principalPrefix;\n\n        $defaults = new \\OC_Defaults();\n        $this-\nrealm = $defaults-\ngetName();\n    }\n\n    /**\n     * Validates a Bearer token\n     *\n     * This method should return the full principal url, or false if the\n     * token was incorrect.\n     *\n     * @param string $bearerToken\n     * @return string|false\n     */\n    protected function validateBearerToken($bearerToken) {\n        if (!is_string($bearerToken)) {\n            return false;\n        }\n\n        $app = new App('oauth2');\n        /** @var AccessTokenMapper $accessTokenMapper */\n        $accessTokenMapper = $app-\ngetContainer()-\nquery('OCA\\OAuth2\\Db\\AccessTokenMapper');\n\n        try {\n            /** @var AccessToken $accessToken */\n            $accessToken = $accessTokenMapper-\nfindByToken($bearerToken);\n            $userId = $accessToken-\ngetUserId();\n\n            \\OC_Util::setupFS($userId);\n\n            return $this-\nprincipalPrefix . $userId;\n        } catch (DoesNotExistException $exception) {\n            return false;\n        }\n    }\n\n}\n\n\n\n\nNeben dem Konstruktur, in der \nprincipalPrefix\n sowie das \nrealm\n analog zum Konstruktor der \nAuth\n-Klasse gesetzt werden, musste lediglich die Funktion \nvalidateBearerToken\n implementiert werden. Hier wird der in der Anfrage mitgesendete Bearer Token mithilfe vom \nAccessTokenMapper\n \u00fcberpr\u00fcft. Falls der Access Token g\u00fcltig ist, wird die ID des Nutzers abgefragt, um mit \n\\OC_Util::setupFS($userId)\n das Dateisystem f\u00fcr den WebDAV Server vorzubereiten. Es wird dann der \nprincipalPrefix\n zusammen mit der \nuserId\n zur\u00fcckgegeben. Andernfalls wird \nfalse\n zur\u00fcckgegeben, was dazu f\u00fchrt, dass der WebDAV Zugriff verweigert wird.\n\n\nHeaderabh\u00e4ngige Authentifizierung\n\n\nDamit die WebDAV Schnittstelle sowohl \u00fcber die bisherige Basic Authentication als auch \u00fcber OAuth 2.0 funktioniert, musste eine Logik hinzugef\u00fcgt werden, die abh\u00e4ngig vom Authoriaztion Header entscheidet, welches Verfahren anzuwenden ist. Der Ansatzpunkt musste dabei die Datei \nappinfo/v1/webdav.php\n sein, da hier das Authentication Backend erstellt wird. Folgendes Codebeispiel zeigt, welche \u00c4nderungen notwendig waren.\n\n\nif (strpos(\\OC::$server-\ngetRequest()-\ngetHeader('Authorization'), 'Bearer') !== false) {\n    // OAuth 2.0\n    $authBackend = new \\OCA\\DAV\\Connector\\Sabre\\OAuth2();\n} else {\n    // Basic Auth\n    $authBackend = new \\OCA\\DAV\\Connector\\Sabre\\Auth(\n        \\OC::$server-\ngetSession(),\n        \\OC::$server-\ngetUserSession(),\n        \\OC::$server-\ngetRequest(),\n        \\OC::$server-\ngetTwoFactorAuthManager(),\n        'principals/'\n    );\n}\n\n\n\n\nDurch die ownCloud-interne Funktion \ngetHeader\n konnte der Authorization Header abgefragt werden. Da f\u00fcr Bearer Authentication das Wort \u201eBearer\u201c in diesem enthalten sein muss, konnte mithilfe der Stringfunktion \nstrpos\n die Logik implementiert werden. Abh\u00e4ngig vom Header wird somit entweder die Klasse \nOAuth2\n f\u00fcr OAuth 2.0 oder \nAuth\n f\u00fcr Basic Authentication als Authentication Backend genutzt.\n\n\nTests\n\n\n\n  \nTODO:\n Tests hinzuf\u00fcgen beschreiben.\n\n\n\n\nAnpassung des ownCloud Cores\n\n\nUm die Funktionalit\u00e4ten des OAuth 2.0 Protokolls mit Hilfe der App nutzen zu k\u00f6nnen, mussten die \nWebDAV Schnittstelle\n und auch die \nOCS Schnittstelle\n um die Authentifizierungsmethode OAuth 2.0 erweitert werden.\nDazu wurde ein \nPull request\n gestellt, um entsprechende \u00c4nderungen durchzuf\u00fchren.", 
            "title": "Technische Umsetzung"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#technische-umsetzung", 
            "text": "", 
            "title": "Technische Umsetzung"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#motivation", 
            "text": "Da man m\u00f6glichst keine neue Schnittstelle implementieren wollte, war es das Ziel, die bestehende WebDAV Schnittstelle um OAuth 2.0 zu erweitern. Die WebDAV Schnittstelle ist als  ownCloud App  realisiert worden. Auf der anderen Seite musste das OAuth 2.0 Protokoll mit seinen Schnittstellen bereitgestellt werden, um die Authentifizierung in der WebDAV App um OAuth 2.0 zu erweitern zu k\u00f6nnen. Daf\u00fcr wurde eine weitere ownCloud App implementiert.", 
            "title": "Motivation"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#implementierung-der-oauth2-app", 
            "text": "In der App sollte der h\u00e4ufig f\u00fcr Webapplikationen eingesetzte  Authorization Code Flow  implementiert werden. Dazu mussten folgende User Stories umgesetzt werden:   Clientregistrierung:  Als ownCloud-Administrator m\u00f6chte ich Clients in den Administrator-Einstellungen hinzuf\u00fcgen und l\u00f6schen k\u00f6nnen, um die Kontrolle \u00fcber erlaubte Clients zu haben.  Authorization URL:  Als Client-Entwickler m\u00f6chte ich eine Authorization URL zur Verf\u00fcgung haben, um Authorization Codes anfordern zu k\u00f6nnen.  Access Token URL:  Als Client-Entwickler m\u00f6chte ich eine Access Token URL zur Verf\u00fcgung haben, um Access Tokens anfordern zu k\u00f6nnen.  Verwaltung autorisierter Applikationen : Als ownCloud-Nutzer m\u00f6chte ich in den pers\u00f6nlichen Einstellungen autorisierte Applikationen verwalten k\u00f6nnen, um einen \u00dcberblick zu haben und Autorisierungen widerrufen zu k\u00f6nnen.", 
            "title": "Implementierung der oauth2 App"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#datenmodell", 
            "text": "Zun\u00e4chst musste ein Datenmodell zur Speicherung der ben\u00f6tigten Daten aufgestellt werden. Gem\u00e4\u00df dem Authorization Code Flow wurden folgende Entit\u00e4ten mit Attributen definiert:   client :  Die Applikation, die f\u00fcr den Zugriff auf die WebDAV Schnittstelle autorisiert werden soll.  identifier : Zeichenkette, die einen Client eindeutig identifiziert.  secret : Zeichenkette, mit der ein Client sich beim Anfordern eines Access Tokens authentifizieren kann.  redirect_uri : URI, an die nach erfolgter Autorisierung des Nutzers weitergeleitet wird.    authorization_code :  Ein  Authorization Grant , mit dem der Client die Autorisierung des Nutzers darlegen und somit ein Access Token anfordern kann.  code : Zeichenkette, die als Authorization Code dient.  client_id : Client Identifier des Clients, f\u00fcr den der Authorization Code ausgegeben wird.  user_id : User ID des ownCloud-Nutzers, der den Client autorisiert hat.  expires : Zeitpunkt, zu dem der Authorization Code ung\u00fcltig wird (optional).    access_token :  Eine Zeichenkette, die den Zugriff auf die WebDAV Schnittstelle erlaubt.  code : Zeichenkette, die als Access Token dient.  client_id : Client Identifier des Clients, f\u00fcr den der Access Token ausgegeben wird.  user_id : User ID des ownCloud-Nutzers, der den Client autorisiert hat.  expires : Zeitpunkt, zu dem der Access Token ung\u00fcltig wird (optional).    refresh_token :  Eine Zeichenkette, mit der ein abgelaufener Access Token gegen einen neuen ausgetauscht werden kann.  code : Zeichenkette, die als Refresh Token dient.  client_id : Client Identifier des Clients, f\u00fcr den der Access Token ausgegeben wird.  user_id : User ID des ownCloud-Nutzers, der den Client autorisiert hat.  expires : Zeitpunkt, zu dem der Refresh Token ung\u00fcltig wird (optional).     Folgendes Entity-Relationship-Modell fasst das Datenmodell nochmal grafisch zusammen.", 
            "title": "Datenmodell"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#mapper-und-entities", 
            "text": "F\u00fcr den Datenbank-Zugriff im PHP-Code ist es in ownCloud m\u00f6glich,  Mapper  und  Entities  zu schreiben. Dadurch werden Tupel in einer Datenbank-Tabelle automatisch in ein Objekt umgewandelt.  Folgendes Codebeispiel zeigt am Beispiel des Entitys  Client , wie eine PHP-Klasse dazu aussehen muss.  ?php\nnamespace OCA\\OAuth2\\Db;\n\nuse OCP\\AppFramework\\Db\\Entity;\n\n/**\n * Class Client\n *\n * @method string getIdentifier()\n * @method void setIdentifier(string $identifier)\n * @method string getSecret()\n * @method void setSecret(string $secret)\n * @method string getRedirectUri()\n * @method void setRedirectUri(string $redirectUri)\n * @method string getName()\n * @method void setName(string $name)\n */\nclass Client extends Entity {\n\n    protected $identifier;\n    protected $secret;\n    protected $redirectUri;\n    protected $name;\n\n    public function __construct() {\n        $this- addType('id', 'int');\n        $this- addType('identifier', 'string');\n        $this- addType('secret', 'string');\n        $this- addType('redirect_uri', 'string');\n        $this- addType('name', 'string');\n    }\n\n}  Wichtig ist, dass die Klasse von  Entity  erbt und sowohl der Klassenname als auch die Attribute mit denen der Tabelle \u00fcbereinstimmen. Pascal bzw. Camel case im PHP-Code wird automatisch zu Snake case f\u00fcr die Datenbank umgewandelt. Getter und Setter werden ebenfalls automatisch generiert. Die PHPDoc Kommentare dienen lediglich dazu, in der Entwicklungsumgebung eine automatische Vervollst\u00e4ndigung zu haben. Die Angabe von  Typen  im Konstruktor dienen dazu, beim Lesen aus der Datenbank die richtige Umwandlung zu erhalten.  Das folgende Codebeispiel zeigt einen Ausschnitt aus dem zur  Client  Entity geh\u00f6renden Mapper.  ?php\nnamespace OCA\\OAuth2\\Db;\n\nuse InvalidArgumentException;\nuse OCP\\AppFramework\\Db\\Entity;\nuse OCP\\IDb;\nuse OCP\\AppFramework\\Db\\Mapper;\n\nclass ClientMapper extends Mapper {\n\n    /**\n     * ClientMapper constructor.\n     *\n     * @param IDb $db Database Connection.\n     */\n    public function __construct(IDb $db) {\n        parent::__construct($db, 'oauth2_clients');\n    }\n\n    /**\n     * Selects a client by its ID.\n     *\n     * @param int $id The client's ID.\n     *\n     * @return Entity The client entity.\n     *\n     * @throws \\OCP\\AppFramework\\Db\\DoesNotExistException if not found.\n     * @throws \\OCP\\AppFramework\\Db\\MultipleObjectsReturnedException if more than one result.\n     */\n    public function find($id) {\n        if (!is_int($id)) {\n            throw new InvalidArgumentException('id must not be null');\n        }\n\n        $sql = 'SELECT * FROM `' . $this- tableName . '` WHERE `id` = ?';\n        return $this- findEntity($sql, array($id), null, null);\n    }\n\n    /**\n     * Selects clients by the given user ID.\n     *\n     * @param string $userId The user ID.\n     *\n     * @return array The client entities.\n     */\n    public function findByUser($userId) {\n        if (!is_string($userId)) {\n            throw new InvalidArgumentException('userId must not be null');\n        }\n\n        $sql = 'SELECT * FROM `' . $this- tableName . '` '\n            . 'WHERE `id` IN ( '\n                . 'SELECT `client_id` FROM `oc_oauth2_authorization_codes` WHERE `user_id` = ? '\n                . 'UNION '\n                . 'SELECT `client_id` FROM `oc_oauth2_access_tokens` WHERE `user_id` = ? '\n            .')';\n        return $this- findEntities($sql, array($userId, $userId), null, null);\n    }\n\n}  Beim Mapper ist es wichtig, dass die Klasse von  Mapper  erbt und eine Entity-Klasse zu ihm existiert. Dazu wird das Wort vor \u201eMapper\u201c als Entityname verwendet. Im Konstruktur wird der Tabellenname angegeben. Die beiden Funktionen  find  und  findByUser  demonstrieren  SELECT -Anweisungen. Dazu wird die SQL-Anweisungen zusammen mit ben\u00f6tigten Parametern an  findEntity  bzw.  findEntities  \u00fcbergeben, abh\u00e4ngig davon, ob mehrere Entities im Ergebnis enthalten sein sollten. Funktionen zum l\u00f6schen, einf\u00fcgen und updaten werden von der Oberklasse bereits implementiert und mussten nicht angepasst werden.", 
            "title": "Mapper und Entities"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#schnittstellen-und-routes", 
            "text": "Um in einer ownCloud App Schnittstellen anzubieten, m\u00fcssen  Routes  registriert werden. Zur Umsetzung der erw\u00e4hnten User Stories waren folgende Routes notwendig:     Methode  Endpunkt  Beschreibung      GET  authorize  Endpunkt, zu dem der Client den Nutzer weiterleitet, um die Autorisierung anzufragen (Authorization URL).    POST  authorize  Endpunkt, der aufgerufen wird, sobald der Nutzer den Client autorisiert hat.    POST  api/v1/token  Endpunkt, an dem ein Access Token angefordert wird (Access Token URL).    POST  clients  Endpunkt, durch den der Administrator einen Client hinzuf\u00fcgen kann.    POST  clients/{id}/delete  Endpunkt, durch den der Administrator den Client mit der ID  id  l\u00f6schen kann.    POST  clients/{id}/revoke  Endpunkt, durch den der Nutzer die Autorisierung des Clients mit der ID  id  widerrufen kann.     Registriert werden die Routes in der Datei  routes.php , indem ein Array mit den Routes zur\u00fcckgegeben wird. Nachfolgendes Codebeispiel zeigt einige der obigen Routes:  ?php\nreturn [\n    'routes' =  [\n        ['name' =  'page#authorize', 'url' =  '/authorize', 'verb' =  'GET'],\n        ['name' =  'o_auth_api#generate_token', 'url' =  '/api/v1/token', 'verb' =  'POST'],\n        ['name' =  'settings#deleteClient', 'url' =  '/clients/{id}/delete', 'verb' =  'POST']\n    ]\n];  Durch  name  wird f\u00fcr jede Route der Name des dazugeh\u00f6rigen  Controllers  sowie die aufzurufende Funktion angegeben. Vor dem  # -Zeichen steht der Controllername in Snake case und hinter dem  # -Zeichen steht der Funktionsname (ebenfalls in Snake case). Mithilfe von  url  wird der Endpunkt festgelegt und  verb  definiert die HTTP-Methode.", 
            "title": "Schnittstellen und Routes"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#controller", 
            "text": "Wenn an einem Endpunkt eine HTTP-Anfrage ankommt, so wird der in den Routes definierte  Controller  aufgerufen. Wichtig ist hierbei, dass von der Klasse  Controller  oder einer Unterklasse wie  ApiController  geerbt wird.  F\u00fcr den Controller notwendige Parameter wie  Mapper  k\u00f6nnen im Konstruktor als Parameter angegeben und so durch  Dependency Injection  erhalten werden. Nachfolgendes Codebeispiel zeigt den Konstruktor vom  PageController .  /**\n * PageController constructor.\n * \n * @param string $AppName The name of the app.\n * @param IRequest $request The request.\n * @param ClientMapper $clientMapper The client mapper.\n * @param AuthorizationCodeMapper $authorizationCodeMapper The authorization code mapper.\n * @param string $UserId The user ID.\n */\npublic function __construct($AppName, IRequest $request, ClientMapper $clientMapper,\n    AuthorizationCodeMapper $authorizationCodeMapper, $UserId) {\n    parent::__construct($AppName, $request);\n\n    $this- clientMapper = $clientMapper;\n    $this- authorizationCodeMapper = $authorizationCodeMapper;\n    $this- userId = $UserId;\n}  Die hier notwendigen Parameter sind der Name der App, eine  ClientMapper  Instanz, eine  AuthorizationCodeMapper  Instanz und die ID des Nutzers, um bei der Autorisierung des Clients speichern zu k\u00f6nnen, welcher Nutzers dies veranlasst hat.  Die mit den Routes verkn\u00fcpften Funktionen k\u00f6nnen zur Zugriffskontrolle mit  PHPDoc Annotationen  versehen werden. Folgendes Codebeispiel zeigt die Annotationen f\u00fcr die Funktion  generateToken  im  OAuthApiController .  /**\n * Implements the OAuth 2.0 Access Token Response.\n *\n * @param string $code The authorization code.\n * @return JSONResponse The Access Token or an empty JSON Object.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n * @PublicPage\n * @CORS\n */\npublic function generateToken($code) { }  Die Annotationen haben dabei folgende Bedeutungen.     Annotation  Bedeutung      @NoAdminRequired  Aufruf auch von normalen Nutzern m\u00f6glich.    @NoCSRFRequired  Zeigt an, dass die \u00dcberpr\u00fcfung des CSRF Tokens nicht gewollt ist.    @PublicPage  Zugriff auch ohne Login m\u00f6glich.    @CORS  Aufruf der API durch andere Web Applikationen von au\u00dfen m\u00f6glich.     In den Controller-Funktionen k\u00f6nnen verschiedene Inhalte zur\u00fcckgegeben werden. Hier genutzte R\u00fcckgabetypen sind in der folgenden Tabelle zusammengefasst.     Typ  Beschreibung      TemplateResponse  Zur R\u00fcckgabe eines Templates, das dem Nutzer angezeigt werden soll.    RedirectResponse  Zur Weiterleitung des Nutzers an eine andere URL.    JSONResponse  Zur R\u00fcckgabe eines JSON Strings.     Ein Beispiel f\u00fcr die R\u00fcckgabetypen  TemplateResponse  und  RedirectResponse  gibt die Funktion  authorize  im  PageController , die im folgenden Codebeispiel zu sehen ist.  /**\n * Shows a view for the user to authorize a client.\n *\n * @param string $response_type The expected response type.\n * @param string $client_id The client identifier.\n * @param string $redirect_uri The redirect URI.\n * @param string $state The state.\n * @param string $scope The scope.\n *\n * @return TemplateResponse|RedirectResponse The authorize view or a\n * redirection to the ownCloud main page.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n */\npublic function authorize($response_type, $client_id, $redirect_uri, $state = null, $scope = null) {\n    if (!is_string($response_type) || !is_string($client_id)\n        || !is_string($redirect_uri) || (isset($state)   !is_string($state))\n        || (isset($scope)   !is_string($scope))) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    try {\n        /** @var Client $client */\n        $client = $this- clientMapper- findByIdentifier($client_id);\n    } catch (DoesNotExistException $exception) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    if (strcmp($client- getRedirectUri(), urldecode($redirect_uri)) !== 0) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n    if (strcmp($response_type, 'code') !== 0) {\n        return new RedirectResponse(OC_Util::getDefaultPageUrl());\n    }\n\n    return new TemplateResponse('oauth2', 'authorize', ['client_name' =  $client- getName()]);\n}  Hier werden zun\u00e4chst die Parameter auf G\u00fcltigkeit \u00fcberpr\u00fcft. Sollten die Parameter nicht g\u00fcltig sein (beispielsweise deshalb, weil der angegebene Client nicht existiert oder dessen Redirect URI falsch angegeben wurde) wird mit einem  RedirectResponse  auf die ownCloud Startseite umgeleitet. Andernfalls wird ein  TemplateResponse  f\u00fcr das Template  authorize  zur\u00fcckgegeben. F\u00fcr das Rendern des Templates k\u00f6nnen Parameter wie hier  client_name  f\u00fcr den Namen des Clients \u00fcbergeben werden.  Der R\u00fcckgabetyp  JSONResponse  wird f\u00fcr die R\u00fcckgabe des Access Tokens in der Funktion  generateToken  im  OAuthApiController  genutzt, wie nachfolgendes Codebeispiel zeigt. Zudem ist das Zusammenspiel mit Entities und Mappern zu sehen.  /**\n * Implements the OAuth 2.0 Access Token Response.\n *\n * @param string $code The authorization code.\n * @return JSONResponse The Access Token or an empty JSON Object.\n *\n * @NoAdminRequired\n * @NoCSRFRequired\n * @PublicPage\n * @CORS\n */\npublic function generateToken($code) {\n    if (is_null($code) || is_null($_SERVER['PHP_AUTH_USER'])\n        || is_null($_SERVER['PHP_AUTH_PW'])) {\n        return new JSONResponse(['message' =  'Missing credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    try {\n        /** @var Client $client */\n        $client = $this- clientMapper- findByIdentifier($_SERVER['PHP_AUTH_USER']);\n    } catch (DoesNotExistException $exception) {\n        return new JSONResponse(['message' =  'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    if (strcmp($client- getSecret(), $_SERVER['PHP_AUTH_PW']) !== 0) {\n        return new JSONResponse(['message' =  'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    try {\n        /** @var AuthorizationCode $authorizationCode */\n        $authorizationCode = $this- authorizationCodeMapper- findByCode($code);\n    } catch (DoesNotExistException $exception) {\n        return new JSONResponse(['message' =  'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    if (strcmp($authorizationCode- getClientId(), $client- getId()) !== 0) {\n        return new JSONResponse(['message' =  'Unknown credentials.'], Http::STATUS_BAD_REQUEST);\n    }\n\n    $token = Utilities::generateRandom();\n    $userId = $authorizationCode- getUserId();\n    $accessToken = new AccessToken();\n    $accessToken- setToken($token);\n    $accessToken- setClientId($authorizationCode- getClientId());\n    $accessToken- setUserId($userId);\n    $this- accessTokenMapper- insert($accessToken);\n\n    $this- authorizationCodeMapper- delete($authorizationCode);\n\n    return new JSONResponse(\n        [\n            'access_token' =  $token,\n            'token_type' =  'Bearer',\n            'user_id' =  $userId\n        ]\n    );\n}  Nach erfolgreicher \u00dcberpr\u00fcfung des Authorization Codes und der Angaben zur Client Authentication im Authorization Header wird eine neuer Access Token erstellt und in der Datenbank gespeichert. Der verwendete Authorization Code wird zudem gel\u00f6scht. Im JSON Response wird dann der Access Token, der Token Typ und die ID des Nutzers zur\u00fcckgegeben. Nachfolgend ist ein Beispiel dazu angegeben.  {\n     access_token  :  1vtnuo1NkIsbndAjVnhl7y0wJha59JyaAiFIVQDvcBY2uvKmj5EPBEhss0pauzdQ ,\n     token_type  :  Bearer ,\n     user_id  :  admin \n}  F\u00fcr die Token-Generierung wurde die Hilfsklasse  Utilities  mit der statischen Funktion  generateRandom  geschrieben, die mithilfe einer ownCloud-internen Funktion 64-stellige Zeichenketten erzeugt. Folgendes Codebeispiel zeigt diese Klasse.  ?php\nnamespace OCA\\OAuth2;\n\nclass Utilities {\n\n    /**\n     * Generates a random string with 64 characters.\n     *\n     * @return string The random string.\n     */\n    public static function generateRandom() {\n        return \\OC::$server- getSecureRandom()- generate(64,\n            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789');\n    }\n\n}  Zusammenfassend werden im folgenden UML-Klassendiagramm die Controller mit ihren Beziehungen zu den Entities und Mappern dargestellt.  \n   TODO:  Klassendiagramm einf\u00fcgen.", 
            "title": "Controller"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#hooks", 
            "text": "In den  Hooks  einer ownCloud App wird Code gespeichert, der vor oder nach einem bestimmten Ereignis ausgef\u00fchrt werden soll. \nDiese Hooks sind teilweise vorgefertig, k\u00f6nnen aber auch f\u00fcr bestimmte Funktionalit\u00e4ten selbst entworfen werden. Diese Hooks m\u00fcssen in den  routes  registriert werden und die zugeh\u00f6rige Logik im  Container  gespeichert werden.  In der App wurden Userhooks definiert, welche vor dem endg\u00fcltigen L\u00f6schen eines Nutzers Code ausf\u00fchren. Zuerst wird eine Konstruktorfunktion aufgerufen, welche den  userManager , den  authorizationCodeMApper , den  accessTokenMapper  und den  refreshTokenMapper  aufruft. \nDann wird der pre-delete Hook registriert und ein  callback  f\u00fcr den Hook definiert. Dieser  callback  l\u00f6scht jegliche, dem Nutzer zugeh\u00f6rige,  authorizationCodes ,  accessTokens  und  refreshTokens.  Dazu wird in den jeweiligen Konstruktoren die Methode  deleteByUID  aufgerufen.  Folgendes Codebeispiel zeigt den genannten Fall der  UserHooks .  class UserHooks {\n\n    /**\n     * UserHooks constructor.\n     *\n     * @param IUserManager $userManager The user manager\n     * @param AuthorizationCodeMapper $authorizationCodeMapper The authorization code mapper\n     * @param AccessTokenMapper $accessTokenMapper The access token mapper\n     * @param RefreshTokenMapper $refreshTokenMapper The refresh token mapper\n     */\n    public function __construct(IUserManager $userManager,\n                                AuthorizationCodeMapper $authorizationCodeMapper,\n                                AccessTokenMapper $accessTokenMapper,\n                                RefreshTokenMapper $refreshTokenMapper) {\n        $this- userManager = $userManager;\n        $this- authorizationCodeMapper = $authorizationCodeMapper;\n        $this- accessTokenMapper = $accessTokenMapper;\n        $this- refreshTokenMapper = $refreshTokenMapper;\n    }\n    /**\n     * Registers a pre-delete hook for users to delete authorization codes,\n     * access tokens and refresh tokens that reference the user.\n     */\n    public function register() {\n        /**\n         * @param User $user\n         */\n        $callback = function ($user) {\n            if (!is_null($user- getUID())) {\n                $this- authorizationCodeMapper- deleteByUser($user- getUID());\n                $this- accessTokenMapper- deleteByUser($user- getUID());\n                $this- refreshTokenMapper- deleteByUser($user- getUID());\n            }\n        };\n        $this- userManager- listen('\\OC\\User', 'preDelete', $callback);\n    }\n}", 
            "title": "Hooks"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#templates", 
            "text": "In den  Templates  einer ownCloud App wird die f\u00fcr den Nutzer sichtbare Oberfl\u00e4che definiert. Es k\u00f6nnen die vom  Controller  \u00fcbergebenen Parameter genutzt werden. Dazu gibt es ein Array mit dem Namen  $_ . \nZur Vermeidung von Cross-Site-Scripting gibt es die ownCloud-interne Funktion  p() , mithilfe derer Werte ausgegeben werden k\u00f6nnen.  Folgende Templates wurden in der App definiert:   authorize : Zur Darstellung des Authroization Requests, bei dem der Nutzer um Autorisierung eines Clients gebeten wird. Es werden ein Text zur Erkl\u00e4rung sowie Buttons zum Akzeptieren oder Ablehnen angezeigt.  settings-admin : Stellt zur Verwaltung der Clients eine tabellarische Auflistung der Clients sowie ein Formular zum Hinzuf\u00fcgen von Clients dar.  settings-personal : Stellt eine tabellarische Auflistung der vom Nutzer autorisierten Clients dar, mit der M\u00f6glichkeit, die Autorisierung zu widerrufen.   Folgendes Codebeispiel zeigt das Template  settings-admin .  ?php div class= section  id= oauth2 \n     h2 ?php p($l- t('OAuth 2.0')); ? /h2 \n\n     h3 ?php p($l- t('Registered clients')); ? /h3 \n     ?php if (empty($_['clients'])) {\n        p($l- t('No clients registered.'));\n    }\n    else { ? \n     table class= grid \n         thead \n         tr \n             th id= headerName  scope= col ?php p($l- t('Name')); ? /th \n             th id= headerRedirectUri  scope= col ?php p($l- t('Redirect URI')); ? /th \n             th id= headerClientIdentifier  scope= col ?php p($l- t('Client Identifier')); ? /th \n             th id= headerSecret  scope= col ?php p($l- t('Secret')); ? /th \n             th id= headerRemove nbsp; /th \n         /tr \n         /thead \n         tbody \n             ?php foreach ($_['clients'] as $client) { ? \n                 tr \n                     td ?php p($client- getName()); ? /td \n                     td ?php p($client- getRedirectUri()); ? /td \n                     td ?php p($client- getIdentifier()); ? /td \n                     td ?php p($client- getSecret()); ? /td \n                     td \n                         form action= ../apps/oauth2/clients/ ?php p($client- getId()); ? /delete  method= post \n                              style='display:inline;' \n                             input type= submit  class= button icon-delete  value= \n                         /form \n                     /td \n                 /tr \n             ?php } ? \n         /tbody \n     /table \n     ?php } ? \n\n     h3 ?php p($l- t('Add client')); ? /h3 \n     form action= ../apps/oauth2/clients  method= post \n         input id= name  name= name  type= text  placeholder= ?php p($l- t('Name')); ? \n         input id= redirect_uri  name= redirect_uri  type= url  placeholder= ?php p($l- t('Redirect URI')); ? \n         input type= submit  class= button  value= ?php p($l- t('Add')); ? \n     /form  /div   In diesem Template wird eine Tabelle mit den registrierten Clients angezeigt. Durch eine  for -Schleife wird f\u00fcr jeden Client aus dem Parameter  clients  ein Tabelleneintrag angezeigt. Sollten noch keine Clients registriert worden sein, sorgt die  if -Anweisung daf\u00fcr, dass die Meldung \u201eNo clients registered\u201c angezeigt wird. Durch Nutzung von  $l- t()  k\u00f6nnen die Strings auch  in andere Sprachen \u00dcbersetzt werden .  Des Weiteren gibt es unter der Tabelle ein Formular f\u00fcr das Hinzuf\u00fcgen von Clients. Die in dem Formular angegebene Aktion l\u00f6st die Funktion  addClient  im  SettingsController  aus. Analog dazu gibt es f\u00fcr jeden Tabelleneintrag ein Formular zum L\u00f6schen des Eintrags, das die Funktion  deleteClient  im  SettingsController  ausl\u00f6st.", 
            "title": "Templates"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#protokollablauf", 
            "text": "Der Protokollablauf der oauth2 App ist dem regul\u00e4ren OAuth2 Protokollablauf nachempfunden.   Zun\u00e4chst wird vom Moodle Plugin die Methode  GET authorize  mit den Parametern  response_type ,  client_id  und  redirect_uri  ausgef\u00fchrt, welche die OAuth 2.0 App anspricht und f\u00fcr eine Weiterleitung an ownCloud sorgt. Dann wird von ownCloud eine Authentifizierung erfragt, sprich der regul\u00e4re Anmeldebildschirm wird gezeigt, oder die Weiterleitung erfolgt sofort zur Autorisierungsabfrage der OAuth 2.0 App. Nach erfolgter Autorisierung wird zur  redirectURI  aus der  GET authorize  Methode weitergeleitet, sprich zur\u00fcck zum Moodle Plugin.   Anschlie\u00dfend f\u00fchrt das Moodle Plugin die Methode  POST /api/v1/token  aus, die den Authorizationcode an die OAuth 2.0 App sendet und als Antwort einen Access Token erh\u00e4lt.  Nach erfolgter Autorisierung von Moodle mit ownCloud via OAuth 2.0 kann nun der WebDAV Zugriff folgen. Dieser erfolgt mit dem Access Code auf die OAuth WebDAV App. Diese kommuniziert daraufhin mit der OAuth 2.0 App \u00fcber die Methode  GET api/v1/validate  und dem Access Token und pr\u00fcft diesen. Bei erfolgreicher \u00dcberpr\u00fcfung wird dann der WebDAV Zugriff entsprechend erm\u00f6glicht.  \n   TODO:  Sequenzdiagramm einf\u00fcgen.", 
            "title": "Protokollablauf"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#tests", 
            "text": "Zum Testen der PHP-Klassen wurde das Framework  PHPUnit  verwendet. Die aktuelle Testabdeckung ist bei Codecov einsehbar:  .", 
            "title": "Tests"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#continuous-integration", 
            "text": "Als Continuous Integration Integration Tool wurde Travis CI verwendet. Bei jeder \u00c4nderung im  GitHub Repository  wird ein Build angesto\u00dfen, in dem die App mithilfe eines Makefiles f\u00fcr den App Store gebaut wird und anschlie\u00dfend in verschiedenen Umgebungen installiert und getestet wird. Folgende Parameter werden variiert:   PHP Versionen : 5.6, 7.0, 7.1, nightly  Datenbanken : PostgreSQL, MySQL, SQLite  Branches des ownCloud Core :  master   Der aktuelle Build-Status ist bei Travis einsehbar:  .", 
            "title": "Continuous Integration"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#anpassung-der-dav-app", 
            "text": "TODO:  Aktualisieren, \u00fcberf\u00fchren in \"Anpassung des ownCloud Cores\" (s.u.). \nNachdem das OAuth 2.0 Protokoll durch die  oauth2  App bereitgestellt wurde, musste die  WebDAV Schnittstelle  in ownCloud um diese Authentifizierungsmethode erweitert werden. Erreichbar ist diese unter dem Endpunkt  remote.php/webdav .", 
            "title": "Anpassung der dav App"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#authentication-backend", 
            "text": "Eine Anfrage am Endpunkt  remote.php/webdav  wird durch die Datei  appinfo/v1/webdav.php  entgegengenommen. Hier wird mithilfe der  sabre/dav  Bibliothek ein WebDAV-Server gestartet. Nachfolgendes Codebeispiel zeigt die f\u00fcr die Authentifizierung wichtige Stelle.  $authBackend = new \\OCA\\DAV\\Connector\\Sabre\\Auth(\n    \\OC::$server- getSession(),\n    \\OC::$server- getUserSession(),\n    \\OC::$server- getRequest(),\n    \\OC::$server- getTwoFactorAuthManager(),\n    'principals/'\n);  Die Authentifizierung ist in sabre/dav modularisiert, sodass die n\u00f6tigen Anpassungen leicht durchzuf\u00fchren waren. Das im Codebeispiel gezeigte Authentication Backend ist eine von ownCloud implementierte Unterklasse von  AbstractBasic , einer abstrakten Klasse, die bei der Implementierung von Basic Authentication behilflich ist. Gl\u00fccklicherweise existiert in sabre/dav mit der Klasse  AbstractBearer  auch ein entsprechendes Gegenst\u00fcck f\u00fcr Bearer Authentication. Da beide Klassen das  BackendInterface  implementieren, kann ein WebDAV Server mit beiden Authentication Backends gestartet werden.  Die Implementierung von OAuth 2.0 erwies sich damit als ziemlich kurz, wie nachfolgendes Codebeispiel zeigt.  ?php\nnamespace OCA\\DAV\\Connector\\Sabre;\n\nuse Sabre\\DAV\\Auth\\Backend\\AbstractBearer;\nuse OCA\\OAuth2\\Db\\AccessToken;\nuse OCA\\OAuth2\\Db\\AccessTokenMapper;\nuse OCP\\AppFramework\\App;\nuse OCP\\AppFramework\\Db\\DoesNotExistException;\n\n/**\n * OAuth 2.0 authentication backend class.\n */\nclass OAuth2 extends AbstractBearer {\n\n    /**\n     * This is the prefix that will be used to generate principal urls.\n     *\n     * @var string\n     */\n    protected $principalPrefix;\n\n    /**\n     * OAuth2 constructor.\n     *\n     * @param string $principalPrefix\n     */\n    public function __construct($principalPrefix = 'principals/users/') {\n        $this- principalPrefix = $principalPrefix;\n\n        $defaults = new \\OC_Defaults();\n        $this- realm = $defaults- getName();\n    }\n\n    /**\n     * Validates a Bearer token\n     *\n     * This method should return the full principal url, or false if the\n     * token was incorrect.\n     *\n     * @param string $bearerToken\n     * @return string|false\n     */\n    protected function validateBearerToken($bearerToken) {\n        if (!is_string($bearerToken)) {\n            return false;\n        }\n\n        $app = new App('oauth2');\n        /** @var AccessTokenMapper $accessTokenMapper */\n        $accessTokenMapper = $app- getContainer()- query('OCA\\OAuth2\\Db\\AccessTokenMapper');\n\n        try {\n            /** @var AccessToken $accessToken */\n            $accessToken = $accessTokenMapper- findByToken($bearerToken);\n            $userId = $accessToken- getUserId();\n\n            \\OC_Util::setupFS($userId);\n\n            return $this- principalPrefix . $userId;\n        } catch (DoesNotExistException $exception) {\n            return false;\n        }\n    }\n\n}  Neben dem Konstruktur, in der  principalPrefix  sowie das  realm  analog zum Konstruktor der  Auth -Klasse gesetzt werden, musste lediglich die Funktion  validateBearerToken  implementiert werden. Hier wird der in der Anfrage mitgesendete Bearer Token mithilfe vom  AccessTokenMapper  \u00fcberpr\u00fcft. Falls der Access Token g\u00fcltig ist, wird die ID des Nutzers abgefragt, um mit  \\OC_Util::setupFS($userId)  das Dateisystem f\u00fcr den WebDAV Server vorzubereiten. Es wird dann der  principalPrefix  zusammen mit der  userId  zur\u00fcckgegeben. Andernfalls wird  false  zur\u00fcckgegeben, was dazu f\u00fchrt, dass der WebDAV Zugriff verweigert wird.", 
            "title": "Authentication Backend"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#headerabhangige-authentifizierung", 
            "text": "Damit die WebDAV Schnittstelle sowohl \u00fcber die bisherige Basic Authentication als auch \u00fcber OAuth 2.0 funktioniert, musste eine Logik hinzugef\u00fcgt werden, die abh\u00e4ngig vom Authoriaztion Header entscheidet, welches Verfahren anzuwenden ist. Der Ansatzpunkt musste dabei die Datei  appinfo/v1/webdav.php  sein, da hier das Authentication Backend erstellt wird. Folgendes Codebeispiel zeigt, welche \u00c4nderungen notwendig waren.  if (strpos(\\OC::$server- getRequest()- getHeader('Authorization'), 'Bearer') !== false) {\n    // OAuth 2.0\n    $authBackend = new \\OCA\\DAV\\Connector\\Sabre\\OAuth2();\n} else {\n    // Basic Auth\n    $authBackend = new \\OCA\\DAV\\Connector\\Sabre\\Auth(\n        \\OC::$server- getSession(),\n        \\OC::$server- getUserSession(),\n        \\OC::$server- getRequest(),\n        \\OC::$server- getTwoFactorAuthManager(),\n        'principals/'\n    );\n}  Durch die ownCloud-interne Funktion  getHeader  konnte der Authorization Header abgefragt werden. Da f\u00fcr Bearer Authentication das Wort \u201eBearer\u201c in diesem enthalten sein muss, konnte mithilfe der Stringfunktion  strpos  die Logik implementiert werden. Abh\u00e4ngig vom Header wird somit entweder die Klasse  OAuth2  f\u00fcr OAuth 2.0 oder  Auth  f\u00fcr Basic Authentication als Authentication Backend genutzt.", 
            "title": "Headerabh\u00e4ngige Authentifizierung"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#tests_1", 
            "text": "TODO:  Tests hinzuf\u00fcgen beschreiben.", 
            "title": "Tests"
        }, 
        {
            "location": "/owncloud/technische-umsetzung/#anpassung-des-owncloud-cores", 
            "text": "Um die Funktionalit\u00e4ten des OAuth 2.0 Protokolls mit Hilfe der App nutzen zu k\u00f6nnen, mussten die  WebDAV Schnittstelle  und auch die  OCS Schnittstelle  um die Authentifizierungsmethode OAuth 2.0 erweitert werden.\nDazu wurde ein  Pull request  gestellt, um entsprechende \u00c4nderungen durchzuf\u00fchren.", 
            "title": "Anpassung des ownCloud Cores"
        }, 
        {
            "location": "/owncloud/benutzung/", 
            "text": "Benutzung\n\n\nInstallation\n\n\n\n\nHinweis:\n Zur Zeit liegen die Anpassungen der \ndav\n App als \nPull Request\n vor. Falls die \u00c4nderungen angenommen werden, sind sie in einer der n\u00e4chsten ownCloud Versionen enthalten.\n\n\n\n\nDa die \u00c4nderungen zum aktuellen Zeitpunkt noch nicht in den Core aufgenommen wurden, muss der \ndav-oauth\n-Branch des \ngeforkten Repositorys\n geklont werden:\n\n\n$ git clone -b dav-oauth https://github.com/pssl16/core\n\n\n\n\nDanach m\u00fcssen die Dependencies installiert werden. Dazu gen\u00fcgt es, im Verzeichnis des Repositorys folgenden Befehl auszuf\u00fchren:\n\n\n$ make\n\n\n\n\nDie restlichen Installationsschritte unterscheiden sich nicht von denen im \nownCloud Handbuch\n.\n\n\nClientregistrierung\n\n\nZur Clientregistrierung muss in der Eingabemaske der OAuth 2 App in den Adminsettings dem Client ein Name gegeben werden und eine g\u00fcltige URL als \nredirect URI\n angegeben werden. Mit Bet\u00e4tigung des OK-Buttons wird der Client registriert, erh\u00e4lt eine \nClientID\n und ein \nClientsecret\n zugewiesen und wird nun in der Tabelle mit den entsprechenden Attributen dargestellt.\n\n\nL\u00f6schen der Clientregistrierung\n\nUm eine Clientregistrierung zu l\u00f6schen muss in den Adminsettings die tabellarische Ansicht der registrierten Clients ausgew\u00e4hlt werden. Nun kann man bei dem zu l\u00f6schenden Client rechts neben den zugeordneten Attributen auf ein M\u00fclleimer-Symbol klicken, um die entsprechende Clientregistrierung zu l\u00f6schen.\n\n\n\n\nTODO:\n Screenshots einf\u00fcgen.\n\n\n\n\nAuthorization Code Flow\n\n\nDie nachfolgende Abbildung stellt den durch die \noauth2\n App implementierten \nOAuth 2.0 Authorization Code Flow\n dar.\n\n\n\n\n\n  \nTODO:\n Beschreibung der Schritte einf\u00fcgen.\n\n\n\n\nAngepasste WebDAV Schnittstelle\n\n\nWiderrufung der Autorisierung\n\n\nZur Widerrufung der Autorisierung muss diese in den Einstellungen per Klick auf den entsprechenden Button widerrufen werden. Dies ist f\u00fcr den Nutzer in den pers\u00f6nlichen Einstellungen m\u00f6glich, durch Klicken des M\u00fclleimer-Symbols rechts neben dem jeweiligen Eintrag.\n\n\n\n\nTODO:\n Screenshots einf\u00fcgen.", 
            "title": "Benutzung"
        }, 
        {
            "location": "/owncloud/benutzung/#benutzung", 
            "text": "", 
            "title": "Benutzung"
        }, 
        {
            "location": "/owncloud/benutzung/#installation", 
            "text": "Hinweis:  Zur Zeit liegen die Anpassungen der  dav  App als  Pull Request  vor. Falls die \u00c4nderungen angenommen werden, sind sie in einer der n\u00e4chsten ownCloud Versionen enthalten.   Da die \u00c4nderungen zum aktuellen Zeitpunkt noch nicht in den Core aufgenommen wurden, muss der  dav-oauth -Branch des  geforkten Repositorys  geklont werden:  $ git clone -b dav-oauth https://github.com/pssl16/core  Danach m\u00fcssen die Dependencies installiert werden. Dazu gen\u00fcgt es, im Verzeichnis des Repositorys folgenden Befehl auszuf\u00fchren:  $ make  Die restlichen Installationsschritte unterscheiden sich nicht von denen im  ownCloud Handbuch .", 
            "title": "Installation"
        }, 
        {
            "location": "/owncloud/benutzung/#clientregistrierung", 
            "text": "Zur Clientregistrierung muss in der Eingabemaske der OAuth 2 App in den Adminsettings dem Client ein Name gegeben werden und eine g\u00fcltige URL als  redirect URI  angegeben werden. Mit Bet\u00e4tigung des OK-Buttons wird der Client registriert, erh\u00e4lt eine  ClientID  und ein  Clientsecret  zugewiesen und wird nun in der Tabelle mit den entsprechenden Attributen dargestellt.  L\u00f6schen der Clientregistrierung \nUm eine Clientregistrierung zu l\u00f6schen muss in den Adminsettings die tabellarische Ansicht der registrierten Clients ausgew\u00e4hlt werden. Nun kann man bei dem zu l\u00f6schenden Client rechts neben den zugeordneten Attributen auf ein M\u00fclleimer-Symbol klicken, um die entsprechende Clientregistrierung zu l\u00f6schen.   TODO:  Screenshots einf\u00fcgen.", 
            "title": "Clientregistrierung"
        }, 
        {
            "location": "/owncloud/benutzung/#authorization-code-flow", 
            "text": "Die nachfolgende Abbildung stellt den durch die  oauth2  App implementierten  OAuth 2.0 Authorization Code Flow  dar.   \n   TODO:  Beschreibung der Schritte einf\u00fcgen.", 
            "title": "Authorization Code Flow"
        }, 
        {
            "location": "/owncloud/benutzung/#angepasste-webdav-schnittstelle", 
            "text": "", 
            "title": "Angepasste WebDAV Schnittstelle"
        }, 
        {
            "location": "/owncloud/benutzung/#widerrufung-der-autorisierung", 
            "text": "Zur Widerrufung der Autorisierung muss diese in den Einstellungen per Klick auf den entsprechenden Button widerrufen werden. Dies ist f\u00fcr den Nutzer in den pers\u00f6nlichen Einstellungen m\u00f6glich, durch Klicken des M\u00fclleimer-Symbols rechts neben dem jeweiligen Eintrag.   TODO:  Screenshots einf\u00fcgen.", 
            "title": "Widerrufung der Autorisierung"
        }, 
        {
            "location": "/moodle/software-architektur/", 
            "text": "Software Architektur\n\n\nIn Vorbereitung auf unser Projektseminar haben wir verschiedene bestehende Plugins evaluiert. Haupts\u00e4chlich haben wir uns hier an dem \nWebDAV\n und dem \nDropbox\n Plugin orientiert.\n\n\nZur Umsetzung des Projektziels, musste Moodle um n\u00f6tige Funktionalit\u00e4ten erg\u00e4nzt werden, die weder durch den \nmoodle Core\n\nbereitgestellt werden, noch mit Hilfe von externen Plugins hinzugef\u00fcgt werden konnten. Im Folgenden wird beschrieben,\nwie Moodle im Rahmen des Projektes erweitert wurde und welche Auswirkungen sich daraus ergaben.\n\n\nMoodle stellt verschiedene Typen von Plugins\n\n\n\u00dcbersicht \u00fcber die Plugin-Struktur\n\n\nMoodle \nPlugins\n dienen dazu um im Core angebotene Funktionalit\u00e4ten dahingehend zu erweitern, sodass diese den\nindividuellen Bed\u00fcrfnissen des Nutzers entsprechen. Daher eignete sich die Implementierung solcher Plugins ideal zur Umsetzung der definierten Integrationsszenarien.\nIn Moodle wird ein Plugin einer \nKategorie\n zugeordnet, welche eine bestimmte Art von Funktionalit\u00e4t repr\u00e4sentiert.\n\n\nDas \nRepository Plugin\n bietet die n\u00f6tigen Schnittstellen um Dateien aus Sciebo nach Moodle hochzuladen. Um weitere Integrationszenarien zu realisieren, haben wir uns f\u00fcr ein erg\u00e4nzendes \nActivity Module\n\nentschieden. Basierend auf dieser Entscheidung haben wir den \nAuthentifizierungsprozess\n in einem eigenen Plugin implementiert, sodass allen zus\u00e4tzlichen Plugins der Zugriff auf das Verfahren erm\u00f6glicht wird.\n\n\n\n\n\n\n\n\nPlugintyp\n\n\nBeschreibung\n\n\nZweck f\u00fcr das Projekt\n\n\n\n\n\n\n\n\n\n\nadmin tool\n oauth2sciebo\n\n\nBietet Dienste zur Site-Administration an\n\n\nVerwaltung der Authentifizierung mittels OAuth 2.0\n\n\n\n\n\n\nrepository\n sciebo\n\n\nStellt Verbindung zu einer externen Datenquelle her\n\n\nDatenbeschaffung aus Sciebo\n\n\n\n\n\n\nactivity\n collaborativefolders\n\n\nStellt Aktivit\u00e4t in einem Kurs zur Verf\u00fcgung\n\n\nBereitstellung eines Ordners f\u00fcr kollaborative Arbeit\n\n\n\n\n\n\n\n\nAbh\u00e4ngigkeiten\n\n\nDie aus der Aufteilung der Funktionen in verschiedene Plugins resultierenden Abh\u00e4ngigkeiten werden in folgender Abbildung\ndargestellt:\n\n\n\n\nZu beachten ist, dass eine m\u00f6glichst hohe Flexibilit\u00e4t und Modularit\u00e4t bei dem Entwurf der Software Architektur erzielt\nwerden sollte. Das f\u00fchrt zwar mit sich, dass funktionale Plugins (also das \nrepository\n und das \nactivity\n Plugin) nicht\neigenst\u00e4ndig ohne das \nadmin tool\n existieren k\u00f6nnen, allerdings wird weiteren, in Zukunft entwickelten Plugins ebenfalls\nZugriff auf die OAuth 2.0 Schnittstelle in \nSciebo\n bzw. \nownCloud\n erm\u00f6glicht,\nwodurch sich das Projektergebnis zu einer guten Wiederverwendbarkeit qualifiziert.\n\n\nFunktions\u00fcbersicht\n\n\nDie in den verschiedenen Plugins angebotenen Funktionalit\u00e4ten k\u00f6nnen wie folgt zusammengefasst werden:\n\n\n\n\nAdmin Tool\n:\n \noauth2sciebo\n\n\nUmfasst sowohl OAuth 2.0, als auch WebDAV Client.\n\n\nSteuert Protokollablauf von OAuth 2.0 und verwaltet alle dazu n\u00f6tigen Informationen.\n\n\nStellt das Verbindungsst\u00fcck von moodle zu Sciebo bzw. ownCloud\n\n\n\n\n\n\nRepository\n:\n \nsciebo\n\n\nBewerkstelligt die Datenbeschaffung aus Sciebo bzw. ownCloud nach Moodle.\n\n\nErm\u00f6glicht den Upload von Dateien aus einer pers\u00f6nlichen Sciebo Instanz.\n\n\nErm\u00f6glicht die Verlinkung von Dateien aus Sciebo in Moodle.\n\n\n\n\n\n\nActivity Module\n:\n \ncollaborative folders\n\n\nErm\u00f6glicht die Erstellung und Freigabe von Ordern in Sciebo f\u00fcr bestimmte Gruppen in Moodle.", 
            "title": "Software Architektur"
        }, 
        {
            "location": "/moodle/software-architektur/#software-architektur", 
            "text": "In Vorbereitung auf unser Projektseminar haben wir verschiedene bestehende Plugins evaluiert. Haupts\u00e4chlich haben wir uns hier an dem  WebDAV  und dem  Dropbox  Plugin orientiert.  Zur Umsetzung des Projektziels, musste Moodle um n\u00f6tige Funktionalit\u00e4ten erg\u00e4nzt werden, die weder durch den  moodle Core \nbereitgestellt werden, noch mit Hilfe von externen Plugins hinzugef\u00fcgt werden konnten. Im Folgenden wird beschrieben,\nwie Moodle im Rahmen des Projektes erweitert wurde und welche Auswirkungen sich daraus ergaben.  Moodle stellt verschiedene Typen von Plugins", 
            "title": "Software Architektur"
        }, 
        {
            "location": "/moodle/software-architektur/#ubersicht-uber-die-plugin-struktur", 
            "text": "Moodle  Plugins  dienen dazu um im Core angebotene Funktionalit\u00e4ten dahingehend zu erweitern, sodass diese den\nindividuellen Bed\u00fcrfnissen des Nutzers entsprechen. Daher eignete sich die Implementierung solcher Plugins ideal zur Umsetzung der definierten Integrationsszenarien.\nIn Moodle wird ein Plugin einer  Kategorie  zugeordnet, welche eine bestimmte Art von Funktionalit\u00e4t repr\u00e4sentiert.  Das  Repository Plugin  bietet die n\u00f6tigen Schnittstellen um Dateien aus Sciebo nach Moodle hochzuladen. Um weitere Integrationszenarien zu realisieren, haben wir uns f\u00fcr ein erg\u00e4nzendes  Activity Module \nentschieden. Basierend auf dieser Entscheidung haben wir den  Authentifizierungsprozess  in einem eigenen Plugin implementiert, sodass allen zus\u00e4tzlichen Plugins der Zugriff auf das Verfahren erm\u00f6glicht wird.     Plugintyp  Beschreibung  Zweck f\u00fcr das Projekt      admin tool  oauth2sciebo  Bietet Dienste zur Site-Administration an  Verwaltung der Authentifizierung mittels OAuth 2.0    repository  sciebo  Stellt Verbindung zu einer externen Datenquelle her  Datenbeschaffung aus Sciebo    activity  collaborativefolders  Stellt Aktivit\u00e4t in einem Kurs zur Verf\u00fcgung  Bereitstellung eines Ordners f\u00fcr kollaborative Arbeit", 
            "title": "\u00dcbersicht \u00fcber die Plugin-Struktur"
        }, 
        {
            "location": "/moodle/software-architektur/#abhangigkeiten", 
            "text": "Die aus der Aufteilung der Funktionen in verschiedene Plugins resultierenden Abh\u00e4ngigkeiten werden in folgender Abbildung\ndargestellt:   Zu beachten ist, dass eine m\u00f6glichst hohe Flexibilit\u00e4t und Modularit\u00e4t bei dem Entwurf der Software Architektur erzielt\nwerden sollte. Das f\u00fchrt zwar mit sich, dass funktionale Plugins (also das  repository  und das  activity  Plugin) nicht\neigenst\u00e4ndig ohne das  admin tool  existieren k\u00f6nnen, allerdings wird weiteren, in Zukunft entwickelten Plugins ebenfalls\nZugriff auf die OAuth 2.0 Schnittstelle in  Sciebo  bzw.  ownCloud  erm\u00f6glicht,\nwodurch sich das Projektergebnis zu einer guten Wiederverwendbarkeit qualifiziert.", 
            "title": "Abh\u00e4ngigkeiten"
        }, 
        {
            "location": "/moodle/software-architektur/#funktionsubersicht", 
            "text": "Die in den verschiedenen Plugins angebotenen Funktionalit\u00e4ten k\u00f6nnen wie folgt zusammengefasst werden:   Admin Tool :   oauth2sciebo  Umfasst sowohl OAuth 2.0, als auch WebDAV Client.  Steuert Protokollablauf von OAuth 2.0 und verwaltet alle dazu n\u00f6tigen Informationen.  Stellt das Verbindungsst\u00fcck von moodle zu Sciebo bzw. ownCloud    Repository :   sciebo  Bewerkstelligt die Datenbeschaffung aus Sciebo bzw. ownCloud nach Moodle.  Erm\u00f6glicht den Upload von Dateien aus einer pers\u00f6nlichen Sciebo Instanz.  Erm\u00f6glicht die Verlinkung von Dateien aus Sciebo in Moodle.    Activity Module :   collaborative folders  Erm\u00f6glicht die Erstellung und Freigabe von Ordern in Sciebo f\u00fcr bestimmte Gruppen in Moodle.", 
            "title": "Funktions\u00fcbersicht"
        }, 
        {
            "location": "/moodle/admin-tool/", 
            "text": "Admin Tool: \noauth2sciebo\n\n\nZweck des Plugins\n\n\nWie bereits im Kapitel \nSoftware Architektur\n angeschnitten, ist der Hauptzweck dieses Plugins\ndie Schnittstelle zu Sciebo bzw. ownCloud bereitzustellen. Zu diesem Zweck wird die im Projekt implementierte ownCloud \nApp \nOAuth2\n mit Hilfe eines OAuth 2.0 Clients \u00fcber die WebDAV Schnittstelle angesprochen.\nGleichzeitig kann dieses Plugin auch f\u00fcr \u00e4hnliche externe Datenquellen verwendet werden, sofern diese \u00fcber die n\u00f6tigen\nOAuth 2.0 und WebDAV Schnittstellen verf\u00fcgen.\n\n\nIm Wesentlichen implementiert dieses Plugin das folgende \nIntegrationsszenario\n:\n\n\n\n\nAls \nNutzer\n m\u00f6chte ich OAuth2 benutzen k\u00f6nnen, um mich im Learnweb als Sciebo Nutzer anzumelden.\n\n\n\n\nJedoch betrifft es auch alle anderen Szenarien indirekt, da diese erst durch die Authentifizierung mittels OAuth 2.0 \nerm\u00f6glicht werden k\u00f6nnen.\n\n\nVorgegebene Schnittstelle\n\n\nF\u00fcr Admin Tools ist in moodle lediglich eine schwach definierte Schnittstelle gegeben. Wie in jedem anderen moodle Plugin \nauch, m\u00fcssen zun\u00e4chst einige Standartdateien implementiert werden: \n\n\n\n\nversion.php\n:\n Beschreibt die Versionsnummer des Plugins, die ben\u00f6tigte moodle Version und Abh\u00e4ngigkeiten des Plugins.\n\n\naccess.php\n:\n Legt die Berechtigungen f\u00fcr definierte Aktionen innerhalb des Plugins anhand von Nutzerrollen fest.\n\n\ntool_oauth2sciebo.php\n:\n Beinhaltet Sprachstrings f\u00fcr unterschiedliche Regionen und Sprachen, sodass definierte Strings,\nabh\u00e4ngig von der jeweiligen Sprache, dynamisch angezeigt werden k\u00f6nnen.\n\n\n\n\nZus\u00e4tzlich zu den allgemeinen Plugindateien, sollte unser Admin Tool auch mindestens noch eine Datei namens \nsettings.php\n\nbeinhalten. Diese umfasst alle Einstellungen, die f\u00fcr das Admin Tool geltend dem Administrator der moodle Instanz zur \nVerf\u00fcgung gestellt werden sollen. Nach der Eingabe, wird diese Konfiguration moodle-intern in dem sogenannten \nAdmin Tree\n\ngespeichert. Aus dieser Baumstruktur k\u00f6nnen anschlie\u00dfend ben\u00f6tigte Einstellungen beschafft werden.\n\n\nInsgesamt ergibt sich folgende Struktur von Ordnern und Dateien, die mindestens f\u00fcr die Implementierung des von uns gebrauchten\nAdmin Tools notwendig ist:\n\n\n\n  \nTODO:\n Grafik f\u00fcr Ordnerstruktur einf\u00fcgen.\n\n\n\n\nImplementierung der vorgegebenen Schnittstelle\n\n\nEingabemaske\n\n\nUm die OAuth 2.0 und WebDAV Clients erfolgreich zum Zugriff auf eine entsprechende Sciebo bzw. ownCloud Instanz zu bef\u00e4higen,\nm\u00fcssen diese zun\u00e4chst mit Hilfe ben\u00f6tigter Eingabedaten konfiguriert werden. Diese sollen zentral im Admin Tool eingegeben und\ngespeichert werden k\u00f6nnen, um sie anschlie\u00dfend von anderen Plugins aus nutzen zu k\u00f6nnen. Zu diesem Zweck werden globale Optionen\nwerden, welche instanz\u00fcbergreifend gelten.\n\n\nBen\u00f6tigte Eingaben\n\n\nUm den OAuth 2.0 Protokollablauf zu erm\u00f6glichen, m\u00fcssen folgende Daten im Vorfeld erfasst werden:\n\n\n\n\nClient ID\n:\n wird in ownCloud generiert und dient der Identifizierung eines regstrierten Clients.\n\n\nSecret\n:\n wird ebenfalls in ownCloud generiert und zur Authentifizierung verwendet.\n\n\n\n\nBeide Datens\u00e4tze sind Strings bestehend aus Buchstaben und Zahlen. Daher eignet sich f\u00fcr beide ein Textfeld, welches ausschlie\u00dflich \nalphanumerische Werte erwartet zur Eingabe.\n\n\nZur Nutzung des WebDAV Clients werden dar\u00fcber hinaus folgende Daten ben\u00f6tigt:\n\n\n\n\nServer Addresse\n:\n Url \u00fcber die der ownCloud Server erreicht werden kann.\n\n\nServer Pfad\n:\n der angehangene Pfad, \u00fcber den die WebDAV Schnittstelle erreicht werden kann.\n\n\nPort\n:\n Port des WebDAV-Servers.\n\n\nSSL-Verschl\u00fcsselung\n:\n Wahl zwischen HTTP und HTTPS. \n\n\n\n\nW\u00e4hrend die Wahl des Protokolls mittels einer Auswahl aus vorhandenen Optionen abgeboten werden kann, m\u00fcssen die restlichen Werte\nin einem Textfeld erfragt werden. Auch in diesem Fall werden die Variablen nach den zu erwartenden Werten ges\u00e4ubert. Dar\u00fcber hinaus\nwerden alle Eingaben, bis auf dem Port, als notwendig angesehen.\n\n\nExternal Page\n\n\nEine somit notwendige Eingabemaske kann im Rahmen der [\nsettings.php\n] definiert werden. Da zum Zweck der individuellen Validierung und S\u00e4uberung\nder ben\u00f6tigten Parameter die in der \nadminlib.php\n definierten \nKlassen nicht ausreichen, wurde eine \nexterne Seite\n speziell zur Darstellung\ndes notwendigen Formulars erstellt. Die externe Seite, welche \u00fcber die \nindex.php\n Datei aufgerufen wird, sorgt daf\u00fcr, dass\ndie Einstellungen aus dem Formular global in den \nadmin settings\n gespeichert werden. Von dort aus k\u00f6nnen sie, sobald n\u00f6tig ausgelesen\nwerden. Um die externe Seite nun in die Navigation in der Seitenadministration einzubinden, muss diese in der \nsettings.php\n in den \nAdmin Tree eingebunden werden: \n\n\n?php\ndefined('MOODLE_INTERNAL') || die('moodle_internal not defined');\n\n$ADMIN-\nadd('authsettings', new admin_externalpage('tool_oauth2sciebo/auth',\n        'Sciebo OAuth 2.0 Configuration',\n        \n$CFG-\nwwwroot/$CFG-\nadmin/tool/oauth2sciebo/index.php\n));\n\n\n\n\nDas \nadmin_externalpage\n Objekt beschreibt eine externe Seite, die im Admin Tree eingeordnet werden soll. Dazu wird die Seite mit einem\neinzigartigen Namen versehen, einem Anzeigenamen und dem Pfad, \u00fcber den die Seite erreicht werden soll. Neben der externen Seite an\nsich, wird bei der Methode \nadd\n zus\u00e4tzlich \u00fcbergeben, an welcher Stelle die Verkn\u00fcpfung erstellt werden soll. In diesem Fall sind es die\nAuthentifizierungseinstellungen (\nauthsettings\n).\n\n\nNeben der Darstellung des Formulars, verwaltet die externe Seite auch die Speicherung der eigegebenen Daten. Diese werden, \u00e4hnlich wie die\nexterne Seite zuvor, global in den Admin Settings mit Hilfe der Methode \nset_config()\n gespeichert. Sobald also das Formular erfolgreich validiert\nworden ist, werden die Eingabedaten durch einen Aufruf dieser Methode mit der genauen Bezeichnung der Option und dem Wert, den sie im Fomular\nerhalten hat, global abgelegt. Dar\u00fcber hinaus wird \u00fcber die externe Seite auch die R\u00fccksetzung der Daten und der Abbruch der Bearbeitung geregelt.\nZuletzt ist die Seite auch daf\u00fcr zust\u00e4ndig das Formular mit zuvor gesetzten Werten zu f\u00fcllen, die aus den globalen Einstellungen wiederbeschafft werden.\n\n\nFormular\n\n\nUm ein geeignetes Formular zu definieren musste die moodle-interne Klasse \nmoodleform\n erweitert und innerhalb der Funktion \ndefinition()\n\nalle ben\u00f6tigten Eingabefelder definiert werden. Folgende Funktionen wurden dabei verwedet um die Elemente so genau wie m\u00f6glich zu umrei\u00dfen:\n\n\n\n\n\n\n\n\nFunktion\n\n\nBeschreibung\n\n\nBeispiel\n\n\n\n\n\n\n\n\n\n\naddElement\n\n\nF\u00fcgt ein Element zum Formular hinzu\n\n\nTextfeld, Dropdown Men\u00fc, Checkbox\n\n\n\n\n\n\naddRule\n\n\nVersieht ein Element mit einer Regel zur Validierung\n\n\nerforderlich f\u00fcr die Abgabe, nur alphanumerisch\n\n\n\n\n\n\nsetDefault\n\n\nSetzt den Standartwert f\u00fcr ein Element\n\n\n-\n\n\n\n\n\n\nsetType\n\n\nLegt den Parametertypen der Eingabe fest\n\n\nInteger, String, Pfad, roh\n\n\n\n\n\n\n\n\nIm Folgenden wird anhand von zwei Beispielen die Anwendung dieser Funktionen dargestellt:\n\n\n?php\nclass tool_oauth2sciebo_client_form extends moodleform {\n\n    public function definition() {\n        global $CFG;\n\n        $mform = $this-\n_form;\n        // Client ID.\n        $mform-\naddElement('text', 'clientid', get_string('clientid', 'tool_oauth2sciebo'), \n            array('size' =\n '64'));\n        $mform-\naddRule('clientid', get_string('required'), 'required', null, 'client');\n        $mform-\naddRule('clientid', get_string('err_alphanumeric'), 'alphanumeric', null, 'client');\n        $mform-\nsetDefault('clientid', $this-\n_customdata['clientid']);\n        $mform-\nsetType('clientid', PARAM_ALPHANUM);\n\n\n\n\nZun\u00e4chst wird das Client ID Eingabefeld definiert. Hierzu wird zum Formular ein Textfeld hinzugef\u00fcgt, welches den eindeutigen Namen\n\nclientid\n tr\u00e4gt und 64 Felder breit ist. Der Anzeigename des Elements wird \u00fcber ein die Sprachstring-Methode \nget_string\n beschafft.\nDaraufhin wird das Feld als f\u00fcr die Abgabe ben\u00f6tigt markiert und auf alphanumerische Werte beschr\u00e4nkt. Zuletzt wird der Standartwert\nf\u00fcr das Textfeld gesetzt, welcher zuvor durch die externe Seite bei Aufruf \u00fcbergeben wird und zur S\u00e4uberung der Eingabe der Typ des\nElements auf alphanumerisch gestellt.\n\n\n        // Type of server.\n        $mform-\naddElement('select', 'type', get_string('type', 'tool_oauth2sciebo'), \n            array('http' =\n 'HTTP', 'https' =\n 'HTTPS'));\n        $mform-\naddRule('type', get_string('required'), 'required', null, 'client');\n        $mform-\nsetDefault('type', $this-\n_customdata['type']);\n    }\n}\n\n\n\n\nIm zweiten Beispiel wird ein \nselect\n Element zum Formular hinzugef\u00fcgt. Der Unterschied zum Textfeld ist, dass bei einem Dropdown\nMen\u00fc auch verf\u00fcgbare Optionen angegeben werden m\u00fcssen. Au\u00dferdem wird auch dieses Element als ben\u00f6tigt markiert und sein Standartwert\nAus den Aufrufparametern beschafft und gesetzt.\n\n\nAm Ende des Formulares werden zu guter Letzt noch Buttons zur Abgabe des Formulars definiert. Damit ist die Eingabemaske vollst\u00e4ndig. \n\n\nOAuth 2.0 Client\n\n\nDen funktionalen Kern des Plugins stellt der OAuth 2.0 Client dar. Dieser befindet sich in Form der Klasse \nsciebo\n in der\nDatei \nsciebo.php\n in dem \nclasses\n Ordner des Plugins. Diese Klasse steuert sowohl den moodle-seitigen Protokollablauf\nvon OAuth 2.0, als auch den Verbindungsaufbau zu ownCloud mittels WebDAV. Dadurch, dass \nsciebo\n von der im moodle Core\nenthaltenen Klasse \noauth2_client\n erbt, ist ein Gro\u00dfteil des Protokollablaufs bereits abgedeckt.\nDer Konstruktor der Klasse \noauth2_client\n muss mit den \nClient ID\n und \nSecret\n Daten aufgerufen werden. \nDiese werden aus den zuvor angewandten Einstellungen beschafft:\n\n\n?php\n\nnamespace tool_oauth2sciebo;\n\ndefined('MOODLE_INTERNAL') || die();\n\nrequire_once($CFG-\nlibdir . '/oauthlib.php');\n\nuse tool_oauth2sciebo\\sciebo_client;\n\nclass sciebo extends \\oauth2_client {\n\n    /**\n     * Create the DropBox API Client.\n     *\n     * @param   string      $key        The API key\n     * @param   string      $secret     The API secret\n     * @param   string      $callback   The callback URL\n     */\n    public function __construct($callback) {\n        parent::__construct(get_config('tool_oauth2sciebo', 'clientid'),\n            get_config('tool_oauth2sciebo', 'secret'), $callback, '');\n\n\n\n\nZu diesem Zweck wird die Methode \nget_config\n verwendet. Sie gibt den f\u00fcr ein Plugin und einen zuvor einzigartig definierten\nNamen aus dem Admin Tree heraus die dazu gespeicherte Einstellung.\nDar\u00fcber hinaus muss eine \ncallback URL\n angef\u00fcgt werden, die den Pfad angibt, an den nach der Authentifizierung und Authorisierung\nweitergeleitet werden soll. Dieser wird allerdings wird extern in den Plugins erzeugt, die die \nsciebo\n Klasse benutzen.\n\n\nZu beachten ist, dass f\u00fcr die Klasse \nsciebo\n ein namespace definiert wird, womit diese effizient in externen Plugins verwendet werden\nkann, die einen OAuth 2.0 Client ben\u00f6tigen.\n\n\nWeiterhin m\u00fcssen die Methoden \nauth_url\n und \ntoken_url\n der Elternklasse zwingend implementiert werden, um bei der Authentifizierung\nauf die richtigen Pfade zu verweisen:\n\n\n    /**\n    * Returns the auth url for OAuth 2.0 request\n    * @return string the auth url\n    */\n    protected function auth_url() {\n    // Dynamically generated from the admin tool settings.\n        $path = str_replace('remote.php/webdav/', '', get_config('tool_oauth2sciebo', 'path'));\n        return get_config('tool_oauth2sciebo', 'type') . '://' . get_config('tool_oauth2sciebo', 'server') . '/' . $path\n            . 'index.php/apps/oauth2/authorize';\n    }\n\n    /**\n    * Returns the token url for OAuth 2.0 request\n    * @return string the token url\n    */\n    protected function token_url() {\n        $path = str_replace('remote.php/webdav/', '', get_config('tool_oauth2sciebo', 'path'));\n        return get_config('tool_oauth2sciebo', 'type') . '://' . get_config('tool_oauth2sciebo', 'server')  . '/' . $path\n            . 'index.php/apps/oauth2/api/v1/token';\n    }\n\n\n\n\nHierf\u00fcr werden die beiden Pfade aus der Serveraddresse und dem Serverpfad berechnet, da der Endpunkt f\u00fcr die oauth2 App in\nownCloud gleich bleibt.\n\n\n\u00c4nderungen an Core Bibliotheken\n\n\nDu zur Umsetzung des Verfahrens Die vorgegebenen Schnittstellen nicht ausreichten, mussten in Anpassungen in moodles Core \nBibliotheken vorgenommen werden. Im Folgenden werden diese \u00c4nderungen beschrieben.\n\n\nAnpassung der \npost\n Methode\n\n\nDie moodle-interne Klasse \noauth2client\n erbt von einer weiteren Klasse aus dem moodle Core mit dem Namen \ncurl\n, welche mittels\n\nCurl\n HTTP Requests erstellen und verschicken kann. Dadurch ist die Klasse f\u00e4hig eigenst\u00e4ndig einen Access Token mit einem \nAuthorization Code mittels der HTTP POST Methode \u00fcber die \ntoken\n Schnittstelle in ownCloud zu beschaffen. Allerdings\nbietet die daf\u00fcr zust\u00e4ndige Methode \npost\n nicht die M\u00f6glichkeit einen Basic Authorization Header zur Anfrage hinzuzuf\u00fcgen,\nwelcher Client ID und Secret zur Autorisierung in der \noauth2\n ownCloud App mit verschickt. Daher musste die \npost\n Methode\nin der \nsciebo\n Klasse so \u00fcberschrieben werden, dass der Header vor dem Aufruf der geerbten Methode gesetzt wird.\nIn dem zugeh\u00f6rigen Skipt wurde folende Methode erg\u00e4nzt:\n\n\npublic function post($url, $params = '', $options = array()) {\n\n    $this-\nsetHeader(array(\n        'Authorization: Basic ' . base64_encode($this-\nget_clientid() . ':' . $this-\nget_clientsecret())\n        ));\n\n    return parent::post($url, $params, $options);\n}\n\n\n\n\nAnpassung des WebDAV Clients\n\n\nWeiterleitungen\n\n\nTests und CI", 
            "title": "Admin Tool"
        }, 
        {
            "location": "/moodle/admin-tool/#admin-tool-oauth2sciebo", 
            "text": "", 
            "title": "Admin Tool: oauth2sciebo"
        }, 
        {
            "location": "/moodle/admin-tool/#zweck-des-plugins", 
            "text": "Wie bereits im Kapitel  Software Architektur  angeschnitten, ist der Hauptzweck dieses Plugins\ndie Schnittstelle zu Sciebo bzw. ownCloud bereitzustellen. Zu diesem Zweck wird die im Projekt implementierte ownCloud \nApp  OAuth2  mit Hilfe eines OAuth 2.0 Clients \u00fcber die WebDAV Schnittstelle angesprochen.\nGleichzeitig kann dieses Plugin auch f\u00fcr \u00e4hnliche externe Datenquellen verwendet werden, sofern diese \u00fcber die n\u00f6tigen\nOAuth 2.0 und WebDAV Schnittstellen verf\u00fcgen.  Im Wesentlichen implementiert dieses Plugin das folgende  Integrationsszenario :   Als  Nutzer  m\u00f6chte ich OAuth2 benutzen k\u00f6nnen, um mich im Learnweb als Sciebo Nutzer anzumelden.   Jedoch betrifft es auch alle anderen Szenarien indirekt, da diese erst durch die Authentifizierung mittels OAuth 2.0 \nerm\u00f6glicht werden k\u00f6nnen.", 
            "title": "Zweck des Plugins"
        }, 
        {
            "location": "/moodle/admin-tool/#vorgegebene-schnittstelle", 
            "text": "F\u00fcr Admin Tools ist in moodle lediglich eine schwach definierte Schnittstelle gegeben. Wie in jedem anderen moodle Plugin \nauch, m\u00fcssen zun\u00e4chst einige Standartdateien implementiert werden:    version.php :  Beschreibt die Versionsnummer des Plugins, die ben\u00f6tigte moodle Version und Abh\u00e4ngigkeiten des Plugins.  access.php :  Legt die Berechtigungen f\u00fcr definierte Aktionen innerhalb des Plugins anhand von Nutzerrollen fest.  tool_oauth2sciebo.php :  Beinhaltet Sprachstrings f\u00fcr unterschiedliche Regionen und Sprachen, sodass definierte Strings,\nabh\u00e4ngig von der jeweiligen Sprache, dynamisch angezeigt werden k\u00f6nnen.   Zus\u00e4tzlich zu den allgemeinen Plugindateien, sollte unser Admin Tool auch mindestens noch eine Datei namens  settings.php \nbeinhalten. Diese umfasst alle Einstellungen, die f\u00fcr das Admin Tool geltend dem Administrator der moodle Instanz zur \nVerf\u00fcgung gestellt werden sollen. Nach der Eingabe, wird diese Konfiguration moodle-intern in dem sogenannten  Admin Tree \ngespeichert. Aus dieser Baumstruktur k\u00f6nnen anschlie\u00dfend ben\u00f6tigte Einstellungen beschafft werden.  Insgesamt ergibt sich folgende Struktur von Ordnern und Dateien, die mindestens f\u00fcr die Implementierung des von uns gebrauchten\nAdmin Tools notwendig ist:  \n   TODO:  Grafik f\u00fcr Ordnerstruktur einf\u00fcgen.", 
            "title": "Vorgegebene Schnittstelle"
        }, 
        {
            "location": "/moodle/admin-tool/#implementierung-der-vorgegebenen-schnittstelle", 
            "text": "", 
            "title": "Implementierung der vorgegebenen Schnittstelle"
        }, 
        {
            "location": "/moodle/admin-tool/#eingabemaske", 
            "text": "Um die OAuth 2.0 und WebDAV Clients erfolgreich zum Zugriff auf eine entsprechende Sciebo bzw. ownCloud Instanz zu bef\u00e4higen,\nm\u00fcssen diese zun\u00e4chst mit Hilfe ben\u00f6tigter Eingabedaten konfiguriert werden. Diese sollen zentral im Admin Tool eingegeben und\ngespeichert werden k\u00f6nnen, um sie anschlie\u00dfend von anderen Plugins aus nutzen zu k\u00f6nnen. Zu diesem Zweck werden globale Optionen\nwerden, welche instanz\u00fcbergreifend gelten.", 
            "title": "Eingabemaske"
        }, 
        {
            "location": "/moodle/admin-tool/#benotigte-eingaben", 
            "text": "Um den OAuth 2.0 Protokollablauf zu erm\u00f6glichen, m\u00fcssen folgende Daten im Vorfeld erfasst werden:   Client ID :  wird in ownCloud generiert und dient der Identifizierung eines regstrierten Clients.  Secret :  wird ebenfalls in ownCloud generiert und zur Authentifizierung verwendet.   Beide Datens\u00e4tze sind Strings bestehend aus Buchstaben und Zahlen. Daher eignet sich f\u00fcr beide ein Textfeld, welches ausschlie\u00dflich \nalphanumerische Werte erwartet zur Eingabe.  Zur Nutzung des WebDAV Clients werden dar\u00fcber hinaus folgende Daten ben\u00f6tigt:   Server Addresse :  Url \u00fcber die der ownCloud Server erreicht werden kann.  Server Pfad :  der angehangene Pfad, \u00fcber den die WebDAV Schnittstelle erreicht werden kann.  Port :  Port des WebDAV-Servers.  SSL-Verschl\u00fcsselung :  Wahl zwischen HTTP und HTTPS.    W\u00e4hrend die Wahl des Protokolls mittels einer Auswahl aus vorhandenen Optionen abgeboten werden kann, m\u00fcssen die restlichen Werte\nin einem Textfeld erfragt werden. Auch in diesem Fall werden die Variablen nach den zu erwartenden Werten ges\u00e4ubert. Dar\u00fcber hinaus\nwerden alle Eingaben, bis auf dem Port, als notwendig angesehen.", 
            "title": "Ben\u00f6tigte Eingaben"
        }, 
        {
            "location": "/moodle/admin-tool/#external-page", 
            "text": "Eine somit notwendige Eingabemaske kann im Rahmen der [ settings.php ] definiert werden. Da zum Zweck der individuellen Validierung und S\u00e4uberung\nder ben\u00f6tigten Parameter die in der  adminlib.php  definierten \nKlassen nicht ausreichen, wurde eine  externe Seite  speziell zur Darstellung\ndes notwendigen Formulars erstellt. Die externe Seite, welche \u00fcber die  index.php  Datei aufgerufen wird, sorgt daf\u00fcr, dass\ndie Einstellungen aus dem Formular global in den  admin settings  gespeichert werden. Von dort aus k\u00f6nnen sie, sobald n\u00f6tig ausgelesen\nwerden. Um die externe Seite nun in die Navigation in der Seitenadministration einzubinden, muss diese in der  settings.php  in den \nAdmin Tree eingebunden werden:   ?php\ndefined('MOODLE_INTERNAL') || die('moodle_internal not defined');\n\n$ADMIN- add('authsettings', new admin_externalpage('tool_oauth2sciebo/auth',\n        'Sciebo OAuth 2.0 Configuration',\n         $CFG- wwwroot/$CFG- admin/tool/oauth2sciebo/index.php ));  Das  admin_externalpage  Objekt beschreibt eine externe Seite, die im Admin Tree eingeordnet werden soll. Dazu wird die Seite mit einem\neinzigartigen Namen versehen, einem Anzeigenamen und dem Pfad, \u00fcber den die Seite erreicht werden soll. Neben der externen Seite an\nsich, wird bei der Methode  add  zus\u00e4tzlich \u00fcbergeben, an welcher Stelle die Verkn\u00fcpfung erstellt werden soll. In diesem Fall sind es die\nAuthentifizierungseinstellungen ( authsettings ).  Neben der Darstellung des Formulars, verwaltet die externe Seite auch die Speicherung der eigegebenen Daten. Diese werden, \u00e4hnlich wie die\nexterne Seite zuvor, global in den Admin Settings mit Hilfe der Methode  set_config()  gespeichert. Sobald also das Formular erfolgreich validiert\nworden ist, werden die Eingabedaten durch einen Aufruf dieser Methode mit der genauen Bezeichnung der Option und dem Wert, den sie im Fomular\nerhalten hat, global abgelegt. Dar\u00fcber hinaus wird \u00fcber die externe Seite auch die R\u00fccksetzung der Daten und der Abbruch der Bearbeitung geregelt.\nZuletzt ist die Seite auch daf\u00fcr zust\u00e4ndig das Formular mit zuvor gesetzten Werten zu f\u00fcllen, die aus den globalen Einstellungen wiederbeschafft werden.", 
            "title": "External Page"
        }, 
        {
            "location": "/moodle/admin-tool/#formular", 
            "text": "Um ein geeignetes Formular zu definieren musste die moodle-interne Klasse  moodleform  erweitert und innerhalb der Funktion  definition() \nalle ben\u00f6tigten Eingabefelder definiert werden. Folgende Funktionen wurden dabei verwedet um die Elemente so genau wie m\u00f6glich zu umrei\u00dfen:     Funktion  Beschreibung  Beispiel      addElement  F\u00fcgt ein Element zum Formular hinzu  Textfeld, Dropdown Men\u00fc, Checkbox    addRule  Versieht ein Element mit einer Regel zur Validierung  erforderlich f\u00fcr die Abgabe, nur alphanumerisch    setDefault  Setzt den Standartwert f\u00fcr ein Element  -    setType  Legt den Parametertypen der Eingabe fest  Integer, String, Pfad, roh     Im Folgenden wird anhand von zwei Beispielen die Anwendung dieser Funktionen dargestellt:  ?php\nclass tool_oauth2sciebo_client_form extends moodleform {\n\n    public function definition() {\n        global $CFG;\n\n        $mform = $this- _form;\n        // Client ID.\n        $mform- addElement('text', 'clientid', get_string('clientid', 'tool_oauth2sciebo'), \n            array('size' =  '64'));\n        $mform- addRule('clientid', get_string('required'), 'required', null, 'client');\n        $mform- addRule('clientid', get_string('err_alphanumeric'), 'alphanumeric', null, 'client');\n        $mform- setDefault('clientid', $this- _customdata['clientid']);\n        $mform- setType('clientid', PARAM_ALPHANUM);  Zun\u00e4chst wird das Client ID Eingabefeld definiert. Hierzu wird zum Formular ein Textfeld hinzugef\u00fcgt, welches den eindeutigen Namen clientid  tr\u00e4gt und 64 Felder breit ist. Der Anzeigename des Elements wird \u00fcber ein die Sprachstring-Methode  get_string  beschafft.\nDaraufhin wird das Feld als f\u00fcr die Abgabe ben\u00f6tigt markiert und auf alphanumerische Werte beschr\u00e4nkt. Zuletzt wird der Standartwert\nf\u00fcr das Textfeld gesetzt, welcher zuvor durch die externe Seite bei Aufruf \u00fcbergeben wird und zur S\u00e4uberung der Eingabe der Typ des\nElements auf alphanumerisch gestellt.          // Type of server.\n        $mform- addElement('select', 'type', get_string('type', 'tool_oauth2sciebo'), \n            array('http' =  'HTTP', 'https' =  'HTTPS'));\n        $mform- addRule('type', get_string('required'), 'required', null, 'client');\n        $mform- setDefault('type', $this- _customdata['type']);\n    }\n}  Im zweiten Beispiel wird ein  select  Element zum Formular hinzugef\u00fcgt. Der Unterschied zum Textfeld ist, dass bei einem Dropdown\nMen\u00fc auch verf\u00fcgbare Optionen angegeben werden m\u00fcssen. Au\u00dferdem wird auch dieses Element als ben\u00f6tigt markiert und sein Standartwert\nAus den Aufrufparametern beschafft und gesetzt.  Am Ende des Formulares werden zu guter Letzt noch Buttons zur Abgabe des Formulars definiert. Damit ist die Eingabemaske vollst\u00e4ndig.", 
            "title": "Formular"
        }, 
        {
            "location": "/moodle/admin-tool/#oauth-20-client", 
            "text": "Den funktionalen Kern des Plugins stellt der OAuth 2.0 Client dar. Dieser befindet sich in Form der Klasse  sciebo  in der\nDatei  sciebo.php  in dem  classes  Ordner des Plugins. Diese Klasse steuert sowohl den moodle-seitigen Protokollablauf\nvon OAuth 2.0, als auch den Verbindungsaufbau zu ownCloud mittels WebDAV. Dadurch, dass  sciebo  von der im moodle Core\nenthaltenen Klasse  oauth2_client  erbt, ist ein Gro\u00dfteil des Protokollablaufs bereits abgedeckt.\nDer Konstruktor der Klasse  oauth2_client  muss mit den  Client ID  und  Secret  Daten aufgerufen werden. \nDiese werden aus den zuvor angewandten Einstellungen beschafft:  ?php\n\nnamespace tool_oauth2sciebo;\n\ndefined('MOODLE_INTERNAL') || die();\n\nrequire_once($CFG- libdir . '/oauthlib.php');\n\nuse tool_oauth2sciebo\\sciebo_client;\n\nclass sciebo extends \\oauth2_client {\n\n    /**\n     * Create the DropBox API Client.\n     *\n     * @param   string      $key        The API key\n     * @param   string      $secret     The API secret\n     * @param   string      $callback   The callback URL\n     */\n    public function __construct($callback) {\n        parent::__construct(get_config('tool_oauth2sciebo', 'clientid'),\n            get_config('tool_oauth2sciebo', 'secret'), $callback, '');  Zu diesem Zweck wird die Methode  get_config  verwendet. Sie gibt den f\u00fcr ein Plugin und einen zuvor einzigartig definierten\nNamen aus dem Admin Tree heraus die dazu gespeicherte Einstellung.\nDar\u00fcber hinaus muss eine  callback URL  angef\u00fcgt werden, die den Pfad angibt, an den nach der Authentifizierung und Authorisierung\nweitergeleitet werden soll. Dieser wird allerdings wird extern in den Plugins erzeugt, die die  sciebo  Klasse benutzen.  Zu beachten ist, dass f\u00fcr die Klasse  sciebo  ein namespace definiert wird, womit diese effizient in externen Plugins verwendet werden\nkann, die einen OAuth 2.0 Client ben\u00f6tigen.  Weiterhin m\u00fcssen die Methoden  auth_url  und  token_url  der Elternklasse zwingend implementiert werden, um bei der Authentifizierung\nauf die richtigen Pfade zu verweisen:      /**\n    * Returns the auth url for OAuth 2.0 request\n    * @return string the auth url\n    */\n    protected function auth_url() {\n    // Dynamically generated from the admin tool settings.\n        $path = str_replace('remote.php/webdav/', '', get_config('tool_oauth2sciebo', 'path'));\n        return get_config('tool_oauth2sciebo', 'type') . '://' . get_config('tool_oauth2sciebo', 'server') . '/' . $path\n            . 'index.php/apps/oauth2/authorize';\n    }\n\n    /**\n    * Returns the token url for OAuth 2.0 request\n    * @return string the token url\n    */\n    protected function token_url() {\n        $path = str_replace('remote.php/webdav/', '', get_config('tool_oauth2sciebo', 'path'));\n        return get_config('tool_oauth2sciebo', 'type') . '://' . get_config('tool_oauth2sciebo', 'server')  . '/' . $path\n            . 'index.php/apps/oauth2/api/v1/token';\n    }  Hierf\u00fcr werden die beiden Pfade aus der Serveraddresse und dem Serverpfad berechnet, da der Endpunkt f\u00fcr die oauth2 App in\nownCloud gleich bleibt.", 
            "title": "OAuth 2.0 Client"
        }, 
        {
            "location": "/moodle/admin-tool/#anderungen-an-core-bibliotheken", 
            "text": "Du zur Umsetzung des Verfahrens Die vorgegebenen Schnittstellen nicht ausreichten, mussten in Anpassungen in moodles Core \nBibliotheken vorgenommen werden. Im Folgenden werden diese \u00c4nderungen beschrieben.", 
            "title": "\u00c4nderungen an Core Bibliotheken"
        }, 
        {
            "location": "/moodle/admin-tool/#anpassung-der-post-methode", 
            "text": "Die moodle-interne Klasse  oauth2client  erbt von einer weiteren Klasse aus dem moodle Core mit dem Namen  curl , welche mittels Curl  HTTP Requests erstellen und verschicken kann. Dadurch ist die Klasse f\u00e4hig eigenst\u00e4ndig einen Access Token mit einem \nAuthorization Code mittels der HTTP POST Methode \u00fcber die  token  Schnittstelle in ownCloud zu beschaffen. Allerdings\nbietet die daf\u00fcr zust\u00e4ndige Methode  post  nicht die M\u00f6glichkeit einen Basic Authorization Header zur Anfrage hinzuzuf\u00fcgen,\nwelcher Client ID und Secret zur Autorisierung in der  oauth2  ownCloud App mit verschickt. Daher musste die  post  Methode\nin der  sciebo  Klasse so \u00fcberschrieben werden, dass der Header vor dem Aufruf der geerbten Methode gesetzt wird.\nIn dem zugeh\u00f6rigen Skipt wurde folende Methode erg\u00e4nzt:  public function post($url, $params = '', $options = array()) {\n\n    $this- setHeader(array(\n        'Authorization: Basic ' . base64_encode($this- get_clientid() . ':' . $this- get_clientsecret())\n        ));\n\n    return parent::post($url, $params, $options);\n}", 
            "title": "Anpassung der post Methode"
        }, 
        {
            "location": "/moodle/admin-tool/#anpassung-des-webdav-clients", 
            "text": "", 
            "title": "Anpassung des WebDAV Clients"
        }, 
        {
            "location": "/moodle/admin-tool/#weiterleitungen", 
            "text": "", 
            "title": "Weiterleitungen"
        }, 
        {
            "location": "/moodle/admin-tool/#tests-und-ci", 
            "text": "", 
            "title": "Tests und CI"
        }, 
        {
            "location": "/moodle/repository/", 
            "text": "Repository: \nsciebo\n\n\nZweck des Plugins\n\n\nDer Plugin Typ \nRepository\n wird in Moodle unter anderem verwendet um Nutzer die M\u00f6glichkeit zu schaffen Zugang zu\nDateien aus externen Quellen zu bekommen. Das Repository Plugin Sciebo kann somit die User Stories \nZwei\n und \nDrei\n realisieren. Sobald der Admin das Plugin unter \nSite administration\nPlugins \nRepositories\nManage repositories\n aktiviert hat, sieht der Nutzer im File Picker folgende Optionen:\n\n\n(Mehr Informationen zum File Picker finden sie in der \nMoodle Dokumentation\n)\n\n\n\n  \nTODO:\n BILD nach richtiger Benennung.\n\n\nWenn der Nutzer auf den anmelde Button klickt, wird er zu einem Pop-up Window weitergeleitet, dass ihn auffordert sich in der zugeh\u00f6rigen ownCloud Istanz zu authentifizieren. Sobald der Nutzer sich hier einmalig authentifiziert hat, werden ihm im File Picker seine Dateien angezeigt. Das Plugin bietet dem Benutzer zus\u00e4tzliche Vorteile\ndadurch, dass die Authentifizierung nur einmalig erfolgt. Durch den OAuth2 Protokollablauf werden danach Refresh Tokens angefordert ohne dass der Nutzer dies im Front-End zu sehen bekommt. Somit kann der Nutzer angemeldet bleiben w\u00e4hrend verschiedenen Sessions.\n\n\nVorgegebene Schnittstelle\n\n\nWie auch im \nAdmin Tool\n m\u00fcssen zun\u00e4chst einige Standartschnittstellen implementiert werden:\n\n\n\n\nversion.php\n:\n Beschreibt die Versionsnummer des Plugins, die ben\u00f6tigte moodle Version und Abh\u00e4ngigkeiten des Plugins.\n\n\ndb/access.php\n:\n Legt die Berechtigungen f\u00fcr definierte Aktionen innerhalb des Plugins anhand von Nutzerrollen fest.\n\n\nlang/en/repository__sciebo.php\n:\n Beinhaltet Sprachstrings f\u00fcr unterschiedliche Regionen und Sprachen, sodass definierte Strings,\nabh\u00e4ngig von der jeweiligen Sprache, dynamisch angezeigt werden k\u00f6nnen. Als Standard wird eine englische Sprachdatei erwartet.\n\n\n\n\nF\u00fcr Repository-Plugins m\u00fcssen au\u00dferdem folgende Dateien implementiert werden:\n\n\n\n\npix/icon.png\n:\n Hier wird ein 16x16 icon platziert, welches f\u00fcr das Plugin genutzt wird.\n\n\nlib.php\n:\n Hier wird eine Klasse \nrepository_sciebo extends repository\n deklariert, die als Hauptaufgabe die Integration in den File Picker verwaltet.\n\n\n\n\nImplementierung der vorgegebenen Schnittstelle\n\n\nImplementierung der \nlib.php\n\n\nIn der lib.php wird eine Klasse definiert die von der abstrakten Klasse \nrepository\n erbt. Im Folgenden wird darauf eingegangen wie die vorgegebenen Funktionen implementiert wurden.\n\n\n__construct()\n\n\nDiese Funktion wird jedes mal aufgerufen, wenn eine Instanz des Plugins erstellt wird. Hier wird ein Objekt der sciebo Klasse des Admin tools erzeugt, das als Parameter eine returnurl \u00fcbergeben bekommt.\n\n\n$returnurl = new moodle_url('/repository/repository_callback.php', [\n    'callback'  =\n 'yes',\n    'repo_id'   =\n $repositoryid,\n    'sesskey'   =\n sesskey(),\n]);\n$this-\nsciebo = new sciebo($returnurl);\n\n\n\n\nDer \ncallback url\n werden als Parameter noch zus\u00e4tzlich die id und der sesskey \u00fcbergeben, damit die Sitzung nach der Authentifizierung in ownCloud wieder hergestellt werden kann.\n\n\nDes weiteren wird die Parent Methode aufgerufen, die die n\u00f6tigen Datenbankeintr\u00e4ge t\u00e4tigt.\n\n\nget_file()\n\n\nDiese Funktion stellt eine Schnittstelle zum oauht2 Objekt des Admin tools bereit. Die Funktion \u00fcberpr\u00fcft ob schon eine offene Verbindung besteht mit Hilfe der Methode \nsciebo-\ndav-\nopen()\n. Falls keine Verbindung besteht wird die Funktion \n$this-\nsciebo-\nget_file();\n aufgerufen. Die Funktion \u00e4hnelt sehr der Funktion des \nWebDAV Repository\n, statt Basic Authentication wird jedoch das OAuth2 Protokoll benutzt. Danach wird der Nutzer  mit Hilfe der \nlogout()\n Funktion ausgeloggt. Dies erfolgt auch \u00fcber das Admin tool.\n\n\nget_listing()\n\n\nDiese Funktion wird aufgerufen um im File Picker die verf\u00fcgbaren Dateien anzuzeigen. Als R\u00fcckgabe wird ein Array aller verf\u00fcgbaren Dateien mit spezifischen Informationen \u00fcber diese Dateien erwartet. Bis auf die Authentifizierung funktioniert diese Methode genauso wie die Methode des WebDAV Repository. Am Anfang werden noch grundlegende Einstellungen f\u00fcr die Ansicht definiert:\n\n\n$ret['dynload'] = true;\n\n\n\n\nDies best\u00e4tigt dem File Picker, dass Inhalte dynamisch geladen werden. Das hei\u00dft das wenn z.B. ein Ordner angeklickt wird der File Picker einen Ajax-Request versendet um den Inhalt des Ordners anzeigen zu k\u00f6nnen.\n\n\n$ret['nosearch'] = true;\n\n\n\n\nDieser Parameter verbietet die Suche in den Dateien.\n\n\n$ret['nologin'] = false;\n\n\n\n\nDieser Parameter sorgt daf\u00fcr, dass der Login f\u00fcr jede Instanz notwendig ist. Zus\u00e4tzlich wird dadurch automatisch ein Logout-Button im File Picker generiert.\n\n\nMit Hilfe der sciebo Klasse wird \u00fcberpr\u00fcft ob es sich um eine Datei oder einen Ordner handelt.\n\n\nif (!empty($v['resourcetype']) \n $v['resourcetype'] == 'collection') {\n    // A folder.\n    if ($path != $v['href']) {\n        $folders[strtoupper($title)] = array(\n            'title' =\n rtrim($title, '/'),\n            'thumbnail' =\n $OUTPUT-\npix_url(file_folder_icon(90))-\nout(false),\n            'children' =\n array(),\n            'datemodified' =\n $v['lastmodified'],\n            'path' =\n $v['href']\n        );\n    }\n\n\n\n\nFalls es sich um einen Ordner handelt wird der Titel, ein Ordner als Bild, der Pfad zum Ordner und der Zeitpunkt des letzten Zugriffs gespeichert.\n\n\n} else {\n    // A file.\n    $size = !empty($v['getcontentlength']) ? $v['getcontentlength'] : '';\n    $files[strtoupper($title)] = array(\n        'title' =\n $title,\n        'thumbnail' =\n $OUTPUT-\npix_url(file_extension_icon($title, 90))-\nout(false),\n        'size' =\n $size,\n        'datemodified' =\n $v['lastmodified'],\n        'source' =\n $v['href']\n    );\n}\n\n\n\n\nFalls es sich um eine Datei handelt wird zus\u00e4tzlich zu den oben genannten Informationen noch die Datei Gr\u00f6\u00dfe gespeichert.\n\n\nMit Hilfe einer \nforeach()\n Schleife wird dies f\u00fcr jede Datei durchgef\u00fchrt. Anschlie\u00dfend werden zuerst Ordner und danach alphabetisch sortiert die Dateien in einem Array gespeichert. Diese Array wird von der Funktion wiedergegeben, Moodle platziert nun die entsprechenden Eintr\u00e4ge im File Picker.\n\n\nget_link()\n\n\nAnstelle einer Datei soll es auch m\u00f6glich sein, einen Downloadlink zu einer existierenden Datei bereitzustellen. Diese wird von dem Modul URL genutzt. Zus\u00e4tzlich besteht die M\u00f6glichkeit im File Picker Dateien zu verlinken. Die zweite Option erlauben wir in unserem Plugin nicht, da uns die Zeit fehlte die zus\u00e4tzliche Funktionalit\u00e4t zu implementieren. Dies haben wir in der Methode \nsupported_returntypes()\n ausgeschlossen.\nDie Implementierung der \nget_link()\n Methode ist nicht trivial da sich der Link abh\u00e4ngig von den Einstellungen im Admin Tool \u00e4ndert.\nMit Hilfe der Funktion \nget_config()\nk\u00f6nnen in Moodle Einstellungen spezifischer Plugins ausgelesen werden. In der Methode wird wiederum die Methode \nget_link()\n des Objektes \nsciebo\n aufgerufen. Um den funktionierenden Downloadlink zur\u00fcck zu geben muss nun noch der Pr\u00e4fix und die Serveraddresse vor den zur\u00fcckgegebenen Pfad gesetzt werden. Desweiteren wird hinter den Pfad noch \n'public.php?service=files\nt=' . $fileid . '\ndownload'\n angef\u00fcgt. Dies ist eine ownCloud spezifische Implementation einen Downloadlink zu generieren. Hier finden sie genauere Informationen zur \nownCloud external API\n.\n\n\n\npublic function get_link($url) {\n\n    $pref = get_config('tool_oauth2sciebo', 'type') . '://';\n\n    $output = $this-\nsciebo-\nget_link($url);\n    $xml = simplexml_load_string($output);\n    $fields = explode(\n/s/\n, $xml-\ndata[0]-\nurl[0]);\n    $fileid = $fields[1];\n\n    $path = str_replace('remote.php/dav/', '', get_config('tool_oauth2sciebo', 'path'));\n\n    return $pref . get_config('tool_oauth2sciebo', 'server'). '/' . $path .\n            'public.php?service=files\nt=' . $fileid . '\ndownload';\n}\n\n\n\n\nprint_login()\n\n\nUm einen Benutzer zum ersten mal mit dem OAuth2 Protokoll anmelden zu k\u00f6nnen, muss er einmalig seinen Benutzer Namen und sein Passwort angeben. Sobald der Nutzer auf den Login Button klickt erscheint ein Pop-up Window oder es \u00f6ffnet sich ein neuer Tab im Browser, indem der Nutzer aufgefordert wird seinen Namen und sein Passwort anzugeben.\n\n\n    $url = $this-\nsciebo-\nget_login_url();\n    if ($this-\noptions['ajax']) {\n        $ret = array();\n        $btn = new \\stdClass();\n        $btn-\ntype = 'popup';\n        $btn-\nurl = $url-\nout(false);\n        $ret['login'] = array($btn);\n        return $ret;\n    } else {\n        echo html_writer::link($url, get_string('login', 'repository'), array('target' =\n '_blank'));\n    }\n\n\n\n\nAls N\u00e4chstes muss der Benutzer die App autorisieren. Nun wird er zu Moodle zur\u00fcckgeleitet. Die Funktion wird nur aufgerufen, falls der Nutzer weder mit seinem token noch mit einem refreshtoken authentifiziert werden kann.\n\n\nRepository spezifische Einstellungen\n\n\nF\u00fcr Repository Plugins gibt es einige Einstellungen die hart kodiert sind und sich nicht auf der Website anpassen lassen. Hierzu geh\u00f6ren folgende Funktionen:\n\n \nsupported_returntypes()\n  m\u00f6gliche R\u00fcckgabetypen sind:\n    * FILE_INTERNAL - Dateien d\u00fcrfen im Moodle Dateien System hoch und runtergeladen werden.\n    * FILE_EXTERNAL - Dateien bleiben im externen Repository und werden von dort bezogen.\n    * FILE_REFERENCE - Dateien werden lokal erstellt, aber werden extern synchronisiert wenn notwendig.\nWir haben FILE_INTERNAL und FILE_EXTERNAL erlaubt, da die Synchronisation von Dateien einen zu gro\u00dfen Implementationsaufwand f\u00fcr unser Projektseminar darstellte.\n\n \nsupported_filetypes()\n  hier wird spezifiziert welche Arten von Dateitypen unterst\u00fctzt werden. Wir haben alle Dateitypen erlaubt.\n\n\nImplementierung der \ndb/access.php\n\n\nStandardm\u00e4\u00dfig muss nur eine \ncapability\n in einem Repository-Plugin definiert werden. Diese hei\u00dft \nview capability\n und beschreibt wer das Repository sehen darf, sobald es vom Site Admin freigegeben und aktiviert wurde.\n\n\n$capabilities = array(\n    'repository/sciebo:view' =\n array(\n        'captype' =\n 'read',\n        'contextlevel' =\n CONTEXT_MODULE,\n        'archetypes' =\n array(\n            'user' =\n CAP_ALLOW\n        )\n    )\n);\n\n\n\n\nIn unserem Fall darf jeder Nutzer das Repository sehen.\n\n\nBesonderheiten der \nversion.php\n\n\nUm sicherzustellen, dass die Authentifizierung korrekt abl\u00e4uft muss das admin-tool oauth2sciebo installiert sein. Dies wird sichergestellt indem in der \nversion.php\n eine Abh\u00e4ngigkeit gesetzt wird:\n\n\n$plugin-\ndependencies = array(\n    'tool_oauth2sciebo' =\n ANY_VERSION);\n\n\n\n\nF\u00fcr genauere Informationen zu der version.php in Moodle sehen sie sich hier die offizielle Dokumentation der \nversion.php\n an.\n\n\nTests und CI", 
            "title": "Repository"
        }, 
        {
            "location": "/moodle/repository/#repository-sciebo", 
            "text": "", 
            "title": "Repository: sciebo"
        }, 
        {
            "location": "/moodle/repository/#zweck-des-plugins", 
            "text": "Der Plugin Typ  Repository  wird in Moodle unter anderem verwendet um Nutzer die M\u00f6glichkeit zu schaffen Zugang zu\nDateien aus externen Quellen zu bekommen. Das Repository Plugin Sciebo kann somit die User Stories  Zwei  und  Drei  realisieren. Sobald der Admin das Plugin unter  Site administration Plugins  Repositories Manage repositories  aktiviert hat, sieht der Nutzer im File Picker folgende Optionen:  (Mehr Informationen zum File Picker finden sie in der  Moodle Dokumentation )  \n   TODO:  BILD nach richtiger Benennung. \nWenn der Nutzer auf den anmelde Button klickt, wird er zu einem Pop-up Window weitergeleitet, dass ihn auffordert sich in der zugeh\u00f6rigen ownCloud Istanz zu authentifizieren. Sobald der Nutzer sich hier einmalig authentifiziert hat, werden ihm im File Picker seine Dateien angezeigt. Das Plugin bietet dem Benutzer zus\u00e4tzliche Vorteile\ndadurch, dass die Authentifizierung nur einmalig erfolgt. Durch den OAuth2 Protokollablauf werden danach Refresh Tokens angefordert ohne dass der Nutzer dies im Front-End zu sehen bekommt. Somit kann der Nutzer angemeldet bleiben w\u00e4hrend verschiedenen Sessions.", 
            "title": "Zweck des Plugins"
        }, 
        {
            "location": "/moodle/repository/#vorgegebene-schnittstelle", 
            "text": "Wie auch im  Admin Tool  m\u00fcssen zun\u00e4chst einige Standartschnittstellen implementiert werden:   version.php :  Beschreibt die Versionsnummer des Plugins, die ben\u00f6tigte moodle Version und Abh\u00e4ngigkeiten des Plugins.  db/access.php :  Legt die Berechtigungen f\u00fcr definierte Aktionen innerhalb des Plugins anhand von Nutzerrollen fest.  lang/en/repository__sciebo.php :  Beinhaltet Sprachstrings f\u00fcr unterschiedliche Regionen und Sprachen, sodass definierte Strings,\nabh\u00e4ngig von der jeweiligen Sprache, dynamisch angezeigt werden k\u00f6nnen. Als Standard wird eine englische Sprachdatei erwartet.   F\u00fcr Repository-Plugins m\u00fcssen au\u00dferdem folgende Dateien implementiert werden:   pix/icon.png :  Hier wird ein 16x16 icon platziert, welches f\u00fcr das Plugin genutzt wird.  lib.php :  Hier wird eine Klasse  repository_sciebo extends repository  deklariert, die als Hauptaufgabe die Integration in den File Picker verwaltet.", 
            "title": "Vorgegebene Schnittstelle"
        }, 
        {
            "location": "/moodle/repository/#implementierung-der-vorgegebenen-schnittstelle", 
            "text": "", 
            "title": "Implementierung der vorgegebenen Schnittstelle"
        }, 
        {
            "location": "/moodle/repository/#implementierung-der-libphp", 
            "text": "In der lib.php wird eine Klasse definiert die von der abstrakten Klasse  repository  erbt. Im Folgenden wird darauf eingegangen wie die vorgegebenen Funktionen implementiert wurden.", 
            "title": "Implementierung der lib.php"
        }, 
        {
            "location": "/moodle/repository/#__construct", 
            "text": "Diese Funktion wird jedes mal aufgerufen, wenn eine Instanz des Plugins erstellt wird. Hier wird ein Objekt der sciebo Klasse des Admin tools erzeugt, das als Parameter eine returnurl \u00fcbergeben bekommt.  $returnurl = new moodle_url('/repository/repository_callback.php', [\n    'callback'  =  'yes',\n    'repo_id'   =  $repositoryid,\n    'sesskey'   =  sesskey(),\n]);\n$this- sciebo = new sciebo($returnurl);  Der  callback url  werden als Parameter noch zus\u00e4tzlich die id und der sesskey \u00fcbergeben, damit die Sitzung nach der Authentifizierung in ownCloud wieder hergestellt werden kann.  Des weiteren wird die Parent Methode aufgerufen, die die n\u00f6tigen Datenbankeintr\u00e4ge t\u00e4tigt.", 
            "title": "__construct()"
        }, 
        {
            "location": "/moodle/repository/#get_file", 
            "text": "Diese Funktion stellt eine Schnittstelle zum oauht2 Objekt des Admin tools bereit. Die Funktion \u00fcberpr\u00fcft ob schon eine offene Verbindung besteht mit Hilfe der Methode  sciebo- dav- open() . Falls keine Verbindung besteht wird die Funktion  $this- sciebo- get_file();  aufgerufen. Die Funktion \u00e4hnelt sehr der Funktion des  WebDAV Repository , statt Basic Authentication wird jedoch das OAuth2 Protokoll benutzt. Danach wird der Nutzer  mit Hilfe der  logout()  Funktion ausgeloggt. Dies erfolgt auch \u00fcber das Admin tool.", 
            "title": "get_file()"
        }, 
        {
            "location": "/moodle/repository/#get_listing", 
            "text": "Diese Funktion wird aufgerufen um im File Picker die verf\u00fcgbaren Dateien anzuzeigen. Als R\u00fcckgabe wird ein Array aller verf\u00fcgbaren Dateien mit spezifischen Informationen \u00fcber diese Dateien erwartet. Bis auf die Authentifizierung funktioniert diese Methode genauso wie die Methode des WebDAV Repository. Am Anfang werden noch grundlegende Einstellungen f\u00fcr die Ansicht definiert:  $ret['dynload'] = true;  Dies best\u00e4tigt dem File Picker, dass Inhalte dynamisch geladen werden. Das hei\u00dft das wenn z.B. ein Ordner angeklickt wird der File Picker einen Ajax-Request versendet um den Inhalt des Ordners anzeigen zu k\u00f6nnen.  $ret['nosearch'] = true;  Dieser Parameter verbietet die Suche in den Dateien.  $ret['nologin'] = false;  Dieser Parameter sorgt daf\u00fcr, dass der Login f\u00fcr jede Instanz notwendig ist. Zus\u00e4tzlich wird dadurch automatisch ein Logout-Button im File Picker generiert.  Mit Hilfe der sciebo Klasse wird \u00fcberpr\u00fcft ob es sich um eine Datei oder einen Ordner handelt.  if (!empty($v['resourcetype'])   $v['resourcetype'] == 'collection') {\n    // A folder.\n    if ($path != $v['href']) {\n        $folders[strtoupper($title)] = array(\n            'title' =  rtrim($title, '/'),\n            'thumbnail' =  $OUTPUT- pix_url(file_folder_icon(90))- out(false),\n            'children' =  array(),\n            'datemodified' =  $v['lastmodified'],\n            'path' =  $v['href']\n        );\n    }  Falls es sich um einen Ordner handelt wird der Titel, ein Ordner als Bild, der Pfad zum Ordner und der Zeitpunkt des letzten Zugriffs gespeichert.  } else {\n    // A file.\n    $size = !empty($v['getcontentlength']) ? $v['getcontentlength'] : '';\n    $files[strtoupper($title)] = array(\n        'title' =  $title,\n        'thumbnail' =  $OUTPUT- pix_url(file_extension_icon($title, 90))- out(false),\n        'size' =  $size,\n        'datemodified' =  $v['lastmodified'],\n        'source' =  $v['href']\n    );\n}  Falls es sich um eine Datei handelt wird zus\u00e4tzlich zu den oben genannten Informationen noch die Datei Gr\u00f6\u00dfe gespeichert.  Mit Hilfe einer  foreach()  Schleife wird dies f\u00fcr jede Datei durchgef\u00fchrt. Anschlie\u00dfend werden zuerst Ordner und danach alphabetisch sortiert die Dateien in einem Array gespeichert. Diese Array wird von der Funktion wiedergegeben, Moodle platziert nun die entsprechenden Eintr\u00e4ge im File Picker.", 
            "title": "get_listing()"
        }, 
        {
            "location": "/moodle/repository/#get_link", 
            "text": "Anstelle einer Datei soll es auch m\u00f6glich sein, einen Downloadlink zu einer existierenden Datei bereitzustellen. Diese wird von dem Modul URL genutzt. Zus\u00e4tzlich besteht die M\u00f6glichkeit im File Picker Dateien zu verlinken. Die zweite Option erlauben wir in unserem Plugin nicht, da uns die Zeit fehlte die zus\u00e4tzliche Funktionalit\u00e4t zu implementieren. Dies haben wir in der Methode  supported_returntypes()  ausgeschlossen.\nDie Implementierung der  get_link()  Methode ist nicht trivial da sich der Link abh\u00e4ngig von den Einstellungen im Admin Tool \u00e4ndert.\nMit Hilfe der Funktion  get_config() k\u00f6nnen in Moodle Einstellungen spezifischer Plugins ausgelesen werden. In der Methode wird wiederum die Methode  get_link()  des Objektes  sciebo  aufgerufen. Um den funktionierenden Downloadlink zur\u00fcck zu geben muss nun noch der Pr\u00e4fix und die Serveraddresse vor den zur\u00fcckgegebenen Pfad gesetzt werden. Desweiteren wird hinter den Pfad noch  'public.php?service=files t=' . $fileid . ' download'  angef\u00fcgt. Dies ist eine ownCloud spezifische Implementation einen Downloadlink zu generieren. Hier finden sie genauere Informationen zur  ownCloud external API .  \npublic function get_link($url) {\n\n    $pref = get_config('tool_oauth2sciebo', 'type') . '://';\n\n    $output = $this- sciebo- get_link($url);\n    $xml = simplexml_load_string($output);\n    $fields = explode( /s/ , $xml- data[0]- url[0]);\n    $fileid = $fields[1];\n\n    $path = str_replace('remote.php/dav/', '', get_config('tool_oauth2sciebo', 'path'));\n\n    return $pref . get_config('tool_oauth2sciebo', 'server'). '/' . $path .\n            'public.php?service=files t=' . $fileid . ' download';\n}", 
            "title": "get_link()"
        }, 
        {
            "location": "/moodle/repository/#print_login", 
            "text": "Um einen Benutzer zum ersten mal mit dem OAuth2 Protokoll anmelden zu k\u00f6nnen, muss er einmalig seinen Benutzer Namen und sein Passwort angeben. Sobald der Nutzer auf den Login Button klickt erscheint ein Pop-up Window oder es \u00f6ffnet sich ein neuer Tab im Browser, indem der Nutzer aufgefordert wird seinen Namen und sein Passwort anzugeben.      $url = $this- sciebo- get_login_url();\n    if ($this- options['ajax']) {\n        $ret = array();\n        $btn = new \\stdClass();\n        $btn- type = 'popup';\n        $btn- url = $url- out(false);\n        $ret['login'] = array($btn);\n        return $ret;\n    } else {\n        echo html_writer::link($url, get_string('login', 'repository'), array('target' =  '_blank'));\n    }  Als N\u00e4chstes muss der Benutzer die App autorisieren. Nun wird er zu Moodle zur\u00fcckgeleitet. Die Funktion wird nur aufgerufen, falls der Nutzer weder mit seinem token noch mit einem refreshtoken authentifiziert werden kann.", 
            "title": "print_login()"
        }, 
        {
            "location": "/moodle/repository/#repository-spezifische-einstellungen", 
            "text": "F\u00fcr Repository Plugins gibt es einige Einstellungen die hart kodiert sind und sich nicht auf der Website anpassen lassen. Hierzu geh\u00f6ren folgende Funktionen:   supported_returntypes()   m\u00f6gliche R\u00fcckgabetypen sind:\n    * FILE_INTERNAL - Dateien d\u00fcrfen im Moodle Dateien System hoch und runtergeladen werden.\n    * FILE_EXTERNAL - Dateien bleiben im externen Repository und werden von dort bezogen.\n    * FILE_REFERENCE - Dateien werden lokal erstellt, aber werden extern synchronisiert wenn notwendig.\nWir haben FILE_INTERNAL und FILE_EXTERNAL erlaubt, da die Synchronisation von Dateien einen zu gro\u00dfen Implementationsaufwand f\u00fcr unser Projektseminar darstellte.   supported_filetypes()   hier wird spezifiziert welche Arten von Dateitypen unterst\u00fctzt werden. Wir haben alle Dateitypen erlaubt.", 
            "title": "Repository spezifische Einstellungen"
        }, 
        {
            "location": "/moodle/repository/#implementierung-der-dbaccessphp", 
            "text": "Standardm\u00e4\u00dfig muss nur eine  capability  in einem Repository-Plugin definiert werden. Diese hei\u00dft  view capability  und beschreibt wer das Repository sehen darf, sobald es vom Site Admin freigegeben und aktiviert wurde.  $capabilities = array(\n    'repository/sciebo:view' =  array(\n        'captype' =  'read',\n        'contextlevel' =  CONTEXT_MODULE,\n        'archetypes' =  array(\n            'user' =  CAP_ALLOW\n        )\n    )\n);  In unserem Fall darf jeder Nutzer das Repository sehen.", 
            "title": "Implementierung der db/access.php"
        }, 
        {
            "location": "/moodle/repository/#besonderheiten-der-versionphp", 
            "text": "Um sicherzustellen, dass die Authentifizierung korrekt abl\u00e4uft muss das admin-tool oauth2sciebo installiert sein. Dies wird sichergestellt indem in der  version.php  eine Abh\u00e4ngigkeit gesetzt wird:  $plugin- dependencies = array(\n    'tool_oauth2sciebo' =  ANY_VERSION);  F\u00fcr genauere Informationen zu der version.php in Moodle sehen sie sich hier die offizielle Dokumentation der  version.php  an.", 
            "title": "Besonderheiten der version.php"
        }, 
        {
            "location": "/moodle/repository/#tests-und-ci", 
            "text": "", 
            "title": "Tests und CI"
        }, 
        {
            "location": "/moodle/activity/", 
            "text": "Aktivit\u00e4t: \ncollaborative folders\n\n\nZweck des Plugins\n\n\nDas Aktivit\u00e4ts Modul \nCollaborative Folders\n soll Lehrenden die M\u00f6glichkeit geben, f\u00fcr Studierende oder Gruppen von Studierenden Ordner f\u00fcr kollaboratives Arbeiten zu erstellen.\nDie Autorisierung und Authentifizierung erfolgt \u00fcber das \noauth2sciebo\n admin tool. Diese Aktivit\u00e4t implementiert die User Story 4:\n\n\n4. Als \nLehrender\n m\u00f6chte ich Studierenden oder Gruppen von Studierenden Ordner f\u00fcr kollaboratives Arbeiten bereitstellen.\n\n\nDer Lehrende kann einem Kurs beliebig viele Instanzen der Aktivit\u00e4t \nCollaborative Folders\n hinzuf\u00fcgen. In den Einstellungen kann der Lehrende\nnun festlegen wie der Ordner im Moodle Kurs benannt werden soll und wie der Ordner in der Sciebo Instanz benannt werden soll.\n\n\n\n\nDesweiteren hat der Lehrende die M\u00f6glichkeit Ordner nur f\u00fcr einzelne Gruppen zu erstellen. In den Einstellungen werden unter dem Men\u00fcpunkt\n\nCreate Shares for single groups\n alle Gruppen des Kurses aufgelistet. Mit einer Checkbox k\u00f6nnen die Gruppen makiert werden, f\u00fcr die pro Gruppe jeweils\nein Ordner erstellt werden soll.\n\n\nVorgegebene Schnittstelle\n\n\nUm sich grundlegend mit der Struktur von \nAktivity modules\n auseinander zu setzen, benutzen sie die Moodle Dokumentation.\nUm das hinzuf\u00fcgen von Ordnern zu erm\u00f6glichen muss ein neutraler Speicherplatz f\u00fcr die Ordner gew\u00e4hlt werden. Es bietet sich an einen hypothetischen Nutzer zu erstellen unter dessen Adresse alle\nOrdner gespeichert werden. Der Admin der Moodle Seite kann in den Admin Einstellungen einmalig einen Nutzer hinzuf\u00fcgen. Sp\u00e4tere \u00c4nderungen sind nicht mehr m\u00f6glich, da\ndies zu Kompilierungsproblemen mit bestehenden Instanzen des Moduls f\u00fchren w\u00fcrde.\n\n\nDie User Story erfordert, zwei Szenarien zu betrachten. Im ersten Szenario wird ein Ordner f\u00fcr alle Studierenden eines Kurses erstellt.\nDie Anforderung an das Modul ist also einen Ordner in dem gespeicherten Account zu erstellender eindeutig Identifizierbar ist.\nDamit keine Synchronisationskonflikte entstehen, erstellt das Modul eine Ordner Struktur. Der jeweils erforderliche Ordner wird in einem\nOrdner erstellt der nach der collaborativefolders_id benannt ist. Dies ist eine Id die jeder Instanz individuell gegeben wird. So kann es soweit manuell\nkeine Ordner erstellt werden zu keinen Synchronisationskonflikten kommen.\n\n\n$directory = $webdavpath . $id;\n            $name = $webdavpath . $id . '/' . $foldername;\n\n            // If one of the folders could not be created, false is returned.\n            if (($this-\nsciebo-\nmake_folder($directory)) != 201) {\n                return false;\n            }\n            if (($this-\nsciebo-\nmake_folder($name)) != 201) {\n                return false;\n            }\n\n\n\n\nIm zweiten Szenario sollen Ordner nur f\u00fcr Gruppen innerhalb eines Kurses erstellt werden. Zu diesem Zweck gibt es den Men\u00fcpunkt \nCreate Shares for single groups\n.\nHier wird f\u00fcr jede Gruppe ein einzelnes Checkbox Element erstellt.\n\n\nforeach ($arrayofgroups as $id =\n $group){\n            $mform-\naddElement('advcheckbox', $group['id'] , $group['name'], ' Number of participants: ' . $group['numberofparticipants'], array(), array(0, 1));\n        }\n\n\n\n\nBeim Auswerten der Form wird nun \u00fcberpr\u00fcft, ob eines der Elemente ausgew\u00e4hlt wurde. Ist dies\nder Fall wird nur der entsprechenden Gruppe oder den entsprechenden Gruppen ein Ordner erstellt.\n\n\nImplementierung der vorgegebenen Schnittstelle\n\n\nTests und CI", 
            "title": "Collaborative Folders"
        }, 
        {
            "location": "/moodle/activity/#aktivitat-collaborative-folders", 
            "text": "", 
            "title": "Aktivit\u00e4t: collaborative folders"
        }, 
        {
            "location": "/moodle/activity/#zweck-des-plugins", 
            "text": "Das Aktivit\u00e4ts Modul  Collaborative Folders  soll Lehrenden die M\u00f6glichkeit geben, f\u00fcr Studierende oder Gruppen von Studierenden Ordner f\u00fcr kollaboratives Arbeiten zu erstellen.\nDie Autorisierung und Authentifizierung erfolgt \u00fcber das  oauth2sciebo  admin tool. Diese Aktivit\u00e4t implementiert die User Story 4:", 
            "title": "Zweck des Plugins"
        }, 
        {
            "location": "/moodle/activity/#4-als-lehrender-mochte-ich-studierenden-oder-gruppen-von-studierenden-ordner-fur-kollaboratives-arbeiten-bereitstellen", 
            "text": "Der Lehrende kann einem Kurs beliebig viele Instanzen der Aktivit\u00e4t  Collaborative Folders  hinzuf\u00fcgen. In den Einstellungen kann der Lehrende\nnun festlegen wie der Ordner im Moodle Kurs benannt werden soll und wie der Ordner in der Sciebo Instanz benannt werden soll.   Desweiteren hat der Lehrende die M\u00f6glichkeit Ordner nur f\u00fcr einzelne Gruppen zu erstellen. In den Einstellungen werden unter dem Men\u00fcpunkt Create Shares for single groups  alle Gruppen des Kurses aufgelistet. Mit einer Checkbox k\u00f6nnen die Gruppen makiert werden, f\u00fcr die pro Gruppe jeweils\nein Ordner erstellt werden soll.", 
            "title": "4. Als Lehrender m\u00f6chte ich Studierenden oder Gruppen von Studierenden Ordner f\u00fcr kollaboratives Arbeiten bereitstellen."
        }, 
        {
            "location": "/moodle/activity/#vorgegebene-schnittstelle", 
            "text": "Um sich grundlegend mit der Struktur von  Aktivity modules  auseinander zu setzen, benutzen sie die Moodle Dokumentation.\nUm das hinzuf\u00fcgen von Ordnern zu erm\u00f6glichen muss ein neutraler Speicherplatz f\u00fcr die Ordner gew\u00e4hlt werden. Es bietet sich an einen hypothetischen Nutzer zu erstellen unter dessen Adresse alle\nOrdner gespeichert werden. Der Admin der Moodle Seite kann in den Admin Einstellungen einmalig einen Nutzer hinzuf\u00fcgen. Sp\u00e4tere \u00c4nderungen sind nicht mehr m\u00f6glich, da\ndies zu Kompilierungsproblemen mit bestehenden Instanzen des Moduls f\u00fchren w\u00fcrde.  Die User Story erfordert, zwei Szenarien zu betrachten. Im ersten Szenario wird ein Ordner f\u00fcr alle Studierenden eines Kurses erstellt.\nDie Anforderung an das Modul ist also einen Ordner in dem gespeicherten Account zu erstellender eindeutig Identifizierbar ist.\nDamit keine Synchronisationskonflikte entstehen, erstellt das Modul eine Ordner Struktur. Der jeweils erforderliche Ordner wird in einem\nOrdner erstellt der nach der collaborativefolders_id benannt ist. Dies ist eine Id die jeder Instanz individuell gegeben wird. So kann es soweit manuell\nkeine Ordner erstellt werden zu keinen Synchronisationskonflikten kommen.  $directory = $webdavpath . $id;\n            $name = $webdavpath . $id . '/' . $foldername;\n\n            // If one of the folders could not be created, false is returned.\n            if (($this- sciebo- make_folder($directory)) != 201) {\n                return false;\n            }\n            if (($this- sciebo- make_folder($name)) != 201) {\n                return false;\n            }  Im zweiten Szenario sollen Ordner nur f\u00fcr Gruppen innerhalb eines Kurses erstellt werden. Zu diesem Zweck gibt es den Men\u00fcpunkt  Create Shares for single groups .\nHier wird f\u00fcr jede Gruppe ein einzelnes Checkbox Element erstellt.  foreach ($arrayofgroups as $id =  $group){\n            $mform- addElement('advcheckbox', $group['id'] , $group['name'], ' Number of participants: ' . $group['numberofparticipants'], array(), array(0, 1));\n        }  Beim Auswerten der Form wird nun \u00fcberpr\u00fcft, ob eines der Elemente ausgew\u00e4hlt wurde. Ist dies\nder Fall wird nur der entsprechenden Gruppe oder den entsprechenden Gruppen ein Ordner erstellt.", 
            "title": "Vorgegebene Schnittstelle"
        }, 
        {
            "location": "/moodle/activity/#implementierung-der-vorgegebenen-schnittstelle", 
            "text": "", 
            "title": "Implementierung der vorgegebenen Schnittstelle"
        }, 
        {
            "location": "/moodle/activity/#tests-und-ci", 
            "text": "", 
            "title": "Tests und CI"
        }, 
        {
            "location": "/moodle/benutzung/", 
            "text": "Benutzung\n\n\nPlugins k\u00f6nnen in Moodle zus\u00e4tzlich installiert werden. Auf der \noffiziellen Seite\n\nvon Moodle k\u00f6nnen alle zurzeit angebotenen Plugins gefunden werden. F\u00fcr mehr Informationen zur allgemeinen Installation von Moodle Plugins\nbenutzen sie die Dokumentation der \nMoodle Seite\n.\n\n\nInstallation\n\n\nWenn sie die Plugins heruntergeladen haben und richtig platziert haben zeigt der Moodle Plugin Manager Ihnen die verf\u00fcgbaren Plugins an.\nSie ben\u00f6tigen in jedem Fall das oauth2_admin_tool, alle anderen Plugins sind von diesem abh\u00e4ngig.\n\n\nAdmin Tool oauth2sciebo\n\n\nEinstellungen\n\n\nDamit das OAuth 2 Protokoll reibungslos ablaufen kann, muss zuerst der Client in den Einstellungen registriert werden.\n\n\nHierf\u00fcr muss der Administrator das Formular des Plugins, das unter \nWebsite-Administration\nPlugins\nAuthentifizierung\nSciebo OAuth 2.0 Configuration\n zu finden ist, ausf\u00fcllen.\nAls erstes Feld muss die Client ID eingegeben werden. Diese findet man in ownCloud, sobald ein neuer Client registriert wurde. Dasselbe gilt f\u00fcr das n\u00e4chste Feld, hier wird das Secret angegeben, dass sich auch aus der ownCloud App kopieren l\u00e4sst.\n\n\nNun werden die Einstellungen f\u00fcr den WebDAV Zugriff festgelegt.\nAls erstes wird die Adresse des ownCloud Servers angegeben.\nIm n\u00e4chsten Feld wird der Pfad zur WebDAV Schnittstelle angegeben in ownCloud endet diese typischerweise mit \nremote.php/webdav/\n.\nAls Protokolltyp kann http oder https angegeben werden. Wenn keine Angabe gemacht wird, wird von http ausgegangen.\nAls letztes kann der Port angegeben werden was meistens nicht notwendig ist.\n\n\nRepository sciebo\n\n\nEinstellungen\n\n\nSobald das Admin tool installiert wurde kann das Repository installiert werden. Bitte beachten Sie, dass die oben genannten Eintr\u00e4ge get\u00e4tigt wurden, ansonsten funktioniert die Authentifizierung des Repositorys nicht. Repositorys Plugins m\u00fcssen in Moodle von einem Administrator unter dem Men\u00fcpunkt \nWebsite-Administration\nPluginsRepositories\n\u00dcbersicht\n aktiviert werden. Der Administrator kann dem Repository zus\u00e4tzlich unter \nEinstellungen\n einen globalen Namen geben.\n\n\nDas Repository ist sowohl in den Kursen als auch f\u00fcr private Instanzen verf\u00fcgbar und muss nicht mehr hinzugef\u00fcgt werden. Kurs Administratoren k\u00f6nnen das Repository jedoch unter \nSpeicherorte\n l\u00f6schen. Die Nutzung l\u00e4sst sich nicht auf bestimmte Nutzer oder Aktivit\u00e4ten im Kurs einschr\u00e4nken.\n\n\ncollaborative_folders\n\n\nEinstellungen\n\n\nAdmin Einstellungen\n\n\nF\u00fcr die Aktivit\u00e4t collaborative_folders wird ein technischer Nutzer der ownCloud Instanz ben\u00f6tigt. Bei diesem Nutzer werden alle Ordner die erstellt werden gespeichert. Um den Nutzer festzulegen muss in \nWebsite-Administration\nPlugins\nAktivit\u00e4ten\ncollaborativefolders\n ein technischer Nutzer mit Hilfe des OAuth2 Protokolls authentifizieren. \u00dcber einen Login Button werden Sie aufgefordert sich in ownCloud zu authentifizieren. Falls Sie nicht richtig weitergeleitet werden, sind die Einstellungen im Admin tool oauth2sciebo fehlerhaft, bitte \u00fcberpr\u00fcfen Sie diese. Achten Sie darauf, dass Sie sich nicht mit Ihrem normalen Account sondern mit dem technischen Nutzer anmelden.\n\n\nSicht des Lehrenden\n\n\nDie Aktivit\u00e4t ist in jedem Moodle Kurs verf\u00fcgbar. Wenn ein Lehrender die Aktivit\u00e4t dem Kurs hinzuf\u00fcgt muss er dem Ordner einen Namen f\u00fcr die Moodle Instanz und einen f\u00fcr die ownCloud Instanz geben. Danach kann festlegt werden ob Lehrende des Kurses Zugriff auf alle erstellten Ordner haben. Eins der wichtigsten Integrationsszenarien ist, dass nur f\u00fcr Gruppen  von Studierenden ein Ordner erstellt wird. Dies ist m\u00f6glich, wenn der Lehrende den Zugriff auf bestimmte Gruppen beschr\u00e4nkt. In diesem Fall werden nur f\u00fcr die gew\u00e4hlten Gruppen einzelne Ordner erstellt.\n\n\nSicht der Studierenden\n\n\nWenn ein Ordner f\u00fcr einen Studierenden freigegeben wurde, sieht dieser die Aktivit\u00e4t in dem Kurs. W\u00e4hlt er diese aus, kann er sich den Ordner herunterladen, oder sich den Ordner in seine Instanz duplizieren. Hat der Studierende keinen Account in der ownCloud Instanz kann er den Ordner herunterladen jedoch nichts in den Ordner laden.", 
            "title": "Benutzung"
        }, 
        {
            "location": "/moodle/benutzung/#benutzung", 
            "text": "Plugins k\u00f6nnen in Moodle zus\u00e4tzlich installiert werden. Auf der  offiziellen Seite \nvon Moodle k\u00f6nnen alle zurzeit angebotenen Plugins gefunden werden. F\u00fcr mehr Informationen zur allgemeinen Installation von Moodle Plugins\nbenutzen sie die Dokumentation der  Moodle Seite .", 
            "title": "Benutzung"
        }, 
        {
            "location": "/moodle/benutzung/#installation", 
            "text": "Wenn sie die Plugins heruntergeladen haben und richtig platziert haben zeigt der Moodle Plugin Manager Ihnen die verf\u00fcgbaren Plugins an.\nSie ben\u00f6tigen in jedem Fall das oauth2_admin_tool, alle anderen Plugins sind von diesem abh\u00e4ngig.", 
            "title": "Installation"
        }, 
        {
            "location": "/moodle/benutzung/#admin-tool-oauth2sciebo", 
            "text": "", 
            "title": "Admin Tool oauth2sciebo"
        }, 
        {
            "location": "/moodle/benutzung/#einstellungen", 
            "text": "Damit das OAuth 2 Protokoll reibungslos ablaufen kann, muss zuerst der Client in den Einstellungen registriert werden.  Hierf\u00fcr muss der Administrator das Formular des Plugins, das unter  Website-Administration Plugins Authentifizierung Sciebo OAuth 2.0 Configuration  zu finden ist, ausf\u00fcllen.\nAls erstes Feld muss die Client ID eingegeben werden. Diese findet man in ownCloud, sobald ein neuer Client registriert wurde. Dasselbe gilt f\u00fcr das n\u00e4chste Feld, hier wird das Secret angegeben, dass sich auch aus der ownCloud App kopieren l\u00e4sst.  Nun werden die Einstellungen f\u00fcr den WebDAV Zugriff festgelegt.\nAls erstes wird die Adresse des ownCloud Servers angegeben.\nIm n\u00e4chsten Feld wird der Pfad zur WebDAV Schnittstelle angegeben in ownCloud endet diese typischerweise mit  remote.php/webdav/ .\nAls Protokolltyp kann http oder https angegeben werden. Wenn keine Angabe gemacht wird, wird von http ausgegangen.\nAls letztes kann der Port angegeben werden was meistens nicht notwendig ist.", 
            "title": "Einstellungen"
        }, 
        {
            "location": "/moodle/benutzung/#repository-sciebo", 
            "text": "", 
            "title": "Repository sciebo"
        }, 
        {
            "location": "/moodle/benutzung/#einstellungen_1", 
            "text": "Sobald das Admin tool installiert wurde kann das Repository installiert werden. Bitte beachten Sie, dass die oben genannten Eintr\u00e4ge get\u00e4tigt wurden, ansonsten funktioniert die Authentifizierung des Repositorys nicht. Repositorys Plugins m\u00fcssen in Moodle von einem Administrator unter dem Men\u00fcpunkt  Website-Administration PluginsRepositories \u00dcbersicht  aktiviert werden. Der Administrator kann dem Repository zus\u00e4tzlich unter  Einstellungen  einen globalen Namen geben.  Das Repository ist sowohl in den Kursen als auch f\u00fcr private Instanzen verf\u00fcgbar und muss nicht mehr hinzugef\u00fcgt werden. Kurs Administratoren k\u00f6nnen das Repository jedoch unter  Speicherorte  l\u00f6schen. Die Nutzung l\u00e4sst sich nicht auf bestimmte Nutzer oder Aktivit\u00e4ten im Kurs einschr\u00e4nken.", 
            "title": "Einstellungen"
        }, 
        {
            "location": "/moodle/benutzung/#collaborative_folders", 
            "text": "", 
            "title": "collaborative_folders"
        }, 
        {
            "location": "/moodle/benutzung/#einstellungen_2", 
            "text": "", 
            "title": "Einstellungen"
        }, 
        {
            "location": "/moodle/benutzung/#admin-einstellungen", 
            "text": "F\u00fcr die Aktivit\u00e4t collaborative_folders wird ein technischer Nutzer der ownCloud Instanz ben\u00f6tigt. Bei diesem Nutzer werden alle Ordner die erstellt werden gespeichert. Um den Nutzer festzulegen muss in  Website-Administration Plugins Aktivit\u00e4ten collaborativefolders  ein technischer Nutzer mit Hilfe des OAuth2 Protokolls authentifizieren. \u00dcber einen Login Button werden Sie aufgefordert sich in ownCloud zu authentifizieren. Falls Sie nicht richtig weitergeleitet werden, sind die Einstellungen im Admin tool oauth2sciebo fehlerhaft, bitte \u00fcberpr\u00fcfen Sie diese. Achten Sie darauf, dass Sie sich nicht mit Ihrem normalen Account sondern mit dem technischen Nutzer anmelden.", 
            "title": "Admin Einstellungen"
        }, 
        {
            "location": "/moodle/benutzung/#sicht-des-lehrenden", 
            "text": "Die Aktivit\u00e4t ist in jedem Moodle Kurs verf\u00fcgbar. Wenn ein Lehrender die Aktivit\u00e4t dem Kurs hinzuf\u00fcgt muss er dem Ordner einen Namen f\u00fcr die Moodle Instanz und einen f\u00fcr die ownCloud Instanz geben. Danach kann festlegt werden ob Lehrende des Kurses Zugriff auf alle erstellten Ordner haben. Eins der wichtigsten Integrationsszenarien ist, dass nur f\u00fcr Gruppen  von Studierenden ein Ordner erstellt wird. Dies ist m\u00f6glich, wenn der Lehrende den Zugriff auf bestimmte Gruppen beschr\u00e4nkt. In diesem Fall werden nur f\u00fcr die gew\u00e4hlten Gruppen einzelne Ordner erstellt.", 
            "title": "Sicht des Lehrenden"
        }, 
        {
            "location": "/moodle/benutzung/#sicht-der-studierenden", 
            "text": "Wenn ein Ordner f\u00fcr einen Studierenden freigegeben wurde, sieht dieser die Aktivit\u00e4t in dem Kurs. W\u00e4hlt er diese aus, kann er sich den Ordner herunterladen, oder sich den Ordner in seine Instanz duplizieren. Hat der Studierende keinen Account in der ownCloud Instanz kann er den Ordner herunterladen jedoch nichts in den Ordner laden.", 
            "title": "Sicht der Studierenden"
        }
    ]
}